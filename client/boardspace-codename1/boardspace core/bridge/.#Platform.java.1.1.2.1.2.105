package bridge;

import static com.codename1.util.MathUtil.atan2;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.Writer;
import java.net.URI;
import java.util.Calendar;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.TimeZone;

import com.codename1.io.FileSystemStorage;
import com.codename1.io.Log;
import com.codename1.io.Storage;
import com.codename1.system.NativeInterface;
import com.codename1.system.NativeLookup;
import com.codename1.ui.Component;
import com.codename1.ui.Display;
import com.codename1.ui.EncodedImage;
import com.codename1.ui.Font;
import lib.Graphics;
import lib.Image;
import lib.LFrameProtocol;

import com.codename1.ui.Stroke;
import com.codename1.ui.URLImage;
import com.codename1.ui.URLImage.ImageAdapter;
import com.codename1.ui.geom.Dimension;
import com.codename1.ui.geom.GeneralPath;
import com.codename1.ui.geom.Point;
import com.codename1.ui.geom.Rectangle;
import com.codename1.ui.geom.Rectangle2D;
import com.codename1.ui.geom.Shape;
import com.codename1.ui.util.Resources;

import lib.AwtComponent;
import lib.ChatInterface;
import lib.ChatWidget;
import lib.DataCache;
import lib.ExtendedHashtable;
import lib.G;
import lib.Http;

class DummyAdapter implements ImageAdapter
{	
	public EncodedImage adaptImage(EncodedImage downloadedImage,
			EncodedImage placeholderImage) {
		return(downloadedImage);
	}

	public boolean isAsyncAdapter() {
		return false;
	}
	
}

class LogCapture extends Log
{	Log oldLog;
	StringWriter myWriter;
	LogCapture() 
	{ oldLog = Log.getInstance();
	  install(this);  
	}
	protected Writer createWriter() throws IOException 
	{	return(myWriter = new StringWriter());
	}
	
	public String dispose()
	{
		install(oldLog);
		return(myWriter==null ? "" : myWriter.toString());
	}
    public static void setRotation(Graphics g,double ang,int cx,int cy)
    {	
    	if(g!=null) { g.setRotation(ang,cx,cy); }
    }
 
}

/*
 * resource bundle is a cache on the resources provided by codename1,
 * and also wraps some really awful APIs into more reasonable ones.
 * 
 */
class ResourceBundle
{	
	Resources res = null;
	String resFile = "";
	String dataNames[] = null;
	String imageNames[] = null;
	boolean loadedOK = false;
	
	// constructor for resources embedded in the app
	 ResourceBundle(String file)
	 {	
		resFile = file;
		loadedOK = false;
		try {
		//G.print("Loading resource bundle "+file+":"+firstName);
		res = Resources.open(file);
    	dataNames = res.getDataResourceNames();
    	imageNames = res.getImageResourceNames();
    	loadedOK = true;
		} catch (IOException err)
		{
 		G.print("Resource file missing "+file+ ":"+err);
		}	
	 }
	 // constructor for resources in the data cache
	 ResourceBundle(File in,String name)
	 {	resFile = name;
	 	loadedOK = false;
		try {
		 res = Resources.open(new FileInputStream(in));
		 dataNames = res.getDataResourceNames();
		 imageNames = res.getImageResourceNames();
		 loadedOK = true;
	 	} 
	 	catch (IOException err)
 		{
 		G.print("Appdata resource file missing "+in+ ":"+err);
 		}	
	 }

	 // return true of name is an image in this bundle
    public boolean isImage(String name)
    {	// what a terrible API.  isImage is defined to get a NullPointerException
    	try {
    		if(res!=null) { return(res.isImage(name)); }
    	}catch (NullPointerException e) {};
    	return(false);
    }
    // return true if name is a data file in this bundle
    public boolean isData(String name)
    {
    	try {
    		if(res!=null) { return(res.isData(name)); }
    	} catch (NullPointerException e) { }
    	return(false);
    }
    // get a data file from this bundle
    public InputStream getData(String name)
    {	
    	return(res.getData(name));
    }
    // get an image from this bundle
    public void getImage(String name,SystemImage im)
    {	im.setImage(res.getImage(name));
    }
    
}

//
// this class nulls the printStackTrace method to shut up getStackTrace
//
class ErrorTrace extends Error 
{ 	public ErrorTrace(String n) { super(n); }
	public void printStackTrace() { }
}

public abstract class Platform implements Config{
	  
	 protected static InstallerPackage installerPackage = NativeLookup.create(InstallerPackage.class);
	 /**
	 * synchronized because two processes (lobby and loadthread for example) may try
	 * to create the first instance of a class at the same time, leading to conflicts
	 * creating required classes
	 */
		public static synchronized Object MakeInstance(String classname)
	{	String expname = "";
	    try
	    {	expname = G.expandClassName(classname);
	    	Class<?>cl = G.classForName(expname,false);
	    	if(cl==null) { throw new ClassNotFoundException(); }
	        return (cl.newInstance()); //was clazz.newInstance()
	    }
	    catch (Exception e)
	    {
	    	throw G.Error(expname+":"+e.toString());
	    }

		}
    /** 
     * 
     * @param gc the current gc or null
     * @param sh the next clipping region or null
     * normally sh would be the old value received from combinedClip
     */
    public static Rectangle setClip(Graphics gc,Shape sh)
    {	Rectangle val = null;
    	if(gc!=null) 
    		{ val = getClipBounds(gc);
    		  
    		  if(sh instanceof Rectangle)
    		  {
    		  Rectangle rs = (Rectangle)sh;
    		  gc.setClip(Left(rs),Top(rs),Width(rs),Height(rs));
    		  }
    		  else if(sh==null)
    		  	{ 	
    		  		gc.setClip(0,0,9999,9999);
     		  	}
    		  else { G.Error("Non rectangular clip region not supported"); }
    		}
    	return(val);
    }
 
    public static Rectangle getClipBounds(Graphics gc)
	{	if(gc!=null)
		{	return(gc.getClipBounds());
		}
		return(null);
	}
	
    
    public static Shape getClip(Graphics gc)
	{	return(getClipBounds(gc));
    }
    /**
     * set the clipping rectangle of the graphics to include one rectangle
     * and exclude the other.  This is used to create the cutout clipping
     * region for the chat window in a way that is compatible with java 1.1
     * 
     * @param gc
     * @param include
     * @param exclude
     */
    public static void setClip(Graphics gc,Rectangle include,Rectangle exclude)
    {  // draw the final result in one swell foop.  This is not implemented
       // in JDK1.1 and causes errors if you try.
    	if(exclude!=null)
    	{
    	Polygon p = new Polygon();
    	p.addRect(include); 
    	p.addRect(exclude); 
    	//gc.setClip(p);
    	G.Error("Non rectangular clipping regions not supported");
    	}
    	else { setClip(gc,include); }
   }

    /**
     * set the color if gc is not null
     * @param gc
     * @param c
     */
    static public void setColor(Graphics gc,Color c)
    {	if(gc!=null) { gc.setColor(c); }
    }
   
    
    static public Color getColor(Graphics gc)
    {
 	   return(gc!=null ? gc.getColor() : null);
    }


	static public void fillOval(Graphics gc,int x,int y,int w,int h)
    {
    	if(gc!=null) { gc.fillOval(x,y, w, h); }
    }
    static public void frameOval(Graphics gc,int x,int y,int w,int h)
    {
    	if(gc!=null) { gc.frameOval(x,y, w, h); }
    }

    /**
     * draw the msg string with the character baseline at x,y
     * 
     * @param inG
     * @param x
     * @param y
     * @param msg
     * @return
     */
    static public void Text(Graphics gc,String msg,int x,int y)
    {
    	if(gc!=null) 
    		{ gc.Text(msg,x,y);
    		}
    }	

    /**
     * 
     * @param gc
     * @param im
     * @param dx
     * @param dy
     * @param fx
     * @param fy
     * @param w
     * @param h
     */
      public static void drawImage(Graphics gc,Image im,
      			int dx,int dy,
      			int fx,int fy,
      			int w,int h)
      {	drawImage(gc,im,dx,dy,dx+w,dy+h,  fx,fy,fx+w,fy+h);
      }
      
      /**
       * Draw an image from/to particular rectangles with rescaling.  Note that
       * this uses left,top,right,bottomt coordinates rather than left,top,width,height 
     * @param dx	dest left
     * @param dy	dest top
     * @param dx2 dest right
     * @param dy2 dest bottom
     * @param fx  source left
     * @param fy  source top
     * @param fx2 source right
     * @param fy2 source bottom
     * @param gc	the gc to be written to
     * @param im	the image to be written from
       */
      public static void drawImage(Graphics gc0,Image im0,
  			int dx,int dy,int dx2,int dy2,
  			int fx,int fy,int fx2,int fy2)
  {	if(gc0!=null)
  	{	gc0.drawImage(im0,dx,dy,dx2,dy2, fx,fy,fx2,fy2);
  	}
  }
	  /**
	    * set the font if gc is not null
	    * @param gc
	    * @param f
	    */
	   static public void setFont(Graphics gc,Font f)
	   {	if((gc!=null)&&(f!=null)) 
	   			{ 	int fsize = getFontSize(f);
	   				G.Assert(fsize>0,"not a zero font");
		   			gc.setFont(f); 
	   			}
	   }
	   static public FontMetrics getFontMetrics(AwtComponent c)
	   {
		   return(FontMetrics.getFontMetrics(c.getFont()));
	   }
	   static public FontMetrics getFontMetrics(Graphics inG)
	   {   return(FontMetrics.getFontMetrics(inG));
	   }
	   static public FontMetrics getFontMetrics(Font f)
	   {
		   return(FontMetrics.getFontMetrics(f));
	   }
	   static public FontMetrics getFontMetrics(bridge.Component c) 
	   {
		   return(FontMetrics.getFontMetrics(G.getFont(c.getStyle())));
	   }
	   static public FontMetrics getFontMetrics(ProxyWindow c) 
	   {
		   return(FontMetrics.getFontMetrics(G.getFont(c.getStyle())));
	   }
	   static public void moveToFront(Component c)
	   {
		   MasterForm.moveToFront(c);
	   }
	   static public FontMetrics getFontMetrics(bridge.Component c,Font f) 
	   {
		   return(FontMetrics.getFontMetrics(f));
	   }
	   public enum Style
	   {   Plain(Font.STYLE_PLAIN),
		   Italic(Font.STYLE_ITALIC),
		   Bold(Font.STYLE_BOLD);
		   int s;
		   Style(int style) { s=style;}
	   }

	   public static Hashtable<Font,Integer> fontSize = new Hashtable<Font,Integer>();
	   public static Hashtable<Font,String> fontOrigin = new Hashtable<Font,String>();
	   
	   private static int fontFaceCode(String spec)
	   {
		   if ("monospaced".equalsIgnoreCase(spec)) { return Font.FACE_MONOSPACE; }
		   if ("serif".equalsIgnoreCase(spec)) { return Font.FACE_PROPORTIONAL; }
		   return Font.FACE_SYSTEM;
	   }
	   public static Font getFont(String family,Style style,int size)
		{	
			G.Assert(size>0,"not a zero size font");
			Font f = Font.createSystemFont(fontFaceCode(family),style.s,size);
			if(GetPixelSize(f)==size) 
				{ return(f); 
				}
			return(getFont(f,size));	// convert to a truetype font
			//return(new Font(0, style ,size));
		}
		
		public static Font getFont(Font f,int size)
		{	G.Assert(size>0,"not a zero size font");
			Font fd = f.derive(size,f.getStyle());
			if(GetPixelSize(fd)==size) { return(fd); }

			fontSize.put(fd,size);
			return(fd);
		}
		
		public static  Font getFont(Font f,Style style,int size)
		{	G.Assert(size>0,"not a zero size font");
			Font fd = f.derive(size<=0?getFontSize(f):size,style.s);
			if(GetPixelSize(fd)==size) { return(fd); }
			fontSize.put(fd,size);
			return(fd);
		}
		private static Font defaultFont = null;
		public static Font getGlobalDefaultFont()
		{
			if(defaultFont==null) 
			{ defaultFont = G.getFont("fixed", Style.Plain, (int)(14*G.getDisplayScale()));
			G.print("Ask fontsize "+G.defaultFontSize+" get "+G.getFontSize(defaultFont));

			}
			return(defaultFont);
		}
		
		public static int getFontSize(Font f)
		{	double fs = GetPixelSize(f);
			if(fs>0) { return((int)fs); }
			
			int sz = fontSize.containsKey(f) ? fontSize.get(f) : -1;
			if(sz<0) 
				{ G.Error("Unregistered font "+f+" "+f.isTTFNativeFont()+" "+fs); 
				}
			G.Assert(sz>0,"not a zero size font");
			return(sz);
		}
    //
    // a note about compatability with CodenameOne 
    // they sadly defined Rectangle with hidden variables and getters that return ints
    // standard java defines Rectangle with visible variables and getters that return doubles.
    // use these methods so accidents don't happen.
    //
    /**
     * @param r
     * @return the bottom coordinate of a rectangle
     */

   public static int Bottom(Rectangle r) { return(r.getY()+r.getHeight()); }
   public static int Top(Rectangle r) { return(r.getY()); }

   public static void SetTop(Rectangle r,int v) { r.setY(v); }

   public static int Left(Rectangle r) { return(r.getX()); }
   public static int Left(Point x) { return(x.getX()); }
   public static int Top(Point x) { return(x.getY()); }
   public static void SetTop(Point p,int v) { p.setY(v); }
   public static void SetLeft(Rectangle r,int to) { r.setX(to); }
   public static void SetLeft(Point p,int v) { p.setX(v); }
   
   public static int Right(Rectangle r) { return(r.getX()+r.getWidth()); }

   public static int Width(Image im) { return(im.getWidth()); }
   public static int Width(Rectangle r) { return(r.getWidth()); }
   public static int Width(Dimension d) { return(d.getWidth()); } 
   
   public static int Height(Image im) { return(im.getHeight()); }
   public static int Height(Rectangle r) { return(r.getHeight()); }
   public static int Height(Dimension d) { return(d.getHeight()); }

   public static void SetWidth(Rectangle r,int v) { r.setWidth(v); } 
   public static int centerX(Rectangle r) { return(r.getX()+r.getWidth()/2); }
   public static int centerY(Rectangle r) { return(r.getY()+r.getHeight()/2); }
   
   public static void SetHeight(Rectangle r,int v) { r.setHeight(v); }
   public static void SetRect(Rectangle r,int l,int t,int w,int h)
   {	r.setX(l);
   		r.setY(t);
   		r.setWidth(w);
   		r.setHeight(h);
   }

	public static void setThreadName(Thread th,String na) { }
	
    /** get the current stack trace as a String */
    public static String getStackTrace()
    {
    	ByteArrayOutputStream b = new Utf8OutputStream();
        PrintStream os = Utf8Printer.getPrinter(b);
        try { throw new ErrorTrace("Stack trace");
        } catch (Error e)
        {
        	printStackTrace(e,os);
        	os.flush();
        }
    	return b.toString();
   }
	public static String getStackTrace(Thread th)
	{	// th.getStackTrace() is not implemented by codename1
		return("<thread stack trace not available>");
	}

	public static StackTraceElement[] getStackTraceElements(Thread th)
	{	// th.getStackTrace() is not implemented by codename1
		return(null);
	}

	public static Dimension getMinimumSize(Component c)
	{
		return(c.getPreferredSize());
	}
	public static Dimension getMaximumSize(Component c)
	{
		return(c.getPreferredSize());
	}
	public static String getStackTrace(Throwable t)
	{	int level = LogCapture.getLevel();
		LogCapture cap = new LogCapture();
		LogCapture.setLevel(99);
		Log.e(t);
		LogCapture.setLevel(level);
		return cap.dispose();	
	}
	//
	// temporary adjustments to the buildable vm
	//
	public static void printStackTrace(Throwable t,PrintStream s)
	{	
		s.println(getStackTrace(t));
	}
	
	public static double GetPixelSize(Font f)
	{	
			return(f.isTTFNativeFont() ? getTTFsize(f) : -1);
	}
	private static double getTTFsize(Font f)
	{	double siz = f.getPixelSize();
		if(siz<=0)
		{
		// try hard to identify the true size of the font.  This is necessitated
		// by codename1 returning the initial font object whose pixel size is
		// actually unknown.
		int originalHeight = f.getHeight();
		int requestedHeight = originalHeight;
		int style = f.getStyle();
		  // this papers over a bug where a font with size 0 is stuck in the cache
		Font f1 = f.derive(requestedHeight,f.getStyle());
		if(f1==f) { requestedHeight++; f1=f.derive(requestedHeight,style); }
		while(f1.getHeight()>originalHeight) 
			{ requestedHeight--; 
			  f1 = f1.derive(requestedHeight, style);
			}
		while(f1.getHeight()<originalHeight)
			{ requestedHeight--;
			  f1 = f1.derive(requestedHeight,style);
			}
		siz = f1.getPixelSize();
		fontSize.put(f,requestedHeight);
		fontOrigin.put(f,"getTTFsize");
		}
		return(siz);
	}
	/**
	 * get the font from a style object, and try to assure that
	 * the result has a known pixel size.
	 * @param style
	 * @return
	 */
	public static Font getFont(com.codename1.ui.plaf.Style style)
	{	Font f = style.getFont();
		double sz = GetPixelSize(f);
		if(sz<=0)
		{	boolean isttf = f.isTTFNativeFont();
			if(isttf && sz==-1)
				{ int oldh = f.getHeight();
				  // this papers over a bug where a font with size 0 is stuck in the cache
				  Font f1 = f.derive(oldh,f.getStyle());
				  if(f1==f) { f1=f.derive(oldh+1,f.getStyle()); }
				  f = f1;
				}
			else {
			String bad = "Unregistered font "+f
				+ " ttf="+isttf
				+ " h=" + f.getHeight()
				+ " s=" + f.getSize()
				+ " px=" + f.getPixelSize()
				;
			G.print(bad);
			f = getGlobalDefaultFont();
			style.setFont(f);
			}
		}
		return(f);
	}
	
	
	@SuppressWarnings("unchecked")
	public static Object clone(Hashtable<?,?>in)
	{
		@SuppressWarnings("rawtypes")
		Hashtable out = new Hashtable();
		for(Enumeration<?> k = in.keys(); k.hasMoreElements();)
		{	Object key = k.nextElement();
			out.put(key,in.get(key));
		}
		return(out);
	}
		
	/**
	 * 
	 * @param i
	 * @return the number of 1's in i
	 */
    public static int bitCount(int i) {	// cribbed from Integer
        // HD, Figure 5-2
        i = i - ((i >>> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 0x3f;
    }
    /**
     * 
     * @param i
     * @return the number of 1's in i
     */
    public static int bitCount(long i) {
        // HD, Figure 5-14
        i = i - ((i >>> 1) & 0x5555555555555555L);
        i = (i & 0x3333333333333333L) + ((i >>> 2) & 0x3333333333333333L);
        i = (i + (i >>> 4)) & 0x0f0f0f0f0f0f0f0fL;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        i = i + (i >>> 32);
        return (int)i & 0x7f;
     }

    public static boolean isEdt()
    {
    	Display dis = Display.getInstance();
    	return(dis.isEdt());
    }
    public static void setEdt() { }

    public static boolean isPlatformTouchInterface()
    {
       	return Display.getInstance().isPureTouch();
    }
    
 
    /**
     * run in the edt thread, which is where GUI operations have to be in codename1.
     * 
     * @param r
     */
    public static void runInEdt(Runnable r)
    {	if(isEdt())
    		{
    		r.run();
    		}
    	else
    		{
    		//System.out.println("Run "+r);
    		Display.getInstance().callSeriallyAndWait(r); 
    		}
    }

    /**
     * start something asynchronously in the edt thread
     * @param r
     */
    public static void startInEdt(Runnable r)
    {	Display.getInstance().callSerially(r); 
    }
    static public Hashtable<String, Class<?>> namedClasses = 
    		NamedClasses.classes;
    		// this hides the class list, which is restored in com.boardspace.Launch
    		// this was a subtrafuge to work around the build process bug which included
    		// all possible headers.  It's no longer necessary as of 5/2017
    		// new Hashtable<String,Class<?>>();
    
    /**
     * get the class file for a specified named class.  If obfuscation is in use, these
     * are essential to untangle the names.  Otherwise, on IOS this is the only way a class
     * can be found, and on android it's still a good idea to be anal about it, even though
     * the android os will late bind the classes.
     * 
     * @param name
     * @param testOnly
     * @return
     */
    @SuppressWarnings("deprecation")
	public static Class<?> classForName(String name,boolean testOnly) 
    {	Class<?>cl = namedClasses.get(name);
    	if(!testOnly && (cl==null) && G.isIOS())
    	{
    	// complain about unlisted classes. in the development environment.
		G.print(Http.stackTrace("unlisted class "+name));
    	}
    	if(cl==null) 
    	{ 	try { cl = Class.forName(name);		// this will actually work on android if there's no obfuscation   	
    	}
    	catch (ClassNotFoundException err)
    		{	if(!testOnly) { G.print(Http.stackTrace(" class "+name+" not found")); }
    		}
    	}
    	return(cl);
    }
    static public double screenDiagonal()
    {
    	double den = G.isAndroid() 
    			? installerPackage.getScreenDPI()
    			: getPPI();	// convert to inches
    	double w = (getScreenWidth()/den);
    	double h = (getScreenHeight()/den);
    	return(Math.sqrt(w*w+h*h)); 	
    }
    static int simulator[] = null;//{1080,2134,450};// { 2134, 1080, 450};	// galaxy s10
    static public int getRealScreenDPI()
    {	if(simulator!=null) { return(simulator[2]); }
    	return ((int)(!isSimulator() && ((installerPackage!=null) && installerPackage.isSupported())
    			? (installerPackage.getScreenDPI())
    			: Display.getInstance().getDeviceDensity()*96/30));
    }
    static public int getScreenWidth()
    {	if(simulator!=null) { return(simulator[0]); }
    	Display con = Display.getInstance();
    	int w = con.getDisplayWidth();
    	return(w);
    }
    static public int getScreenHeight()
    {	if(simulator!=null) { return(simulator[1]);}
    	Display con = Display.getInstance();
    	int h = con.getDisplayHeight();
    	return(h);
    }
    static public String screenSize()
    {
    	double den = getRealScreenDPI();// convert to inches
    	int w = getScreenWidth();
    	int h = getScreenHeight();
    	
    	return("w="+w+" h="+h+" d="+den+" "+(w/den)+"\" x "+(h/den)+"\"");
    }
    
    static public int getPPI() 
	{ 
	  int sz = (int)getRealScreenDPI();
	  if(G.isAndroid()) { sz = Math.max(120, sz); }
	  return (Math.min(300, Math.max(96, sz))); 
	}
    
    static public String replace(String from, String find, String repl)
    {	int index = from.indexOf(find);
    	if(index>=0)
    	{	return( from.substring(0,index) 
    				+ repl + 
    				replace(from.substring(index+find.length()),find,repl));
    	}
    	else { return(from); }
    }
    static public void showDocument(URI u)
    {	
    	try { Display.getInstance().execute(u.toString());
    	}
    	catch (Throwable e)
    	{
    		G.infoEditBox("Sorry, invoking a browser is not supported here",
        			"The URL is "+u);
    	}
    }
    static public void showDocument(String u)
    {	
    	try { Display.getInstance().execute(u);
    	}
    	catch (Throwable e)
    	{ 
    		G.infoEditBox("Sorry, invoking a browser is not supported here",
    				"The URL is "+u);
    	}

    }
	
	public static void infoEditBox(String caption,String infoMessage)
	{	
		// bridge.TextArea is designed for embedding, only works when on top
		// the raw codename1 text area works fine.
		com.codename1.ui.TextArea message = new com.codename1.ui.TextArea(infoMessage);
		message.setEditable(true);
	    JOptionPane.showMessageDialog(null, message, caption, JOptionPane.INFORMATION_MESSAGE);
	}
	
    static public void showDocument(URL u)
    { showDocument(u.toExternalForm()); 
    }

    static final public String getPlatformName() 
    	{ String name = Display.getInstance().getPlatformName();
    	  if("ios".equals(name)) { return(G.Ios); }
    	  if("and".equals(name)) { return(G.Android); }
    	  return(name); 
    	}
    
     

    // guess (pretty reliably) if we are from the amazon app store
    static public boolean isAmazon()
    {	// codename1 magic, get the native package "InstallerPackageImpl"
    	if(G.isAndroid())
    	{
    	try {
    	if(installerPackage != null && installerPackage.isSupported())
    	{	   		
    		String res = installerPackage.getInstaller(installerPackageName);
    		// amazon should be "com.amazon.venezia"
    		return((res!=null) && res.indexOf("amazon")>=0);
    	}
    	} 
    	catch (ThreadDeath err) { throw err;}
    	catch (Throwable err)
    	{
    		Http.postError(installerPackage,"native error ",err);
    	}}
    	return(false);
    }
    public static int getOrientation()
    {	if(G.isAndroid())
    	{
    	try {
    	if(installerPackage != null && installerPackage.isSupported())
    		{	   		
    		int o = installerPackage.getOrientation();
    		return(o);
    		}
    	} 
    	catch (ThreadDeath err) { throw err;}
    	catch (Throwable err)
    	{
    		Http.postError(installerPackage,"native error ",err);
    	}}
    	return(-1);
    }
    public static void setOrientation(boolean portrait,boolean rev)
    {	if(G.isAndroid())
		{
    	try {
    	if(installerPackage != null && installerPackage.isSupported())
    		{	 
    		installerPackage.setOrientation(portrait,rev);
     		}
    	} 
    	catch (Throwable err)
    	{
    		Http.postError(installerPackage,"native error ",err);
    	}}
    }
    public static String getLocalIpAddress()
    {	if(G.isAndroid())
		{
    	try {
    	if(installerPackage != null && installerPackage.isSupported())
    		{	   	
    		return(installerPackage.getLocalWifiIpAddress());
     		}
    	} 
    	catch (Throwable err)
    	{
    		Http.postError(installerPackage,"native error ",err);
    	}}
    	return("unknown");
    }
    static final public boolean isSimulator() 
    {	boolean sim = Display.getInstance().isSimulator();
    	return( sim);
    }
    
    static public String getScreenSize()
    {
    	Display con = Display.getInstance();
    	int width = (int)con.getDisplayWidth();
    	int height = (int)con.getDisplayHeight();
    	return(""+width+"x"+height);
    }

    static public int getFrameWidth() { return(MasterForm.getFrameWidth()); }
    static public int getFrameHeight() { return(MasterForm.getFrameHeight()); }
    static final public boolean isCodename1() { return(true); }
    
    // these methods are used in Codename1 to affect painting strategy
    // they're here so exCanvas can refer to G rather than MasterForm
    static public boolean canRepaintLocally(Component p) { return(MasterForm.canRepaintLocally(p)); }
    static public boolean canRepaintLocally(Graphics g) { return(MasterForm.canRepaintLocally(g)); }
    static public boolean isCompletelyVisible(Component p) { return(MasterForm.isCompletelyVisible(p)); }
    static public boolean isPartlyVisible(Component p) { return(MasterForm.isPartlyVisible(p)); }
    
	
    /**
     * if xname looks like a resource specifier (ie; no http: or file:)
     * return a full url that matches.  This does not test if the resource exists.
     * @param xname
     * @return
     */
    static public final URL getResourceUrl(String xname,boolean doc)
    {	if(G.isResourceName(xname,doc)) 
    		{ try { return(new URL(xname)); }
    		catch (MalformedURLException e) 
    		{ //G.print("malformed url: "+xname+" "+doc+" : "+e);
    		}}
    	return(null);
    }

    public static int imageNumber = 0;
    
    public static Image getImage(URL name)
    {	Image im = new Image(name.urlString);
    	loadImage(name,im);
    	return(im);
    }
    public static void loadImage(URL name,SystemImage toImage)
    {
    	if(name.getProtocol()==null)
    		{ loadImage(name.urlString,toImage);
    		}
    	else
    	{
    	
    	com.codename1.ui.Image placeHolder = Image.createImageFromInts(new int[]{0xa0a0a0},1,1);
    		
    	Storage inst = Storage.getInstance();
    	String prefix = "temp-image-for-getimage-";
		
    	if(imageNumber==0) {
    		// starting fresh, delete temps
    		String files[] = inst.listEntries();
    		if(files!=null)
    		{for(String file : files)
    		{	if(file.startsWith(prefix))
    			{	inst.deleteStorageFile(file);
    				//System.out.println("delete "+file);
    			}
    			}}
    		else { G.print("No files to purge"); }
    		inst.flushStorageCache();
    	}
		
		String tempname = prefix+imageNumber++;

		String namestr = name.urlString;
		try {
		ImageAdapter p=new DummyAdapter(); 
		URLImage im = URLImage.createToStorage(EncodedImage.createFromImage(placeHolder,true), tempname, namestr,p);
		toImage.setImage(im,namestr);
		}
		catch (Throwable err)
		{
			G.print("Error in createImagetoStorage "+namestr+" "+err);
		}
    	}
    }
    
    
    public static Image getImage(String name)
    { 	Image im = new Image(name);
    	loadImage(name,im);
    	return(im);
    }
    public static void loadImage(String name,SystemImage toImage)
    {
    	ResourceBundle res = getResources(name);
    	if(res!=null)
    		{
    		int ind = name.lastIndexOf('/');
    		String localName = ind>=0 ? name.substring(ind+1) : name;
    		if(res.isImage(localName)) { res.getImage(localName,toImage); return; }
    		}
    	G.print("Image ",name," is missing");
    	toImage.createBlankImage(1,1);
    }
    
    public static ResourceBundle bundle = null;
    public static ResourceBundle appdata = null;
    public static String APPDATA ="/appdata";
    public static ResourceBundle getResources(String name)
     {	G.Assert(name!=null,"GetResources with null resource name");
    	String xName = name.charAt(0)=='/' ? name : "/" + name;
    	if(xName.startsWith(APPDATA))
    	{
    	// load from the data cache
    	xName = xName.substring(APPDATA.length());
    	DataCache cache = DataCache.getInstance();
    	int ind = xName.indexOf('/',1);
        String file0 = ind>=0 ? xName.substring(0,ind) : xName;		// resource name including the /
    	String file = file0.endsWith(".res") ? file0 : file0+".res";
    	ResourceBundle res = appdata;
    	if(res==null || !res.resFile.equals(file))
    	{	File f = cache.findResource(file);
    		if(f==null) { G.Error("Appdata resource %s not found",name); }
    		else {
    			G.print("Load resource data "+file);
     		res = new ResourceBundle(f,file);
      		if(res.loadedOK) { appdata = res; } else { res = null; }
    		}
    	}
    	return(res);
    	}
    	else
    	{
    	int ind = xName.indexOf('/',1);
        String file0 = ind>=0 ? xName.substring(0,ind) : xName;
    	String file = file0.endsWith(".res") ? file0 : file0+".res";
    	ResourceBundle res = bundle;
    	if(res==null || !res.resFile.equals(file))
    	{	
    		G.print("Load resource bundle "+file);
    		res = new ResourceBundle(file);
     		if(res.loadedOK) { bundle = res; } else { res = null; }
    	}
    	return(res);
    	}
    }


    
    // getResourceAsStream loads resources from the top level directory
    // of the project, and requires that theres just a /xx in the name
    public static InputStream getResourceAsStream(String name)
			throws IOException
    {
    	String fullName = (name.charAt(0)=='/') ? name : "/"+name;
		int ind = fullName.lastIndexOf('/');
		ResourceBundle res = getResources(name);
		String localName = fullName.substring(ind+1);
		if(res==null) { G.print("resource file "+name+" not found"); }
		else if(res.isData(localName)) { return(res.getData(localName)); }
		else if(res.isImage(localName)) { return(null); }
		else { G.print("Resource "+localName+" in "+name+" not known"); }
	
		return(null);
	}
    
	/**
	 * get the current x translation of the graphics
	 * 
	 * @param g
	 * @return
	 */
	public static int getTranslateX(Graphics g) {  return(g==null?0:g.getTranslateX()); }
	/**
	 * get the current y translation of the graphics
	 * 
	 * @param g
	 * @return
	 */
	public static int getTranslateY(Graphics g) { return(g==null?0:g.getTranslateY()); }

	

    public static void drawFatLine(Graphics g,int fx,int fy,int tx,int ty,double strokeWidth)
    {	if(g!=null)
    	{
    	Stroke s = new Stroke((float)strokeWidth,Stroke.CAP_ROUND,Stroke.JOIN_ROUND,4);
    	GeneralPath path = new GeneralPath();
    	path.moveTo(fx,fy);
    	path.lineTo(tx, ty);
    	g.graphics.drawShape(path,s);
    	}
    }

    static public void drawArrow(Graphics g1, int ox, int oy, int dest_x,
            int dest_y, int ticksize,double thickness)
        {	if(g1!=null)
        	{
        	Stroke s = new Stroke((float)thickness,Stroke.CAP_ROUND,Stroke.JOIN_ROUND,4);
        	GeneralPath path = new GeneralPath();

        	double angle = atan2((dest_y - oy), (dest_x - ox));
        	
        	path.moveTo(ox, oy);
        	path.lineTo(dest_x, dest_y);
        	path.lineTo((int) (dest_x - (Math.cos(angle + (Math.PI / 6)) * ticksize)),
                    (int) (dest_y - (Math.sin(angle + (Math.PI / 6)) * ticksize)));
        	path.moveTo(dest_x, dest_y);
        	path.lineTo((int) (dest_x - (Math.cos(angle - (Math.PI / 6)) * ticksize)),
        			(int) (dest_y - (Math.sin(angle - (Math.PI / 6)) * ticksize)));
        	g1.graphics.drawShape(path,s);
            
        	}
        }
    
    public static boolean getState(Checkbox cb)
    {	return(cb.isSelected());
    }
    public static String getFileSeparator()
    {	return(""+FileSystemStorage.getInstance().getFileSystemSeparator());
    }
    public static String documentBaseDir()
    {
    /*		if(G.isAndroid()) { return("file:/storage/emulated/0/Documents/"); }
    	if(G.isIOS()) 
    	{ String r = "";
    	  String roots[] = FileSystemStorage.getInstance().getRoots();
    	  for(String s : roots) { r += s+"\n"; }
    	  G.print("roots:"+r);
    	  return(roots[0]);
    	}
    */	
    	FileSystemStorage storage = FileSystemStorage.getInstance();

    	String home = storage.getAppHomePath();

    	if(G.isAndroid())
    	{
     		String documents = home+"Documents/";
    		if(storage.isDirectory(documents)) 
    			{ home = documents; 
    			}
    	}
    	return(home);
    	
    }
    public static boolean isPlaytable()
    {	
    	return(G.isAndroid()
        		&& ((screenDiagonal()>13) || isRealPlaytable()));
    }
    public static boolean isGameboard() 
	{  return( false ); 
	}
    public static boolean isTable() { return(isPlaytable()|isGameboard()); }
    
    public static int tableWidth() {
    	return(G.getInt(G.TABLEWIDTH, 1920));
    }
    public static int tableHeight() {
    	return(G.getInt(G.TABLEHEIGHT, 984));
    }
    static String playtablekeys[] = {  " com.blok."};
    static boolean isRealPlaytable = false;
    public static String playtableId = null;
    static String packs = null;
    static String osinfo = null;
    public static boolean isRealPlaytable() 
    { 	String info = getOSInfo();
    	return(isRealPlaytable = info.indexOf("manufacturer=rockchip")>=0);
    	/*
    	synchronized (playtablekeys) 
    	{
    	if (packs==null)
    	{
    	packs = getPackages();    	
    	for(String k : playtablekeys )
    	{	int ind = packs.indexOf(k);
    		if(ind>=0)
    			{
    			isRealPlaytable=true;
    			playtableId = packs.substring(Math.max(0, ind-10),Math.min(packs.length()-1,ind+20));
    			G.print("Real playtable "+k+" "+playtableId);
    			break;  
    			}
    	}}}
    	return(isRealPlaytable);
    	*/
    }
    public static String getPackages()
    {	String packs = null;
    	if((installerPackage!=null)
    		&& installerPackage.isSupported())
    	{
    	packs = installerPackage.getPackages();
    	}
    	if(packs==null) { packs = ""; }
    	return(packs);
    }
    public static boolean logErrorsWithHttp() { return(true /* isRealPlaytable() || !G.debug() */); };
    public static String getOSInfo()
    {	try {
    	if((osinfo==null)
    			&& (installerPackage!=null)
        		&& installerPackage.isSupported())
    			{osinfo = "getting";
    			 osinfo = installerPackage.getOSInfo();
    			}
    	}
    	catch (Throwable e) { osinfo = e.toString(); }
    	if(osinfo==null) { osinfo="none"; }
    	return(osinfo);
    }
	public static String getAppVersion()
	{	String vers = Display.getInstance().getProperty("AppVersion", "Unknown");
		return(vers)	;
	}
	// don't actually set it.
	public static void setAppVersion(String s) { }
	public static int getAvailableProcessors()
	{
		return(1 /* Runtime.getRuntime().availableProcessors()*/);
	}


	public static String[] getFontFamilies()
	{
	    return(new String[]{"sansserif","serif","monospace"});
	}
	public static AudioClip getAudioClip(URL url)
	{	
		InputStream s;
		try {
			s = url.openStream();
			if(s!=null) { return(new AudioClip(url.toExternalForm(),s)); }
		} catch (IOException e) {
			G.print("Missing AudioClip "+e);
		}
		return(null);

	}
	public static int getIdentity()
	{
		String id = getHostUID();
		return(G.hashChecksum(id,id.length())); 
	}
    /** get the current local offset from GMT in minutes */
    static public int getLocalTimeOffset()
    {	TimeZone tz = TimeZone.getDefault();  
		java.util.Date now = new java.util.Date(System.currentTimeMillis());
		GregorianCalendar cal = new GregorianCalendar();
		cal.setTime(now);
		int off = tz.getOffset(1,cal.get(Calendar.YEAR),
								cal.get(Calendar.MONTH),cal.get(Calendar.DATE),cal.get(Calendar.DAY_OF_WEEK),
								cal.get(Calendar.MILLISECOND));
		return(-off/(1000*60));
    }
    
	public static String getHostUID()
	{	Preferences prefs = Preferences.userRoot();
		String uid = prefs.get("globaluserid",null);
		if(uid!=null)
		{
			long time = Long.parseLong(uid);
			if(time%104535636!=132) { uid = null; }	// invalid!
		}
		if(uid==null) 
		{	long time = System.currentTimeMillis();
			time = time-time%104535636+132;	// tiny fig leaf of authentication
			uid = ""+time;
			prefs.put("globaluserid",uid);
		}
		return(uid+"|"+getPlatformName());
	}
/*
	public static int Fact(int n) { return((n==0) ? 1 : n*Fact(n-1)); } 
	public static int ackerman(int m,int n) 
	{ 	if(m==0) { return(n+1); }
		else if(n==0) { return(ackerman(m-1,1)); }
		else { return(ackerman(m-1,ackerman(m,n-1)));  }
	}
*/
	public static void setGlobalDefaultFont(Font f)
	{	defaultFont = f;
	}
	public static void setGlobalDefaultFont()
	{
		setGlobalDefaultFont(getGlobalDefaultFont());
	}
	public static int getAbsoluteX(Component c) { return(c.getAbsoluteX()); }
	public static int getAbsoluteY(Component c) { return(c.getAbsoluteY()); }
	public static boolean equals(Rectangle r,Object obj)
	{
		if (obj instanceof Rectangle) {
			Rectangle o = (Rectangle)obj;
			return ((r.getX() == o.getX()) &&
					(r.getY() == o.getY()) &&
					(r.getWidth() == o.getWidth()) &&
					(r.getHeight() == o.getHeight()));
		}
		return r.equals(obj);
	}
	public static void setRotation(Graphics g,double r,int cx,int cy)
	{
		if(g!=null) { g.setRotation(r,cx,cy); }
	}
    public static void resetAffine(Graphics g)
    {	
    	if(g!=null) { g.resetAffine(); }
    }
    
    @SuppressWarnings("unchecked")
	public static NativeInterface MakeNative(Class<?>n)
    {	
    	return(NativeLookup.create((Class<NativeInterface>)n));
    }
	public static void writeTextToClipboard(String s) {
		//System.out.println("S '"+s+"'");
		Display.getInstance().copyToClipboard(s);
	}
	public static String readTextFromClipboard() {
		Object ob = Display.getInstance().getPasteDataFromClipboard();
		//System.out.println("G '"+ob+"'");
		if(ob instanceof String) { return((String)ob); }
		return(null);
	}
	public static String substring(StringBuilder str,int from,int to) 
	{ 	int len = to-from;
		char seq[] = new char[len];
		for(int i=0;i<len;i++) { seq[i] = str.charAt(from++); }
		return(new String(seq));
	}

	public static String replaceAll(String from,String find,String replacement)
	{	int prevIndex = 0;
		int index = from.indexOf(find);
		if(index>=0)
		{	StringBuilder str = new StringBuilder();
			int len = find.length();
			while(index>=0) 
				{ String segment = from.substring(prevIndex,index);
				  str.append(segment);
				  str.append(replacement);
				  prevIndex = index+len;
				  index = from.indexOf(find,prevIndex);
				}
			str.append(from.substring(prevIndex));
			return(str.toString());
		}
		else { return(from); }
	}
	 /**
	  * 
	  * @param g
	  * @param left
	  * @param top
	  * @param w
	  * @param h
	  */
	 static public void fillRect(Graphics g, int left, int top, int w,  int h)
	     {	if(g!=null)
	     	{
	    	 int off = G.isAndroid() ? 1 : 0;
	         g.fillRect(left, top, w-off, h-off);
	     	}
	     }
		public static Rectangle getStringBounds(FontMetrics fm, String line, int i, int line0, Graphics g) {
			Rectangle2D d = fm.getStringBounds(line,i,line0,g);
			return(new Rectangle((int)d.getX(),(int)d.getY(),(int)d.getWidth(),(int)d.getHeight()));
		}
		public static Rectangle getStringBounds(FontMetrics fm, String line, Graphics g) {
			Rectangle2D d = fm.getStringBounds(line, g);
			return(new Rectangle((int)d.getX(),(int)d.getY(),(int)d.getWidth(),(int)d.getHeight()));
		}
		

		private static long basetime = System.currentTimeMillis();
		protected static SystemTime time = null;
		static boolean nanotimeSupported = false;
		static boolean asknanotime = true;
		public static long nanoTime()
		{	
			if(nanotimeSupported)
			{
				return(time.currentNanoTime());
			}
			else if(asknanotime)
			{	asknanotime = false;
				time = NativeLookup.create(SystemTime.class);
				nanotimeSupported = time.isSupported(); 
				return(nanoTime());
			}
			else {
			long tim = System.currentTimeMillis();
			return((tim-basetime)*1000000);
			}
		}
	    public static double adjustWindowFontSize(int w,int h)
	    {	// on IOS platforms, everything starts scaled to full screen
	    	return(1.0);
	    }
	
	    @SuppressWarnings("unused")
		public static void markFrame(com.codename1.ui.Graphics g,com.codename1.ui.Component c)
		   {
			  if(false && G.debug()) 
			  {
				  com.codename1.ui.Component t = c;  
				  g.setColor(0xff0000);
			   g.drawLine(0,0,t.getWidth(),t.getHeight());
			   g.setColor(000);
			   int y = 100;
			   while(t!=null)
			   {
			   g.setColor(0x0);
			   g.fillRect(10, y, 2500, 50);
			   g.setColor(0xffffff);
			   com.codename1.ui.Container parent  = t.getParent();
			   g.drawString("t "+t.isOpaque()+" "+((parent==null)?"":parent.getComponentCount())+" "+t,20,y);
			   y+=100;
			   t = parent;
			  }
			   g.setColor(0x00ff);
			   g.fillRect(50, y, 50,c.getHeight());
			  }
		   }
	    
	    // cribbed from standard java String
	    public static final Comparator<String> CASE_INSENSITIVE_ORDER
        	= new CaseInsensitiveComparator();
	    
	private static class CaseInsensitiveComparator implements Comparator<String>
	{
	
	public int compare(String s1, String s2) {
		int n1 = s1.length();
		int n2 = s2.length();
		int min = Math.min(n1, n2);
		for (int i = 0; i < min; i++) {
		char c1 = s1.charAt(i);
		char c2 = s2.charAt(i);
		if (c1 != c2) {
		c1 = Character.toUpperCase(c1);
		c2 = Character.toUpperCase(c2);
		if (c1 != c2) {
		c1 = Character.toLowerCase(c1);
		c2 = Character.toLowerCase(c2);
		if (c1 != c2) {
		// No overflow because of numeric promotion
		return c1 - c2;
		}
		}
		}
	}
	return n1 - n2;
	}
}
// this is a factory for chat windows which conceals that we
// removed the source code for the old style "window based" interface on codename1 
public static ChatInterface CreateChat(boolean useChat,LFrameProtocol myFrame,ExtendedHashtable sharedInfo,boolean framed)
{
    if(useChat)
    {	return new ChatWidget(myFrame,sharedInfo,!framed);
    
    }
    throw G.Error("Old style chat not supported");// commonChatApplet(myFrame,sharedInfo,false);
}
}
