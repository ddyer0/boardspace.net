package octiles;

import online.common.G;
import java.awt.Graphics;
import java.awt.Image;
import java.util.Random;

import online.common.exCanvas;
import online.game.chip;
/*
 * generic "playing piece class, provides canonical playing pieces, 
 * image artwork, scales, and digests.  For our purposes, the squares
 * on the board are pieces too, so there are four of them.
 * 
 */
public class OctilesChip extends chip
{	static final int RUNNER_INDEX = 100;
	private int tileIndex;
	public boolean isTile = false;
	public boolean isRunner = false; 
	public String name = "";
	private int lines[]=null;		// definition of the lines for this chip
		
	private static final int tileMap[][] =
	{		// index is the side clockwise starting at West, value is the connection side
			// each entry should be a permutation of 0-8
			{4,5,6,7,0,1,2,3},	// tile 1, 4 straight connections
			{4,5,7,6,0,1,3,2},	// tile 2, 2 straights and 2 60 degree swishes
			{5,4,7,6,1,0,3,2},	// tile 3, 4 60 degree swishes
			{5,3,6,1,7,0,2,4},	// tile 4, 1 straight, 2 60, 1 90
			{4,3,6,1,0,7,2,5},	// tile 5, 2 straights at 90 degre angles, 2 90 degree
			{3,6,4,0,2,7,1,5},	// tile 6, 2 60's and 2 90's 
			{1,0,5,6,7,2,3,4},	// tile 7, 1 30 and 3 60's
			{1,0,6,7,5,4,2,3},	// tile 8, 2 30s and 2 straights
			{1,0,6,5,7,3,2,4},	// tile 9, 30 60 90 straight
			{7,4,6,5,1,3,2,0},	// tile 10, mirror of tile 9
			{6,3,4,1,2,7,0,5},	// tile 11, 4 90s
			{1,0,7,5,6,3,4,2},	// tile 12, 30 60 2 90s
			{1,0,4,6,2,7,4,5},	// tile 13 30 90 90 60
			{1,0,7,6,5,4,3,2},	// tile 14 2 30s 2 60s
			{4,2,1,5,0,3,7,6},	// tile 15 straight 2 30s 1 90
			{1,0,5,4,3,2,7,6},	// tile 16 3 30s 1 60
			{1,0,4,5,2,3,7,6},	// tile 17 2 60s 2 90s
			{1,0,3,2,5,4,7,6}	// tile 18 4 30s
			
	};	// 18 tiles
	public static final int NTILES = tileMap.length;
	public static final int NRUNNERS = 4;
	
	public int chipNumber() { return(tileIndex); }

   static final int FIRST_TILE_INDEX = 0;

	private OctilesChip(String na,int pla,Image im,int rv,double scl[],int[]ll)
	{	name = na;
		tileIndex=pla;
		isTile = (pla>=FIRST_TILE_INDEX) && (pla<(FIRST_TILE_INDEX+NTILES));
		isRunner = (pla>=RUNNER_INDEX)&&(pla<(RUNNER_INDEX+NRUNNERS));
		image = im;
		randomv = rv;
		scale = scl;
		lines = ll;
	}
	public String toString()
	{	return("<"+ name+">");
	}
	
	public int Digest()
	{	return(randomv);
	}
		
	// note, do not make these private, as some optimization failure
	// tries to access them from outside.
    static private OctilesChip CANONICAL_PIECE[] = null;	// created by preload_images
    static private OctilesChip CANONICAL_RUNNER[] = null;	// preloading images of the runners
    static Image[] line30 = null;
    static Image[] line90 = null;
    static Image[] line120 = null;
    static Image[] line180 = null;

    static private double SCALES[][] =
    {	{0.52,0.5,1.66},		// light square
    	{0.516,0.616,1.0},		// blue runner
    	{0.541,0.608,1.0},		// red runner
    	{0.508,0.641,1.0},		// yellow runner
    	{0.508,0.608,1.0}		// green runner
    };
     
    public static OctilesChip getRunner(int i) { return(CANONICAL_RUNNER[i]); }
	public static OctilesChip getTile(int color)
	{	return(CANONICAL_PIECE[FIRST_TILE_INDEX+color]);
	}
	
	public static OctilesChip getChip(int i)
	{	if(i>=RUNNER_INDEX) { return(getRunner(i-RUNNER_INDEX)); }
		return(getTile(i));
	}
	public void drawChip(Graphics gc,exCanvas canvas,int SQUARESIZE,int cx,int cy,String label)
	{	drawChip(gc,canvas,SQUARESIZE,cx,cy,label,0);
	}

	public void drawChip(Graphics gc,exCanvas canvas,int SQUARESIZE,int cx,int cy,String label,int rotation)
	{	
		super.drawChip(gc,canvas,SQUARESIZE,cx,cy,label);
		if(lines!=null && (gc!=null))
		{
		int mask = 0;
		for(int idx= 0; idx<lines.length;idx++)
		{	
			int exit = lines[idx];
			int entry = idx;
			int mod = 8;
			Image row[] = null;
			int newmask = (1<<entry) | (1<<exit);
			if((mask&newmask)==0)
			{
			mask |= newmask;
			switch(Math.abs(idx-exit))
			{
			default: G.Error("Unexpected line length");
			case 7: entry = exit; 
					// fall through
			case 1:	row = line30; break;
			case 6: entry = exit;
					// fall through
			case 2: row = line90; break;
					// fall through
			case 5: entry = exit;
					// fall through
			case 3: row = line120; break;
			case 4: case 0: row = line180; entry = idx; mod=4; break;
			}
			canvas.drawImage(gc, row[(entry+rotation+800)%mod], scale,cx, cy, SQUARESIZE, 1.0,0.0,null,true);
			if(mask==0xff) { break;}
			}
			
		}
		if(mask!=0xff) { G.Error("missing lines"); }
		}
	}
   static final String[] ImageNames = 
       { "chip",
	     "blue-runner",
	     "red-runner",
	     "yellow-runner",
	     "green-runner"};
 
   static final String[] line30names = 
   	{ "line-30-0","line-30-1","line-30-2","line-30-3","line-30-4",
	   "line-30-5","line-30-6","line-30-7"};
   static final String[] line90names = 
  	{ "line-90-0","line-90-1","line-90-2","line-90-3","line-90-4",
	   "line-90-5","line-90-6","line-90-7"};   
   static final String[] line120names = 
 	{ "line-120-0","line-120-1","line-120-2","line-120-3","line-120-4",
	   "line-120-5","line-120-6","line-120-7"};   
  
   static final String[] line180names = 
	   	{ "line-180-0","line-180-1","line-180-2","line-180-3"
		   }; 
   
// these were used in the "just lines" version of the connections.  The
// current version uses line pairs with the spaces between the lines filled
// so the resulting drawing looks like a solid overpass
//static final String[] lineTop = { "chip-dark" };
//
//   static final Image[]preloadGroup(String ImageDir,exCanvas forcan,Image top,String masks[])
//   {
//	   Image lines[] = forcan.load_images(ImageDir,masks);
//	   Image res[] = new Image[lines.length];
//	   for(int i=0;i<lines.length;i++)
//		  { res[i] = G.Composite(forcan, top, lines[i]);
//		  }   
//	   return(res);
//  }
//    
	// call from the viewer's preloadImages
	public static void preloadImages(exCanvas forcan,String ImageDir)
	{	if(CANONICAL_PIECE==null)
		{
        Image IM[]=forcan.load_masked_images(ImageDir,ImageNames);
        OctilesChip CC[] = new OctilesChip[NTILES];
        Random rv = new Random(340644);		// an arbitrary number, just change it
        for(int i=0;i<NTILES;i++) 
        	{
        	CC[i]=new OctilesChip("Tile "+(i+1),i,IM[0],rv.nextInt(),SCALES[0],tileMap[i]);
        	}
        CANONICAL_PIECE = CC;
        CANONICAL_RUNNER = new OctilesChip[NRUNNERS];
        for(int i=0;i<NRUNNERS;i++)
        {	CANONICAL_RUNNER[i] = new OctilesChip(ImageNames[i+1],RUNNER_INDEX+i,IM[i+1],rv.nextInt(),SCALES[i+1],null); 
        }
        check_digests(CC);
		}
//		Image top[] = forcan.load_images(ImageDir,lineTop);
	

		line30 = forcan.load_masked_images(ImageDir,line30names);
		line90 = forcan.load_masked_images(ImageDir,line90names);
		line120 = forcan.load_masked_images(ImageDir,line120names);
		line180 = forcan.load_masked_images(ImageDir,line180names);

	}

}
