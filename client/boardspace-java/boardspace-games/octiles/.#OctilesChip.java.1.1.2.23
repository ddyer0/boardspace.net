package octiles;


import java.awt.Graphics;
import java.awt.Image;
import lib.Random;

import lib.G;

import online.common.exCanvas;
import online.game.chip;
/*
 * generic "playing piece" class, provides the background octagon chip, runners,
 * and lines as overlays to the octagon.
 */
public class OctilesChip extends chip
{	static final int RUNNER_INDEX = 100;
	static final int BLUE_RUNNER = 100;
	static final int RED_RUNNER = 101;
	static final int YELLOW_RUNNER = 102;
	static final int GREEN_RUNNER = 103;
	static final int BLUE_RUNNER_INDEX = 0;
	static final int RED_RUNNER_INDEX = 1;
	static final int YELLOW_RUNNER_INDEX = 2;
	static final int GREEN_RUNNER_INDEX = 3;
	
	private int tileIndex;
	public int owner = -1;
	public boolean isTile = false;
	public boolean isRunner = false; 
	public String contentsString() { return(" "+file); }
	private int lines[]=null;		// definition of the lines for this chip
	private int drawOrder[]=null;
	
	private static final int tileMap[][] =
	{		// index is the side clockwise starting at West, value is the connection side
			// each entry should be a permutation of 0-8
			{4,5,6,7,0,1,2,3},	// tile 1, 4 straight connections
			{4,5,7,6,0,1,3,2},	// tile 2, 2 straights and 2 60 degree swishes
			{5,4,7,6,1,0,3,2},	// tile 3, 4 60 degree swishes
			{5,3,6,1,7,0,2,4},	// tile 4, 1 straight, 2 60, 1 90
			{4,3,6,1,0,7,2,5},	// tile 5, 2 straights at 90 degre angles, 2 90 degree
			{3,6,4,0,2,7,1,5},	// tile 6, 2 60's and 2 90's 
			{1,0,5,6,7,2,3,4},	// tile 7, 1 30 and 3 60's
			{1,0,6,7,5,4,2,3},	// tile 8, 2 30s and 2 straights
			{1,0,6,5,7,3,2,4},	// tile 9, 30 60 90 straight
			{7,4,6,5,1,3,2,0},	// tile 10, mirror of tile 9
			{6,3,4,1,2,7,0,5},	// tile 11, 4 90s
			{1,0,7,5,6,3,4,2},	// tile 12, 30 60 2 90s
			{1,0,4,6,2,7,3,5},	// tile 13 30 90 90 60
			{1,0,7,6,5,4,3,2},	// tile 14 2 30s 2 60s
			{4,2,1,5,0,3,7,6},	// tile 15 straight 2 30s 1 90
			{1,0,5,4,3,2,7,6},	// tile 16 3 30s 1 60
			{1,0,4,5,2,3,7,6},	// tile 17 2 60s 2 90s
			{1,0,3,2,5,4,7,6}	// tile 18 4 30s
			
	};	// 18 tiles
	
	private static final int drawMap[][] =
	{		// the values are the draw order for strokes.  0 first.  Drawing
			// in this order makes the pattern of overpass/underpass for tiles
			// almost completely agree with the real tiles.
			{0,3,2,1,4,5,6,7},	// tile 1, 4 straight connections
			{2,3,0,1,4,5,6,7},	// tile 2, 2 straights and 2 60 degree swishes
			{0,2,1,3,4,5,6,7},	// tile 3, 4 60 degree swishes
			{0,4,2,1,3,5,6,7},	// tile 4, 1 straight, 2 60, 1 90
			{0,2,1,3,4,5,6,7},	// tile 5, 2 straights at 90 degre angles, 2 90 degree
			{0,1,2,3,4,5,6,7},	// tile 6, 2 60's and 2 90's 
			{0,1,4,2,3,5,6,7},	// tile 7, 1 30 and 3 60's
			{0,1,2,3,4,5,6,7},	// tile 8, 2 30s and 2 straights
			{0,1,2,4,3,5,6,7},	// tile 9, 30 60 90 straight
			{0,2,1,3,4,5,6,7},	// tile 10, mirror of tile 9
			{5,1,2,3,4,0,6,7},	// tile 11, 4 90s
			{0,1,2,4,3,5,6,7},	// tile 12, 30 60 2 90s
			{0,1,3,2,4,5,6,7},	// tile 13 30 90 90 60
			{0,1,2,3,4,5,6,7},	// tile 14 2 30s 2 60s
			{0,1,2,3,4,5,6,7},	// tile 15 straight 2 30s 1 90
			{0,1,2,3,4,5,6,7},	// tile 16 3 30s 1 60
			{0,1,3,2,4,5,6,7},	// tile 17 2 60s 2 90s
			{0,1,2,3,4,5,6,7}	// tile 18 4 30s
			
	};	// 18 tiles
	
	public static final int NTILES = tileMap.length;
	public static final int NRUNNERS = 4;
	
	public int chipNumber() { return((tileIndex<RUNNER_INDEX)?tileIndex+1:tileIndex); }

   static final int FIRST_TILE_INDEX = 0;

	private OctilesChip(String na,int pla,Image im,long rv,double scl[],int[]ll,int[]dd)
	{	
		file = na;
		tileIndex=pla;
		owner = pla-RUNNER_INDEX;
		isTile = (pla>=FIRST_TILE_INDEX) && (pla<(FIRST_TILE_INDEX+NTILES));
		isRunner = (pla>=RUNNER_INDEX)&&(pla<(RUNNER_INDEX+NRUNNERS));
		image = im;
		randomv = rv;
		scale = scl;
		lines = ll;
		drawOrder = dd;
	}
	
		
	// note, do not make these private, as some optimization failure
	// tries to access them from outside.
    static OctilesChip CANONICAL_PIECE[] = null;	// created by preload_images
    static OctilesChip CANONICAL_RUNNER[] = null;	// preloading images of the runners
    static Image[] line30 = null;
    static Image[] line90 = null;
    static Image[] line120 = null;
    static Image[] line180 = null;

    // these are the "highlight" versions of the lines, currently red insets
    // between the black line pairs.
    static Image[] line30_h = null;
    static Image[] line90_h = null;
    static Image[] line120_h = null;
    static Image[] line180_h = null;

    static private double SCALES[][] =
    {	{0.541,0.55,1.95},		// light square
    	{0.516,0.616,1.0},		// blue runner
    	{0.541,0.608,1.0},		// red runner
    	{0.473,0.641,1.0},		// yellow runner
    	{0.508,0.608,1.0}		// green runner
    };
     
    public static OctilesChip getRunner(int i) { return(CANONICAL_RUNNER[i]); }
	public static OctilesChip getTile(int color)
	{	return(CANONICAL_PIECE[FIRST_TILE_INDEX+color]);
	}
	
	public static OctilesChip getChip(int i)
	{	if(i>=RUNNER_INDEX) { return(getRunner(i-RUNNER_INDEX)); }
		return(getTile(i-1));
	}
	public void drawChip(Graphics gc,exCanvas canvas,int SQUARESIZE,int cx,int cy,String label)
	{	drawChip(gc,canvas,SQUARESIZE,cx,cy,label,0,0);
	}
	/**
	 *  determine the exit edge when placed with rotation and entering from some direction
	 *  the +1 is because the table assumes direction 0 is west, when actually it is southwest
	 * @param rotation
	 * @param enter
	 * @return direction of exit
	 */
	public int exitDirection(int rotation,int enter)
	{	G.Assert(lines!=null,"has lines");
		return((lines[(enter-rotation+8-1)%8]+8+rotation+1)%8);
	}
	/**
	 * draw the background chip using the inherited drawChip, then draw
	 * the lines as an overlay, considering the rotation and requests for
	 * highlighting
	 * @param gc
	 * @param canvas
	 * @param SQUARESIZE
	 * @param cx
	 * @param cy
	 * @param label
	 * @param rotation 0-7 steps rotation clockwise
	 * @param markedStrokes bitmask of 1<<stroke position to be highlighted
	 */
	public void drawChip(Graphics gc,exCanvas canvas,int SQUARESIZE,int cx,int cy,String label,int rotation,int markedStrokes)
	{	drawChip(gc,canvas,SQUARESIZE,1.0,cx,cy,label,rotation,markedStrokes);
	}
	/**
	 * draw the background chip using the inherited drawChip, then draw
	 * the lines as an overlay, considering the rotation and requests for
	 * highlighting
	 * @param gc
	 * @param canvas
	 * @param SQUARESIZE
	 * @param xscale
	 * @param cx
	 * @param cy
	 * @param label
	 * @param rotation 0-7 steps rotation clockwise
	 * @param markedStrokes bitmask of 1<<stroke position to be highlighted
	 */
	public void drawChip(Graphics gc,exCanvas canvas,int SQUARESIZE,double xscale,int cx,int cy,String label,int rotation,int markedStrokes)
	{	
		super.drawChip(gc,canvas,SQUARESIZE,xscale,cx,cy,label);
		if(lines!=null && (gc!=null))
		{
		int mask = 0;
		for(int ind= 0; ind<lines.length;ind++)
		{	int idx = drawOrder[ind];
			int exit = lines[idx];
			int entry = idx;
			int mod = 8;
			Image row[] = null;
			Image row_h[] = null;
			int newmask = (1<<entry) | (1<<exit);
			boolean marked = ( (1<<idx) & markedStrokes)!=0;
			if((mask&newmask)==0)
			{
			mask |= newmask;
			switch(Math.abs(idx-exit))
			{
			default: throw G.Error("Unexpected line length");
			case 7: entry = exit; 
				//$FALL-THROUGH$
			case 1:	row = line30; 
					row_h = line30_h;
					break;
			case 6: entry = exit;
				//$FALL-THROUGH$
			case 2: row = line90; 
					row_h = line90_h;
					break;
			case 5: entry = exit;
					//$FALL-THROUGH$
			case 3: row = line120; 
					row_h = line120_h;
					break;
			case 4: case 0: 
					row = line180;
					row_h = line180_h;
					entry = idx;
					mod=4; break;
			}
			canvas.drawImage(gc, row[(entry+rotation+800)%mod], scale,cx, cy, SQUARESIZE, 1.0,0.0,null,true);
			if(marked)
				{
				// draw the highlight line
				canvas.drawImage(gc, row_h[(entry+rotation+800)%mod], scale,cx, cy, SQUARESIZE, 1.0,0.0,null,true);
				}

			if(mask==0xff) { break;}
			}
			
		}
		if(mask!=0xff) { throw G.Error("missing lines"); }
		}
	}
   static final String[] ImageNames = 
       { "chip",
	     "blue-runner",
	     "red-runner",
	     "yellow-runner",
	     "green-runner"};
 
   static final String[] line30names = 
   	{ "line-30-0","line-30-1","line-30-2","line-30-3","line-30-4",
	   "line-30-5","line-30-6","line-30-7"};
   static final String[] line90names = 
  	{ "line-90-0","line-90-1","line-90-2","line-90-3","line-90-4",
	   "line-90-5","line-90-6","line-90-7"};   
   static final String[] line120names = 
 	{ "line-120-0","line-120-1","line-120-2","line-120-3","line-120-4",
	   "line-120-5","line-120-6","line-120-7"};   
  
   static final String[] line180names = 
	   	{ "line-180-0","line-180-1","line-180-2","line-180-3"
		   }; 
   

   
	// call from the viewer's preloadImages
	public static void preloadImages(exCanvas forcan,String ImageDir)
	{	if(CANONICAL_PIECE==null)
		{
        Image IM[]=forcan.load_masked_images(ImageDir,ImageNames);
        OctilesChip CC[] = new OctilesChip[NTILES];
        Random rv = new Random(340644);		// an arbitrary number, just change it
        for(int i=0;i<NTILES;i++) 
        	{
        	CC[i]=new OctilesChip("Tile "+(i+1),i,IM[0],rv.nextLong(),SCALES[0],tileMap[i],drawMap[i]);
        	}
        CANONICAL_PIECE = CC;
        CANONICAL_RUNNER = new OctilesChip[NRUNNERS];
        for(int i=0;i<NRUNNERS;i++)
        {	CANONICAL_RUNNER[i] = new OctilesChip(ImageNames[i+1],RUNNER_INDEX+i,IM[i+1],rv.nextLong(),SCALES[i+1],null,null); 
        }
        check_digests(CC);
		}
		// the mask images contain two related pictures, the one we normally want in the
		// low order 8 bits, and a related "highlight" mask in the middle 8 bits.
		{
		// load the mask images
		Image masks[] = forcan.load_images(ImageDir, line30names, "-mask");
		// create a red image using the middle 8 bits of the mask
		line30_h = forcan.CompositeMasks(masks,8,0xe00000);
		// create the regular image composite of the tile and the low order 8 bits
		line30 = forcan.load_images(ImageDir, line30names,masks);
		}
		// repeat for the rest of the line images...
		{
			Image masks[] = forcan.load_images(ImageDir, line90names, "-mask");
			line90_h = forcan.CompositeMasks(masks,8,0xe00000);
			line90 = forcan.load_images(ImageDir, line90names,masks);
		}
		{
			Image masks[] = forcan.load_images(ImageDir, line120names, "-mask");
			line120_h = forcan.CompositeMasks(masks,8,0xe00000);
			line120 = forcan.load_images(ImageDir, line120names,masks);
		}
		{
			Image masks[] = forcan.load_images(ImageDir, line180names, "-mask");
			line180_h = forcan.CompositeMasks(masks,8,0xe00000);
			line180 = forcan.load_images(ImageDir, line180names,masks);
		}

	}

}