package loa;

import online.common.CellId;
import online.common.HitPoint;
import online.common.exHashtable;
import online.game.*;
import online.game.sgf.sgf_game;
import online.game.sgf.sgf_names;
import online.game.sgf.sgf_node;
import online.game.sgf.sgf_property;

import java.awt.*;
import java.io.*;
import java.lang.Math;
import java.util.*;

import lib.*;

public class LoaViewer extends commonCanvas implements Observer, UIC,
    ViewerProtocol, Play2Constants, sgf_names
{
    static final Color HighlightColor = Color.green;
    static final int EmptyBoard = -1; // highlight points to empty board
    static final Color vcrButtonColor = new Color(0.7f, 0.7f, 0.75f);
    Loa_Board b = null;
    Point selectedStone = null; // selected point
    private int CELLSIZE = 0;
    //private Rectangle fullRect = addRect("fullRect");
    //private Rectangle boardRect = addRect("boardRect");
    private Rectangle logRect = addRect("logRect"); // game log
    private Rectangle progressRect = addRect("progressRect");

    private Rectangle countP1Rect = addRect("player1Count");
    private Rectangle countP2Rect = addRect("player2Count");
    private Rectangle pointP1Rect = addRect("player1Points");
    private Rectangle pointP2Rect = addRect("player2Points");
    
    private CellId movingObject = DefaultId.HitNoWhere; // >=0 iff a ball is moving

    /* end of viewer protocol methods */
    public boolean invalid = true;
    private Rectangle[][] r; // where the squares are
    private int rsize = 0;
    private boolean last_use_grid = true;
    boolean invert_y = true;
    private boolean last_invert_y = true;
    int last_board_size = 0;

   
   private int paintedSize = 0;
   public boolean repositionBoxes()
   {	if(paintedSize!=b.size)
   		{ resetBounds();
   		  return(true);
   		}
     return(false);
   }
   private void createPlayerGroup(commonPlayer pl0,Rectangle count,Rectangle point,int playerx,int playery)
   {
       Rectangle p0time = pl0.timeRect;
       Rectangle p0xtime = pl0.extraTimeRect;
       Rectangle p0anim = pl0.animRect;
       Rectangle nameRect = pl0.nameRect;
       Rectangle picRect = pl0.picRect;
 
       //player1 balls
       nameRect.x = playerx;
       nameRect.y = playery;
       nameRect.width = CELLSIZE * 3;
       nameRect.height = (CELLSIZE*2/3);

       
       // player portrait
       picRect.x = nameRect.x;
       picRect.y = nameRect.y + nameRect.height;
       picRect.width = CELLSIZE * 5/2;
       picRect.height = CELLSIZE * 5/2;
        
        
       // time dispay for player1
       p0time.x = G.Right(nameRect);
       p0time.y = nameRect.y;
       p0time.width = 3*CELLSIZE/2;
       p0time.height = nameRect.height;
       
       p0xtime.x = p0time.x;
       p0xtime.y = G.Bottom(p0time);
       p0xtime.height = p0time.height;
       p0xtime.width = p0time.width;
       
       // player1 piece count
       count.x = picRect.x+picRect.width;
       count.y =G.Bottom(p0xtime);
       count.width=CELLSIZE;
       count.height=CELLSIZE;
       
       point.x = count.x;
       point.y = count.y+count.height;
       point.height=count.height;
       point.width=point.height;

       p0anim.x = G.Right(picRect);
       p0anim.y = picRect.y;
       p0anim.width = p0time.height;
       p0anim.height = p0anim.width;

   }
   
   public void setLocalBounds(int x, int y, int width, int height)
    { // do layout etc.
	   	boolean wideMode = width>(height*1.6);
        fullRect.x = 0;
        fullRect.y = 0;
        fullRect.width = width;
        fullRect.height = height;
        paintedSize = b.size;
        int chatHeight = selectChatHeight(height);
         
        int bs = b.boardSize() + 1; // 1 for the grid
        int nx = bs + (wideMode ? 12 : 6);
        int ny = bs+1;
        int cellh = wideMode ? height/ny : (height-chatHeight) / ny;
        int cellw = width / nx;
        int auxx =  G.Right(boardRect)+CELLSIZE*5 ;
        
        CELLSIZE = Math.min(cellw, cellh);

        boardRect.x = CELLSIZE/2;
        boardRect.y = (wideMode ? 0 : chatHeight)+CELLSIZE/2;
        boardRect.width = bs * CELLSIZE;
        boardRect.height = bs * CELLSIZE;

        logRect.width = CELLSIZE * 4;
        chatRect.x = wideMode ? auxx : 0;
        chatRect.width = wideMode ? fullRect.width-chatRect.x-CELLSIZE/4 : boardRect.width;
        chatRect.height = chatHeight;
        logRect.x = wideMode ? auxx : chatRect.x+chatRect.width+CELLSIZE/4;
        logRect.y = 0;
        logRect.height = wideMode ? CELLSIZE*4 : chatHeight;
        chatRect.y = wideMode ? G.Bottom(logRect) : fullRect.y;
      
        int vy = G.Bottom(boardRect)-3*CELLSIZE/2;
        SetupVcrRects(G.Right(boardRect)+CELLSIZE/2, vy, CELLSIZE * 3, (6 * CELLSIZE) / 4);

        progressRect.x = CELLSIZE * 4;
        progressRect.width = 3 * CELLSIZE;
        progressRect.y = G.Bottom(boardRect);
        progressRect.height = CELLSIZE / 4;

        {	int playerx = G.Right(boardRect);
        	createPlayerGroup(getPlayerOrTemp(0),countP1Rect,pointP1Rect,playerx,boardRect.y);
        	createPlayerGroup(getPlayerOrTemp(1),countP2Rect,pointP2Rect,playerx,boardRect.y+CELLSIZE*4);	
        }

        theChat.setBounds(chatRect.x+x,chatRect.y+y,chatRect.width,chatRect.height);
        theChat.setVisible(true);

        generalRefresh();
    }

    public commonMove ParseNewMove(String st)
    {
        return (new Move_Spec(st, b.whoseTurnStone()));
    }

    public Move_Spec currentMove()
    {
        int v = (viewStep >= 0) ? (viewStep - 1) : (History.size() - 1);

        if (v >= 0)
        {
            return ((Move_Spec) History.elementAt(v));
        }

        return (null);
    }

    public boolean Execute(commonMove mm,replayMode replay)
    {	boolean review = reviewMode();
        Move_Spec m = (Move_Spec) mm;
        int step = (b.moveNumber());
        if(!review) { viewMove = Math.max(step, viewMove);} // maintain the max move for the parents
        mm.setSliderNumString("" + step);

        b.Test_Move(m); //side effect of blessing and setting capture flag

        //System.out.println("Execute "+m);
        if (m.N() == M_Select)
        { // just select a point

            int fx = m.fromX();
            int fy = m.fromY();
            selectedStone = ((fx >= 0) && (fy >= 0)) ? new Point(fx, fy) : null;
        }
        else
        {	mm.player = b.whoseTurn;
            b.Execute(mm);
        }
        if(!review) { setDoneState(false); }
        generalRefresh();
        GameOverNow();		// side effect of noticing the game is over
        return (true);
    }

    public commonMove EditHistory(commonMove m)
    { // add to history, but also edit history so redundant moves are eliminated

        Move_Spec newmove = (Move_Spec) m;

        if (newmove.N() == M_Select)
        {
            return (null);
        }

        return (newmove);
    }
    public void performHistoryInitialization(StringTokenizer his)
    {   //the initialization sequence
    	String token = his.nextToken();
        b.doInit(token);
    }

    public synchronized void ReplayGame(sgf_game ga)
    {	// we need to make sure the state is "standard" so lax sgf files can assume that
    	// as a default.
    	b.setCurrentSetup("standard");	// make sure we start as a standard setup
    	super.ReplayGame(ga);
    }
    
    public String gameType() { return(b.gametype); }
    public String sgfGameType() { return(LOA_SGF); }
    
    // loa has its own version of printGameRecord to maintain some historical
    // ideosyncrancies of format.
    public void printGameRecord(PrintWriter pw, String startingTime)
    {
        String nameString = "";

        for (commonPlayer p = commonPlayer.firstPlayer(players); p != null;
                p = commonPlayer.nextPlayer(players, p))
        {
            if (!nameString.equals(""))
            {
                nameString += "-";
            }

            nameString += p.trueName;
        }

        pw.println("(;");
        pw.println("GM[" + LOA_SGF + "] VV[1]");
        pw.println("DT[" + startingTime + "]");
        pw.println("GN[" + nameString + "]");
        pw.println("SU[" + b.gametype + "]");

        for (commonPlayer p = commonPlayer.firstPlayer(players); p != null;
                p = commonPlayer.nextPlayer(players, p))
        { //don't translate color here
            pw.println("P" + PColors[p.boardIndex] + "[" + p.trueName + "]");

            {
                String rank = p.getPlayerInfo(exHashtable.RANKING);

                if ((rank != null) && !("".equals(rank)))
                {
                    pw.println(PColors[p.boardIndex] + "[ranking " + rank + "]");
                }
            }

            {
                String ct = p.getPlayerInfo(exHashtable.COUNTRY);

                if ((ct != null) && !("".equals(ct)))
                {
                    pw.println(PColors[p.boardIndex] + "[country " + ct + "]");
                }
            }
        }

        //start with 1 to skip the anchor element
        for (int i = 1; i < History.size(); i++)
        {
            Move_Spec m = (Move_Spec) History.elementAt(i);
            pw.println("; " + m.color.Name_as_Char() + "[" + m.moveString() +
                "]");
        }

        pw.println(";");

        for (commonPlayer p = commonPlayer.firstPlayer(players); p != null;
                p = commonPlayer.nextPlayer(players, p))
        {
            int col = p.colourIndex() % 4;

            if ((col >= 0))
            {
                pw.println("P" + PColors[p.boardIndex] + "[time " +
                    G.timeString(p.elapsedTime) + "]");
            }
        }

        pw.println(")");
    }
    


    public void StartDragging(HitPoint hp)
    {	if (getMovingObject() >= 0)
    	{	// if we got something started, inform the mouse handler
        hp.dragging = true;
    	}
    	repaint(20);
    }

    public void StopDragging(HitPoint hp)
    {
        performStandardActions(hp,false);
        movingObject = DefaultId.HitNoWhere;
        generalRefresh();
    }

    // board things that you can only do when it's your turn
    public HitPoint MouseMotion(int eventX, int eventY, mouseState upcode)
    {
        HitPoint pt = new HitPoint(eventX, eventY);
        HitPoint drag = dragPoint;
        pt.dragging = (drag!=null) && (upcode!=mouseState.LAST_IS_UP);
        pt.hitCode = DefaultId.HitNoWhere; 
        pt.down = (upcode==mouseState.LAST_IS_DOWN)||(upcode==mouseState.LAST_IS_DRAG);
        
       	if(adjustChatSize(pt))
		{
		if(upcode==mouseState.LAST_IS_DOWN)
			{ dragSizeAdj=0; 
			  dragPoint = pt;
			  pt.dragging=true; 
			}
		}
       	if(pt.dragging && (dragPoint.hitCode==DefaultId.HitChatButton))
		{
		int dist = pt.y-dragPoint.y;
    	if(dist!=dragSizeAdj)
    		{ chatSizeAdj += dist-dragSizeAdj;
    		  dragSizeAdj=dist;
     		  resetBounds(); 
    		}
		}
        if (fullRect.contains(eventX, eventY))
        {
            
            {
                commonPlayer pl = whoseTurn();
                Stone Black = b.blackStone();
                Stone White = b.whiteStone();
                Point selected = selectedStone;
                Point p = hitTest(eventX, eventY); // see if we hit a square

                if ((upcode== mouseState.LAST_IS_UP)
                		&& (allowed_to_edit || ((pl == my) && !reviewMode()))
                		&& (p != null)) // did the user click in a square?
                {
                    Stone contents = b.squareContents(p.x, p.y);

                    if (selected == null) // yes (he hit a square), no slected stone?
                    { // yes, (no selected stome);

                        if ((contents == Black) || (contents == White)) // is square occupied?
                        {
                            SelectStone(p); // yes, make this the selected stone
                        }
                    }
                    else if (GameOver() || (reviewMode() && !allowed_to_edit))
                    {
                        SelectStone(null);
                    }
                    else
                    { // we have a selected stone

                        LoaMove theMove = b.isLegalMove(selected.x, selected.y,
                                p.x, p.y);
                        SelectStone(null); // un-select the stone

                        if (theMove != null)
                        {
                            PerformAndTransmit(theMove.moveString());
                        }
                    }

                    invalidate();
                    repaint(20);
                }
            }

            // now look for things we can hit even when not our turn
         }
        drawVcrGroup(pt, null, null, null);
        return(SetHighlight(pt));
       
    }

    public BoardProtocol getBoard()   {    return (b);   }
    
    public commonPlayer whoseTurn()
    { // if(reviewMode())
      // { return(viewTurn);
      // }
      // else

        {
            Stone who = b.whoseTurnStone();
            int idx = (who == b.black.color) ? BLACK_INDEX : WHITE_INDEX;

            return (players[idx]);
        }
    }

    static Image textures[]=null;
    static Image images[]=null;
    public synchronized void preloadImages()
    {	
    	if (textures == null)
    	{ 	// note that for this to work correctly, the images and masks must be the same size.  
        	// Refer to http://www.andromeda.com/people/ddyer/java/imagedemo/transparent.html
    		
    		// images and textures are static variables, so they're shared by
    		// the entire class and only get loaded once.  Special synchronization
    		// tricks are used to make sure.
          images = load_images(ImageDir, ImageNames, 
        		  	load_images(ImageDir, ImageNames,"-mask")); // load the main images
          textures = load_images(ImageDir,TextureNames);
    	}
    }
    Color LoaMouseColors[] = { Color.black,Color.white};
    Color LoaMouseDotColors[] = { Color.white,Color.black};
    
    public void init(exHashtable stuff)
    {
        super.init(stuff);
        MouseDotColors = LoaMouseDotColors;
        MouseColors = LoaMouseColors;
        b = new Loa_Board(sharedInfo.getString(exHashtable.GAMETYPE,"LOA"));
        doInit(false);
   }

    public void doInit(boolean preserve_history)
    {
        super.doInit(preserve_history);
        b.doInit(b.gametype);
        if(!preserve_history)
    	{ PerformAndTransmit(reviewOnly?"Edit":"Start Black", false,replayMode.Live);
    	}
    }

    /* do things on the clock */
    public void ViewerRun()
    {
        super.ViewerRun();
    }


    public void make_invalid()
    {
        invalid = true;
    }

    public void make_valid()
    {
        if (invalid)
        {
            repaint(20);
        }
    }
    public void drawSprite(Graphics g,int idx,int xp, int yp)
    { //not used
    }


    Color table_color()
    {
        return (table_color);
    }

    private Stone selectedColor()
    {
        Point p = selectedStone;

        if (p != null)
        {
            return (b.squareContents(p.x, p.y));
        }

        return (null);
    }

    void drawMainMessage(Graphics g)
    {	String msg = "";
    	Color cc = Color.black;
        g.setFont(standardBoldFont);
        if(GameOver())
        {
        	msg = gameOverMessage();
        }
        else
        {
        commonPlayer p = whoseTurn();
        Stone col = b.whoseTurnStone();
        Stone contents = selectedColor();
        msg = ((contents == null) || (contents != col))
            ? s.get("Select the #1 piece to move", s.get(col.name))
            : s.get("Select the destination for the selected piece");

        if (p != null)
        {
            msg = p.userName + " : " + msg;
        }

        if (!reviewMode())
        {
            if (inLimbo)
            {
                msg = s.get(LimboMessage);
            }

        }}
        G.Text(g, false, boardRect.x-CELLSIZE/2,boardRect.y-CELLSIZE/2, boardRect.width,
            CELLSIZE / 2, cc, null, msg);
    }
    void drawStone(Graphics g,Rectangle rec,Color fg,Color bg,String msg,int idx)
    {	int cx = rec.width/2;
    	int cy = rec.height/2;
    	drawImage(g, images[idx], SCALES[idx],
        		rec.x+cx,rec.y+cy,rec.width, 1.0,0.0,msg,false);
        
    }
    public void redrawBoard(Graphics g,HitPoint p)
    {
        LoaMove cm = currentMove();
        Rectangle rb = boardRect;
        int n = b.boardSize();
        int height = rb.height;
        int width = rb.width;
        int squaresize = CELLSIZE;
        boolean isLOAP= (b.setup==Setup_Type.LOAP);
        
        G.tileImage(g,textures[BACKGROUND_TILE_INDEX], fullRect, this);   
        if(reviewMode())
        {	 
          G.tileImage(g,textures[BACKGROUND_REVIEW_TILE_INDEX],boardRect, this);   
        }
           
        
        int leftmargin = rb.x + ((width - (n * squaresize)) / 2);
        int topmargin = rb.y + ((height - (n * squaresize)) / 2);
        int rightmargin = leftmargin + (n * squaresize);
        int bottommargin = topmargin + (n * squaresize);

        r = null;
        rsize = n;


        if (use_grid)
        {
            for (int i = 0; i < n; i++)
            {
                String number = (new Integer(invert_y ? (n - i) : (i + 1))).toString();
                String letter = (new Character((char) ('A' + i))).toString();
                G.Text(g, true, leftmargin - (squaresize / 2),
                    topmargin + (i * squaresize), squaresize / 2, squaresize,
                    Color.black, null, number);
                G.Text(g, true, rightmargin, topmargin + (i * squaresize),
                    squaresize / 2, squaresize, Color.black, null, number);
                G.Text(g, true, leftmargin + (i * squaresize),
                    topmargin - (squaresize / 2), squaresize, squaresize / 2,
                    Color.black, null, letter);
                G.Text(g, true, leftmargin + (i * squaresize), bottommargin,
                    squaresize, squaresize / 2, Color.black, null, letter);
            }
        }

        int off = Math.max(1, (int) (squaresize * 0.05));
        int wff = off * 2;
        Stone Empty = b.emptyStone();
        Stone White = b.whiteStone();
        Stone Black = b.blackStone();
        Stone Blocked = b.blockedStone();
        Rectangle[][] rects = new Rectangle[n][n];
        int nwhite = 0;
        int nblack = 0;
        int center = n/2;
        int edge = n-2;
        for (int y = 0; y < n; y++)
            for (int x = 0; x < n; x++)
            {
                int xc = leftmargin + (squaresize * x);
                int yc = topmargin + (squaresize * y);
                int s2 = squaresize / 2;
                boolean light = (((x + y) & 1) == (isLOAP?1:0));
                int chipindex = light ? LIGHT_TILE_INDEX : DARK_TILE_INDEX;
                //Color squarecolor =  light ? white_square_color
                //                           : black_square_color;
                if(isLOAP)
                	{ if ((x==center)&&(y==center)) 
                		{ //squarecolor = loap_7_color;
                		  chipindex = GREEN_TILE_INDEX;
                		}
                	else if(((x==edge)&&((y==1)||(y==edge)))
                			|| ((x==1)&&((y==1)||(y==edge))))
                		{ //squarecolor=loap_3_color;	
                		  chipindex = YELLOW_TILE_INDEX;
                		}
                	}
                	
                rects[y][x] = new Rectangle(xc, yc, squaresize, squaresize);
              //  g.setColor(squarecolor);
              //  g.fillRect(xc, yc, squaresize, squaresize);
                
                drawImage(g, textures[chipindex], TSCALES[chipindex],
                		xc+s2,yc+s2,squaresize);
                
                {
                    Stone st = b.squareContents(x, invert_y ? (n - y - 1) : y);

                    if (st == Black)
                    {	nblack++;
                        //G.DrawAACircle(g, xc + s2, yc + s2, s2 - off - 2,
                        //    black_stone_color, squarecolor, true);
                        drawImage(g, images[LIGHT_TILE_INDEX], SCALES[LIGHT_TILE_INDEX],
                        		xc+s2,yc+s2,squaresize);

                    }
                    else if (st == White)
                    {	nwhite++;
                        //G.DrawAACircle(g, xc + s2, yc + s2, s2 - off - 2,
                        //    white_stone_color, squarecolor, true);
                        drawImage(g, images[DARK_TILE_INDEX], SCALES[DARK_TILE_INDEX],
                        		xc+s2,yc+s2,squaresize);
                   }
                    else if (st == Blocked)
                    {
                        g.setColor(blocked_square_color);
                        g.fillRect(xc + (off * 3), yc + (off * 3),
                            squaresize - (wff * 3), squaresize - (wff * 3));
                    }
                    else if (st == Empty)
                    {
                    }
                    else
                    {
                        throw new Error("Color " + st + " not handled");
                    }
                }
            }
        drawStone(g,countP1Rect,black_stone_color,table_color(),""+nblack,LIGHT_TILE_INDEX);
        drawStone(g,countP2Rect,white_stone_color,table_color(),""+nwhite,DARK_TILE_INDEX);

        if(isLOAP)
        { g.setFont(largeBoldFont);
          G.frameRect(g,Color.black,pointP1Rect);
          G.Text(g,true,pointP1Rect,Color.black,null,""+b.black.loaps_points);
          G.frameRect(g,Color.black,pointP2Rect);
          G.Text(g,true,pointP2Rect,Color.black,null,""+b.white.loaps_points);
        }
        Point selected = selectedStone;
        G.setFont(g,standardBoldFont);
        if (selected != null)
        {
            int x = selected.x;
            int y = invert_y ? (n - selected.y - 1) : selected.y;
            int ox = leftmargin + (squaresize * x) + (squaresize / 2);
            int oy = topmargin + (squaresize * y) + (squaresize / 2);
            g.setColor(selected_arrow_color);

            for (Enumeration<Move_Spec> moves = b.getLegalMoves(selected.x, selected.y);
                    moves.hasMoreElements();)
            {
                LoaMove m = moves.nextElement();
                x = m.toX();
                y = m.toY();

                if (invert_y)
                {
                    y = n - y - 1;
                }

                int dest_x = leftmargin + (squaresize * x) + (squaresize / 2);
                int dest_y = topmargin + (squaresize * y) + (squaresize / 2);

                //log.println("bS " + squaresize + " " + squaresize/6);
                G.drawArrow(g, ox, oy, dest_x, dest_y, squaresize / 6);

                //log.println("aS " + squaresize + " " + squaresize/6);
            }
        }

        if ((cm != null) && (cm.N() > 0) /* n<=0 are special values */)
        {
            int last_from_x = cm.fromX();
            int last_to_x = cm.toX();
            int last_from_y = cm.fromY();
            int last_to_y = cm.toY();

            if (invert_y)
            {
                last_to_y = n - last_to_y - 1;
                last_from_y = n - last_from_y - 1;
            }

            g.setColor(lastmove_arrow_color);
            G.drawArrow(g,
                (squaresize / 2) + leftmargin + (squaresize * last_from_x),
                (squaresize / 2) + topmargin + (squaresize * last_from_y),
                (squaresize / 2) + leftmargin + (squaresize * last_to_x),
                (squaresize / 2) + topmargin + (squaresize * last_to_y),
                squaresize / 6);
        }

        r = rects;
    }

    public void drawFixedElements(Graphics offGC,boolean repaint_grid)
    {
        createAllFixed(fullRect.width, fullRect.height); // create backing bitmaps
        Image allFixed = allFixed();
        Graphics allFixedGC = (allFixed==null) ? offGC : allFixed.getGraphics();
        
        if (repositionBoxes() || repaint_grid ||  (allFixed==null))
        { // draw the board and semi-fixed elements
        	paintedSize = b.size;
            redrawBoard(allFixedGC,null);
        }
        if(allFixed!=null) 
        	{offGC.drawImage(allFixed, 0, 0, fullRect.width,
                fullRect.height, this);
        	}
	
    }
    public void paintCanvas(Graphics g, boolean repaint_grid,HitPoint hp) // paint the board
    {
         //LoaGame game = c.getGame();
        int n = b.boardSize();
        if ((last_board_size != n) || (last_use_grid != use_grid))
        {
            repaint_grid = true;
            last_use_grid = use_grid;
            last_board_size = n;
        }

        Image offScreen = createOffScreen(fullRect.width, fullRect.height); // create backing bitmaps
        Graphics offGC = (offScreen==null) ? g : offScreen.getGraphics();
    	G.setClip(offGC,fullRect);
        if (last_invert_y != invert_y)
        {
            repaint_grid = true;
            last_invert_y = invert_y;
        }

        offGC.setFont(standardBoldFont);
        drawFixedElements(offGC,repaint_grid);
    	
        drawPlayerStuff(offGC,null,HighlightColor,	table_color);
        
         
        drawVcrGroup(hp, offGC, HighlightColor, vcrButtonColor);
        drawMainMessage(offGC);

        {commonPlayer p = whoseTurn();

        if (p != null)
        {
            p.drawProgressBar(offGC, progressRect);
        }}
       // draw clocks, sprites, and other ephemera
        {
            drawClocksAndMice(offGC, null);
            redrawGameLog(offGC, null, logRect, table_color);


            
            ShowStats(offGC, boardRect.x + boardRect.width/2, boardRect.y+boardRect.height + 10);
            showRectangles(offGC, CELLSIZE);
            //DrawTileSprite(offGC);      //draw the floating tile, if present
            
            DrawArrow(offGC,hp);
            drawSprites(offGC);
                       
            if(offScreen!=null) 
            	{  displayClipped(g,fullRect,chatRect,offScreen);

            	}

            invalid = false;
        }
    }


    private Point hitTest(int x, int y)
    {
        int n = rsize;

        if (!invalid && (r != null))
        {
            for (int by = 0; by < n; by++)
                for (int bx = 0; bx < n; bx++)
                    if (r[by][bx].contains(x, y))
                    {
                        return (new Point(bx, last_invert_y ? (n - by - 1) : by));
                    } // found it
        }

        return (null);
    }

    public void SelectStone(Point p)
    {
        String str = (p == null) ? "null" : U.LocationToString(p.x, p.y);
        PerformAndTransmit("Select " + str);
    }

    /** factory method to create a robot */
    public SimpleRobotProtocol newRobotPlayer() { return(new RoboPlay()); }


    public void addStones(Stone color, String spec)
    {
        String str = spec;
        Reader sr = new StringReader(str);
        Point pt;

        try
        {
            try
            {
                while ((pt = U.parsePosition(str, sr)) != null)
                {
                    b.make_square_be_color(pt.x, pt.y, (Stone_Type) color);
                }
            }
            finally
            {
                sr.close();
            }
        }
        catch (IOException err)
        {
        	G.Error(err.toString());
        }
    }

    // loa has its own version of save game to maintain some historical
    // ideosyncrancies of format.
    public sgf_game save_game()
    {
        sgf_game game = new sgf_game();
        sgf_node root = new sgf_node();
        sgf_node curr = root;
        game.root = root;
        game.current = root;
        root.set_property(gamename_property, theChat.shortNameField());
        root.set_property(gametitle_property, theChat.nameField());

        for (int i = players.length - 1; i >= 0; i--)
        {
            commonPlayer p = players[i];

            if (p != null)
            { //don't translate the color here
                root.set_property("P" + i, " id " + p.trueName);

                {
                    String rank = p.getPlayerInfo(exHashtable.RANKING);

                    if ((rank != null) && !("".equals(rank)))
                    {
                        root.set_property("P" + i, "ranking " + rank);
                    }
                }

                {
                    String ct = p.getPlayerInfo(exHashtable.COUNTRY);

                    if ((ct != null) && !("".equals(ct)))
                    {
                        root.set_property("P" + i, "country " + ct);
                    }
                }
            }
        }

 
        root.set_property("GM", LOA_SGF);

        for (int i = 0; i < History.size(); i++)
        {
            Move_Spec m = (Move_Spec) History.elementAt(i);
            sgf_node nn = new sgf_node();
            curr.addElement(nn, asOnly);
            curr = nn;
            curr.set_property("" + m.Color().getName(), m.moveString());

            if (m.getComment() != null)
            {
                curr.set_property("C", m.getComment());
            }
        }

        {
            sgf_node nn = new sgf_node();
            curr.addElement(nn, asOnly);
            curr = nn;
        }

        for (int i = players.length - 1; i >= 0; i--)
        {
            commonPlayer p = players[i];

            if (p != null)
            {
                String timestring = p.getPlayerInfo("time");

                if (!"".equals(timestring))
                {
                    timestring = " time " + timestring;
                    curr.set_property("P" + i, timestring);
                }
            }
        }

        return (game);
    }



    public void ReplayMove(sgf_node no)
    {
        String comments = "";
        sgf_property prop = no.properties;

        while (prop != null)
        {
            String name = prop.getName();
            String value = (String) prop.getValue();

            if (setup_property.equals(name))
            {
                b.doInit(value);
                b.setWhoseTurn(0);
            }

            if (name.equals(comment_property))
            {
                comments += value;
            }
            else if (name.equals(game_property))
            {
                if (!((value.equals(LOA_SGF)) || (value.toLowerCase().equals("loa"))))
                {
                	G.Error("game type " + value + " is not Expected");
                }
            }
            else if (name.equals(version_property))
            {
                if (!value.equals("1"))
                {
                	G.Error("Game version " + value + " not handled");
                }
            }
            else if ("PB".equals(name) || "PW".equals(name))
            {
                int player = "PB".equals(name) ? 0 : 1;
                commonPlayer p = players[player];

                if (p == null)
                {
                    p = players[player] = new commonPlayer(player);

               }
               if((p.trueName==null) || "".equals(p.trueName)) {  p.trueName = p.userName = value; } 
               else
            	  { StringTokenizer tokens = new StringTokenizer(value);
                    String first = tokens.nextToken();
                    parsePlayerInfo(p,first,tokens);
            	  	}
               // pb/pw also set time
            }
            else if ("W".equals(name) || "B".equals(name))
            {
                commonPlayer p = "B".equals(name) ? players[0] : players[1];
                StringTokenizer tokens = new StringTokenizer(value);
                String first = tokens.nextToken();

                if(parsePlayerInfo(p,first,tokens)) {}
                else
                {
                    String msg = first + " " + G.restof(tokens); 
                    b.setWhoseTurn(p.boardIndex);
                    PerformAndTransmit(msg, false,replayMode.Replay);
                }
            }
            else
            {
            	replayStandardProps(name,value);
            }

            prop = prop.next;
        }

        if (!"".equals(comments))
        {
            setComment(comments);
        }
    }


}