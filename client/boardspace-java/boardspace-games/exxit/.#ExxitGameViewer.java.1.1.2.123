package exxit;

import online.common.*;
import online.game.*;
import online.game.sgf.sgf_names;
import online.game.sgf.sgf_node;
import online.game.sgf.sgf_property;

import java.awt.*;
import java.util.*;

import javax.swing.JCheckBoxMenuItem;



import lib.G;
import lib.Random;


/**
 * 
 * Change History
 *
 * December 2006  Inital version, derived from Hive  

*/
public class ExxitGameViewer extends commonCanvas 
	implements ViewerProtocol, ExxitConstants, sgf_names
{
     /**
	 * 
	 */
	static final long serialVersionUID = 1L;
	// colors
    private Color reviewModeBackground = new Color(220,165,200);
    private Color HighlightColor = new Color(0.2f, 0.95f, 0.75f);
    private Color logrectHighlightColor = new Color(0.9f,0.9f,0.3f);
    private Color ZoomColor = new Color(0.0f,0.0f,1.0f);
    private Color rackBackGroundColor = new Color(165,155,155);
    private Color boardBackgroundColor = new Color(165,155,155);
    private Color vcrButtonColor = new Color(0.7f, 0.7f, 0.75f);
 
    private Font gameLogBoldFont=null;
    private Font gameLogFont = null;
    // images
    private static Image[] images = null; // images of black and white bugs
    private boolean redblack_tiles = true;
    private JCheckBoxMenuItem useWoodenTiles = null;

    private static Image[] textures = null;// background textures
    // private state
    private ExxitGameBoard b = null; //the board from which we are displaying
    private int CELLSIZE; 	//size of the layout cell
    private final double INITIAL_TILE_SCALE = 3.0;
    private double board_center_x = 0.0;
    private double board_center_y = 0.0;
    private double BOARD_TILE_SCALE = 4.0;
    private double SPRITE_TILE_SCALE = 3.5;
    private double RACK_TILE_SCALE = 2.0;
    // addRect is a service provided by commonCanvas, which supports a mode
    // to visualize the layout during development.  Look for "show rectangles"
    // in the options menu.
    //private Rectangle fullRect = addRect("fullRect"); //the whole viewer area
    //private Rectangle boardRect = addRect("boardRect"); //the actual board, normally at the left edge
    private Rectangle logRect = addRect("logRect"); //the game log, normally off the the right
    private Rectangle doneRect = addRect("doneRect");
    private Rectangle repRect = addRect("repRect");
    private Rectangle editRect = addRect("editRect");
    private Rectangle goalRect = addRect("goalRect");
    private Rectangle progressRect = addRect("progressRect");
    private Rectangle secondPlayerChipRect = addRect("secondPlayerChipRect");
    private Rectangle firstPlayerChipRect = addRect("firstPlayerChipRect");
    private Rectangle secondPlayerScoreRect = addRect("secondPlayerScoreRect");
    private Rectangle firstPlayerScoreRect = addRect("firstPlayerScoreRect");
    private Rectangle stateRect = addRect("stateRect");
    private Rectangle tilePoolRect = addRect("tilePoolRect");
    private Rectangle liftRect = addRect("liftRect");
    private boolean lifted=false;
    private Slider zoomRect = null;
    
	// whem moving, these remember the object we're dragging around
    //private HitPoint movingObject = null; // 

    public void preloadImages()
    {	
	    if (textures == null)
	    { // note that dfor this to work correctly, the images and masks must be the same size.  
	      // Refer to http://www.andromeda.com/people/ddyer/java/imagedemo/transparent.html
	      // this doesn't use the "-mask" suffix form of load images because some masks are
	      // shared.
	        images = load_masked_images(ImageDir, ImageFileNames); // load the main images
	        textures = load_images(ImageDir,TextureNames);
	    }
    }
    Color StandardMouseColors[] = MouseColors;
    Color StandardMouseDotColors[] = MouseDotColors;
    Color ExxitMouseColors[] = {Color.red,Color.black};
    Color ExxitMouseDotColors[] = {Color.black,Color.white};
    void setMouseColors()
    {	if(redblack_tiles)
    	{
        MouseColors = ExxitMouseColors;
        MouseDotColors = ExxitMouseDotColors;
    	}
    	else
    	{
    	MouseColors = StandardMouseColors;
    	MouseDotColors = StandardMouseDotColors;
    	}
    }
	/**
	 * 
	 * this is the real instance intialization, performed only once.
	 * info contains all the goodies from the environment.
	 * */
    public void init(exHashtable info)
    {
        super.init(info);
        setMouseColors();
        gameLogBoldFont = G.getFont(standardPlainFont, G.Style.Bold, FontHeight+2);
        gameLogFont = G.getFont(standardPlainFont,G.Style.Plain,FontHeight);
        zoomRect = addSlider("zoomRect",s.get("Tile Size"),ExxitId.ZoomSlider);
        zoomRect.min=1.0;
        zoomRect.max=5.0;
        zoomRect.value=2.0;
        zoomRect.barColor=ZoomColor;
        zoomRect.highlightColor = HighlightColor;

        useWoodenTiles = myFrame.addOption(s.get("use Wooden tiles"),false,deferredEvents);
       
        b = new ExxitGameBoard(info.getString(exHashtable.GAMETYPE, "Exxit"));
        doInit(false);
    }

    /** 
     *  used when starting up or replaying and also when loading a new game 
     *  */
    public void doInit(boolean preserve_history)
    {
        //System.out.println(myplayer.trueName + " doinit");
        super.doInit(preserve_history);				// let commonViewer do it's things
        b.doInit(b.gametype);						// initialize the board
        if(!preserve_history)
        	{zoomRect.setValue(INITIAL_TILE_SCALE);
        	 board_center_x = board_center_y = 0.0;
             PerformAndTransmit(reviewOnly?"Edit":"Start P0", false,replayMode.Replay);
        	}
   } 
    
    public int midGamePoint()
    {	return(40);		// exxit games are long
    }




	/**
	 * this is the main method to do layout of the board and other widgets.  I don't
	 * use swing or any other standard widget kit, or any of the standard layout managers.
	 * they just don't have the flexibility to produce the results I want.  Your milage
	 * may vary, and of course you're free to use whatever layout and drawing methods you
	 * want to.  However, I do strongly encourage making a UI that is resizable within
	 * reasonable limits, and which has the main "board" object at the left.
	 * 
	 *  The basic layout technique used here is to start with a cell which is about the size
	 *  of a board square, and lay out all the other object relative to the board or to one
	 *  another.  The rectangles don't all have to be on grid points, and don't have to
	 *  be nonoverlapping, just so long as the result generally looks good.
	 *  
	 *  When "extraactions" is available, a menu opion "show rectangles" works
	 *  with the "addRect" mechanism to help visualize the layout.
	 */ 
    public void setLocalBounds(int x, int y, int width, int height)
    {	boolean wideMode = false; //width>height*1.4;
        int ncols = b.ncols+20; // more cells wide to allow for the aux displays
        int nrows = b.nrows/2;
        int cellw = width / ncols;
        int chatHeight = selectChatHeight(height);
        int cellh = (height-(wideMode?0:chatHeight)) / nrows;
        CELLSIZE = Math.max(2,Math.min(cellw, cellh)); //cell size appropriate for the aspect ration of the canvas
        int rackWidth = 12*CELLSIZE;

        G.SetRect(fullRect,0, 0,width, height);

        // game log.  This is generally off to the right, and it's ok if it's not
        // completely visible in all configurations.
        
        G.SetRect(boardRect,CELLSIZE/2,(wideMode?0:chatHeight)+CELLSIZE*2,
        		width-CELLSIZE-rackWidth,height-G.Top(boardRect)-CELLSIZE*2);
   
        G.SetRect(stateRect,G.Left( boardRect), (wideMode?0:chatHeight)+CELLSIZE/4,
        		G.Width(boardRect)-CELLSIZE*7,3*CELLSIZE/2);
       
 
        G.SetRect(zoomRect, G.Right(stateRect),G.Top( stateRect), CELLSIZE*7,G.Height(stateRect));
 
        G.SetRect(liftRect,G.Left( zoomRect) - CELLSIZE*2, chatHeight+CELLSIZE/8,
        		2*CELLSIZE-CELLSIZE/4,2*CELLSIZE-CELLSIZE/4);
  

		//this sets up the "vcr cluster" of forward and back controls.
        SetupVcrRects(CELLSIZE / 2,
            G.Bottom(boardRect) - 3*CELLSIZE, 
            CELLSIZE * 6,
            3 * CELLSIZE);

        G.SetRect(goalRect, CELLSIZE * 3,G.Bottom(boardRect),30 * CELLSIZE, CELLSIZE*2 );
        
        G.SetRect(progressRect, G.Left(goalRect)+G.Width(goalRect)/6,G.Top(goalRect) ,G.Width(goalRect)/2, CELLSIZE/2);

        int xpos = (G.Right(boardRect)+CELLSIZE);
        int logW = CELLSIZE * 10;
        G.SetRect(logRect, wideMode ? xpos : (width-logW-CELLSIZE),0 ,logW, wideMode ? CELLSIZE*6 : chatHeight);

        {
            commonPlayer pl0 = getPlayerOrTemp(0);
            commonPlayer pl1 = getPlayerOrTemp(1);
            Rectangle p0time = pl0.timeRect;
            Rectangle p1time = pl1.timeRect;
            Rectangle p0xtime = pl0.extraTimeRect;
            Rectangle p1xtime = pl1.extraTimeRect;
            Rectangle p0anim = pl0.animRect;
            Rectangle p1anim = pl1.animRect;
            Rectangle firstPlayerRect = pl0.nameRect;
            Rectangle secondPlayerRect = pl1.nameRect;
            Rectangle firstPlayerPicRect = pl0.picRect;
            Rectangle secondPlayerPicRect = pl1.picRect;
            
            //first player name
            G.SetRect(firstPlayerRect, xpos, G.Bottom(logRect)+CELLSIZE, CELLSIZE * 6, (3 * CELLSIZE) / 2);

            // time display for first player
            G.SetRect(p0time,G.Right( firstPlayerRect),G.Top( firstPlayerRect), CELLSIZE * 3, CELLSIZE);
            G.SetRect(p0xtime,G.Left(p0time),G.Bottom(p0time),G.Width(p0time),G.Height( p0time));
            
    		// tfirst player "i'm alive" animation ball
            G.SetRect(p0anim, G.Right(p0time) ,G.Top( p0time), CELLSIZE, CELLSIZE);
            // time display for second player
           G.SetRect(p1time,G.Right( secondPlayerRect),G.Top( secondPlayerRect),G.Width( p0time),G.Height( p0time));
           
           G.SetRect(p1xtime, G.Left(p0xtime), G.Bottom(p1time),G.Width(p0xtime),G.Height( p0xtime));
           
           G.SetRect(p1anim,G.Left(p0anim), G.Top(p1time),G.Width( p0anim),G.Height(p0anim));

           G.SetRect(firstPlayerScoreRect,G.Left( p0time),G.Top(p0time)+3*CELLSIZE, CELLSIZE*3,CELLSIZE*2);
           G.SetRect(secondPlayerScoreRect,G.Left( p1time),G.Top(p1time)-4*CELLSIZE,G.Width( firstPlayerScoreRect),G.Height(firstPlayerScoreRect));
           
           // first player portrait
           G.SetRect(firstPlayerPicRect,G.Left( firstPlayerRect), G.Bottom(firstPlayerRect), CELLSIZE * 4,CELLSIZE * 4);
           
           // "edit" rectangle, available in reviewers to switch to puzzle mode
           G.SetRect(editRect, G.Right(boardRect)+CELLSIZE/2,G.Bottom( firstPlayerPicRect)+CELLSIZE,
        		    CELLSIZE*4, 3*CELLSIZE/2);

           //second player name
           G.SetRect(secondPlayerRect,G.Left( firstPlayerRect),G.Bottom(boardRect) - G.Height(firstPlayerRect),
        		   G.Width(firstPlayerRect),G.Height( firstPlayerRect));

           // player 2 portrait
           G.SetRect(secondPlayerPicRect,G.Left(secondPlayerRect),G.Top(secondPlayerRect) - G.Height( firstPlayerPicRect) ,
        		   	G.Width(firstPlayerPicRect),G.Height(firstPlayerPicRect));
 
           // "done" rectangle, should alway be visible, but only active when a move is complete.
           G.SetRect(doneRect,G.Left( editRect),G.Top( secondPlayerPicRect)-G.Height(editRect)-CELLSIZE,
        		   G.Width(editRect),G.Height(editRect));

           G.SetRect(chatRect,x,y,G.Width(boardRect), chatHeight);
        }
       
        G.SetRect(repRect,G.Right( doneRect)+CELLSIZE,G.Top( doneRect),CELLSIZE*6 ,G.Height( doneRect));
        
		// a pool of chips for the first player at the top
        G.SetRect(firstPlayerChipRect, 
        		G.Right(boardRect) + CELLSIZE/2,
        		G.Bottom(editRect)+CELLSIZE/2,
        		4*CELLSIZE, 3*CELLSIZE);
        
      
        // and for the second player at the bottom
        G.SetRect(secondPlayerChipRect,
        		G.Left(firstPlayerChipRect),
        		G.Top( doneRect)-G.Height(firstPlayerChipRect)-CELLSIZE/2,
        		G.Width(firstPlayerChipRect),
        		G.Height(firstPlayerChipRect));
        

        G.SetRect(tilePoolRect,
        		G.Right( firstPlayerChipRect)+CELLSIZE,
        		G.Top( firstPlayerChipRect),
        		CELLSIZE*7 ,
        		G.Bottom(secondPlayerChipRect)-G.Top(firstPlayerChipRect));
		
       
        positionTheChat(chatRect,Color.white,Color.white);
        
        generalRefresh();
    }

    private void DrawLiftRect(Graphics gc,HitPoint highlight)
    {	boolean hit = false;
    	if(G.pointInRect(highlight,liftRect))
    	{	hit = true;
    		highlight.hitCode = ExxitId.LiftRect;
    		highlight.dragging=lifted=highlight.down;
    	}
		if(gc!=null) 
		{ G.centerImage(gc,textures[LIFT_ICON_INDEX],liftRect,this); 
		  G.frameRect(gc,hit?HighlightColor:Color.black,liftRect);
		}
    }
    
	// draw a box of spare chips. For hex it's purely for effect.
    private boolean fliptiles = false;
    private void DrawTilePool(Graphics gc, Rectangle r, HitPoint highlight)
    {
      boolean canhit = b.LegalToHitTiles() && G.pointInRect(highlight, r);
      ExxitCell c = b.tiles;
      if(gc!=null) { G.frameRect(gc, Color.black, r); }
      Random rand = new Random(4321); // consistant randoms, different for black and white 
      boolean canDrop = canhit && (b.movingObjectIndex()>=0);
      boolean hitPiece = false;
      int height = c.height();
     // if(r.height>CELLSIZE*4)	// r can be not laid out during initialization
      {for(int i=0;i<height;i++)
        {
        	ExxitPiece p = c.pieceAtIndex(i);
            int cs = CELLSIZE*7;
            int spacex = G.Width(r) - CELLSIZE*2;
            int spacey = G.Height(r)- CELLSIZE*2;
 
            int rx = G.Left(r)+ G.nextInt(rand,spacex);
            int ry = G.Top(r)+ G.nextInt(rand,spacey);
            int index = p.imageIndex(fliptiles)
	  			+ (redblack_tiles ? REDBLACK_OFFSET : STANDARD_OFFSET);
	  			 
            if(gc!=null) 
        	{drawImage(gc, images[index], SCALES[index], rx + CELLSIZE,
                ry +CELLSIZE, cs, 1.0,0.0);
        	}
        	 if(canhit && !canDrop && G.pointInRect(highlight,rx,ry,CELLSIZE*2,CELLSIZE*2))
	        		{ highlight.hitObject = b.tiles;
	        		  highlight.arrow = StockArt.UpArrow;
	        		  highlight.awidth = CELLSIZE;
	        		  hitPiece = true;
	         		  highlight.hitCode = (p.player==(fliptiles?SECOND_PLAYER_INDEX:FIRST_PLAYER_INDEX))?ExxitId.White_Tile_Pool:ExxitId.Black_Tile_Pool;
	        		}

        }
       if(gc!=null)
    	   {G.Text(gc,true,G.Right(r)-CELLSIZE,G.Bottom(r)-CELLSIZE,CELLSIZE,CELLSIZE,Color.black,null,
    		   	""+height);
    	   }
       if(canhit && canDrop) 
       	{ highlight.hitObject = b.tiles;
       	  highlight.hitCode = ExxitId.White_Tile_Pool;
       	  highlight.arrow = StockArt.DownArrow;
       	  highlight.awidth = CELLSIZE;
       	  hitPiece = true;
       	}
       else if (canhit && !canDrop)
       {	if(!hitPiece) { highlight.hitCode = ExxitId.Flip_Tiles; }
       }
      }
    }
    private void DrawScore(Graphics gc,Rectangle r,int player)
    {
    	G.setFont(gc,gameLogBoldFont);
    	G.Text(gc,true,r,0,Color.black,rackBackGroundColor,""+b.scoreForPlayer(player,true));
    	G.frameRect(gc,Color.black,r);
    }
	// draw a box of spare gobblets. Notice if any are being pointed at.  Highlight those that are.
    private void DrawChipPool(Graphics gc, ExxitState state,Rectangle r, int player,HitPoint highlight)
    {	ExxitCell thisCell= b.rack[player];
        boolean canhit = b.LegalToHitChips(player) && G.pointInRect(highlight, r);
        boolean canDrop = canhit && (b.movingObjectIndex() == player) && G.pointInRect(highlight,r);
        boolean doesHit = canDrop;
        int cellW = G.Width(r)/2;
        if(gc!=null) { G.frameRect(gc, Color.black, r); }
        {	
        	if(thisCell!=null)
        	{
	    		int left = G.Left(r)+cellW/2;
	    		int height=thisCell.height();
    		
        		for(int bug=height; bug>0;bug--)
        		{
        		ExxitPiece topCup = thisCell.pieceAtIndex(height-bug);
        		if(topCup!=null)
        		{ int rx = left+((bug<=height/2)?cellW:0);
        		  int ry = G.Top(r)+5*G.Height(r)/8+2-CELLSIZE/3*((bug<=height/2)?height/2-bug:height-bug);
        		  int index = topCup.imageIndex(false)
        		  			+ (redblack_tiles ? REDBLACK_OFFSET : STANDARD_OFFSET);
	           	  if(canhit 
	           			&& G.pointInRect(highlight,rx-cellW/2,ry-CELLSIZE/2,cellW,CELLSIZE*2)
	           			&& (height>0)
	           			)
	        		{ doesHit = true;
 	        		}

        		  if(gc!=null)
                	{drawImage(gc, images[index], SCALES[index],rx,  ry,
                			CELLSIZE*7, 1.0,0.0);
                	//G.frameRect(gc,Color.black,left,top,cellW,SQUARESIZE);
                	}
       		}}
        		
      		if(doesHit)
      			{highlight.hitObject = thisCell;
      			highlight.hitCode = chipPoolIndex[player];
      			highlight.arrow = canDrop ? StockArt.DownArrow : StockArt.UpArrow;
      			highlight.awidth = CELLSIZE;
      			}

        		//if((gc!=null)&&(hitCell==thisCell)) { G.frameRect(gc,Color.red,left-cellW/2,top-CELLSIZE/2,cellW,2*CELLSIZE); }
           	if((gc!=null) && ((thisCell==b.pickedSource)||(thisCell==b.droppedDest)))
        	{ 
            G.DrawAACircle(gc,left,G.Top(r)+CELLSIZE/2,2,Color.green,Color.yellow,true);
            }
        	}
 

        }
    }

    public void drawSprite(Graphics g,int obj,int xp,int yp)
    {
    	int idx = obj + (redblack_tiles ? REDBLACK_OFFSET : STANDARD_OFFSET);
      	 ;
       	int cellS = (int)(CELLSIZE*zoomRect.value);
       	double scale = boardRect.contains(xp,yp)?SPRITE_TILE_SCALE:RACK_TILE_SCALE;
           drawImage(g, images[idx],SCALES[idx], xp, yp,cellS*scale);
	
    }


    /* draw the deep unchangable objects, including those that might be rather expensive
     * to draw.  This background layer is used as a backdrop to the rest of the activity.
     * in our cease, we draw the board and the chips on it. 
     * */
    public void drawFixedElements(Graphics gc)
    { boolean reviewBackground = reviewMode() && !mutable_game_record;
      G.setColor(gc,reviewBackground ? reviewModeBackground : boardBackgroundColor);
      G.tileImage(gc,textures[BACKGROUND_TILE_INDEX],fullRect, this);   
          G.tileImage(gc,textures[reviewBackground 
                                 ? BROWN_FELT_INDEX
                                 : (redblack_tiles ? YELLOW_FELT_INDEX : OLD_YELLOW_FELT_INDEX)],
          		boardRect, this); 
      G.frameRect(gc,Color.black,boardRect);
 
      // draw a picture of the board. In this version we actually draw just the grid
      // to draw the cells, set gb.Drawing_Style in the board init method
      //gb.DrawGrid(gc, tbRect, use_grid, boardBackgroundColor, Color.blue, Color.blue,Color.black);

     }

    /* draw the board and the chips on it. */
     private int liftSteps = 0;
     private void drawBoardElements(Graphics gc, ExxitGameBoard gb, Rectangle tbRect,
    		 HitPoint ourTurnSelect,HitPoint anySelect)
     {	liftSteps = lifted ? Math.min(++liftSteps,12) : Math.max(--liftSteps,0);
     	int liftdiv = 40;
     	boolean dolift = (liftSteps>0);
        Rectangle oldClip = G.setClip(gc,tbRect);
    	if(dolift && (liftSteps<12))
     		{ // this induces a very simple animation
     		repaint(20); 
     		}
     	HitPoint mo = dragPoint;
     	boolean dragging = (anySelect!=null) && (mo!=null) ;
     	boolean draggingBoard = dragging && (mo.hitCode==ExxitId.InvisibleDragBoard);
      	if(draggingBoard)
     	{	double center_x = (board_center_x*G.Width(tbRect))+(G.Left(anySelect)-G.Left(mo))*12;
     	    double center_y = (board_center_y*G.Height(tbRect))-(G.Top(anySelect)-G.Top(mo))*12;
     	    board_center_x = center_x / G.Width(tbRect);
     	    board_center_y = center_y / G.Height(tbRect);
     	    G.SetTop(mo,G.Top( anySelect));
     	    G.SetLeft(mo,G.Left(anySelect));
     	    repaint();
     	}
     	//
       	// now draw the contents of the board and anything it is pointing at
        //
         boolean somehit = draggingBoard;
         Hashtable<ExxitCell,ExxitCell> dests = gb.movingObjectDests();
         ExxitCell sourceCell = gb.pickedSource; 
         ExxitCell destCell = gb.droppedDest;
         double cs = (gb.cellToX('B',2)-gb.cellToX('A',2))/zoomRect.value;
    	 Point empty = gb.emptyColumn();	// get an empty col/row to start the display
        // precalculate the spanning size of the board.
         int cellSize =  (int)(cs*zoomRect.value);
         int ncols = gb.ncols;
         int liftYval =  cellSize/6+(dolift?(liftSteps*cellSize)/liftdiv : 0);
         int liftXval = dolift?(liftSteps*cellSize)/(2*liftdiv) : 0;
         double actCellSize = cellSize*BOARD_TILE_SCALE;
         //System.out.println("cs "+cs/CELLSIZE+ " "+cs+" "+CELLSIZE);
         for (int col0 = ncols-1; col0 >=0 ; col0--)
         {	int col = (col0+G.Left(empty))%ncols;
            char thiscol = (char) ('A' + col);
            int lastincol = gb.nInCol[col];
            for (int thisrow0 = lastincol-1;
              	   thisrow0 >= 0; 
              	   thisrow0--) // start at row 1 (0 is the grid) 
             { //where we draw the grid
               	int dispRow = (thisrow0+G.Top(empty))%lastincol+1 + gb.firstRowInCol[col];
                Point cp = gb.cellToXY(thiscol,dispRow,tbRect);	// calculate xy wrapped
                int xpos = G.Left(cp);
                int ypos = G.Top(cp);               
                //if(tbRect.contains(xpos,ypos))
                 {
                 ExxitCell cell = gb.GetExxitCell(thiscol,dispRow);
                 boolean isADest = dests.get(cell)!=null;
                 boolean isASource = (cell==sourceCell)||(cell==destCell);
                 ExxitPiece piece = cell.topPiece();
                 boolean hitpoint = !somehit
                 	&& G.pointInside(ourTurnSelect, xpos, ypos, cellSize/2) 
                 	&& gb.LegalToHitBoard(cell);
                 if(hitpoint) 
                 { somehit =true; 
                 }

                 boolean drawhighlight = hitpoint ||
                     gb.isDest(cell) ||
                     gb.isSource(cell);
  
                 // drawing
                 if (hitpoint)
                 {	 //if(gc!=null) { gc.drawOval(xpos-cellSize/2,ypos-cellSize/2,cellSize,cellSize); }
                     ourTurnSelect.hitCode = isADest?ExxitId.EmptyBoard:ExxitId.BoardLocation;
                     ourTurnSelect.arrow = isADest?StockArt.DownArrow:StockArt.UpArrow;
                     ourTurnSelect.awidth = CELLSIZE;
                     ourTurnSelect.col = thiscol;
                     ourTurnSelect.row = dispRow;
                     ourTurnSelect.hitObject = cell;
                 }

                 if (gc != null)
                 {
                 //G.DrawAACircle(gc,xpos,ypos,1,tiled?Color.green:Color.blue,Color.yellow,true);
                 if(piece!=null)
                 {	for(int hgt=cell.height()-1,lvl=0; lvl<=hgt; lvl++)
                 	{
                 	ExxitPiece drawPiece = cell.pieceAtIndex(lvl);
                     int pi = drawPiece.imageIndex(false) 
                     			+ (redblack_tiles ? REDBLACK_OFFSET : STANDARD_OFFSET);  
                     if (drawhighlight)
                     { // checking for pointable position
                       //  drawChip(gc, SELECTION_INDEX, xpos, ypos, actcellSize, 1.0,0.0);
                     }

                     if (pi >= 0)
                     {	double pscale[] = SCALES[pi];
                     	String id=null;
                     	
                        if(use_grid && (lvl==hgt)) 
                        { id= cell.cellName;
                        }
 
                     	 adjustScales(pscale,piece);
      
                     	drawImage(gc, images[pi], SCALES[pi], xpos+liftXval*lvl,ypos-liftYval*lvl, actCellSize, 1.0,0.0,id,false);

                     }
                 	}
                }
                 if(isASource)
                 {G.DrawAACircle(gc,xpos,ypos,2,Color.green,Color.yellow,true);
                 } else
                 if(isADest)
                 {G.DrawAACircle(gc,xpos,ypos,2,Color.red,Color.yellow,true);
                 }
                 }}
             }
         }
         
        if(!somehit && G.pointInRect(anySelect,tbRect) && !G.pointInRect(anySelect,vcrRect) && ((mo==null)||draggingBoard))
     	{ //let him drag anywhere, just don't annoy with the hand icon.
     		anySelect.hitCode=ExxitId.InvisibleDragBoard;
     		anySelect.dragging=anySelect.down;
     	}
  		G.setClip(gc,oldClip);
     }


    //
    // draw the board and things on it.  If gc!=null then actually 
    // draw, otherwise just notice if the highlight should be on
    //
    public void redrawBoard(Graphics gc, HitPoint selectPos)
    {  ExxitGameBoard gb = b;
       boolean moving = (getMovingObject()>=0);
       HitPoint ourTurnSelect = OurMove() ? selectPos : null;
       HitPoint buttonSelect = moving?null:ourTurnSelect;
       HitPoint nonDraggingSelect = (moving && !reviewMode()) ? null : selectPos;
  
   
       ExxitState state = b.getState();
        redrawGameLog(gc, nonDraggingSelect, logRect, Color.black, logrectHighlightColor,gameLogBoldFont,gameLogFont);
        drawBoardElements(gc, gb, boardRect, ourTurnSelect,nonDraggingSelect);
        DrawChipPool(gc, state, secondPlayerChipRect, SECOND_PLAYER_INDEX, ourTurnSelect);
        DrawChipPool(gc, state, firstPlayerChipRect, FIRST_PLAYER_INDEX, ourTurnSelect);
        DrawScore(gc,firstPlayerScoreRect,FIRST_PLAYER_INDEX);
        DrawScore(gc,secondPlayerScoreRect,SECOND_PLAYER_INDEX);
        DrawTilePool(gc, tilePoolRect,ourTurnSelect);
        zoomRect.draw(gc,nonDraggingSelect);
        DrawLiftRect(gc,nonDraggingSelect);
        DrawRepRect(gc,b.Digest(),repRect);
        //System.out.println("dig "+b.Digest());
        
        G.setFont(gc,standardBoldFont);
		if (state != ExxitState.PUZZLE_STATE)
        {
             if (G.handleRoundButton(gc, doneRect, 
            		((b.DoneState()) ? buttonSelect : null), 
            		s.get(DoneAction),
                    HighlightColor, rackBackGroundColor))
            {	// always display the done button, but only make it active in
            	// the appropriate states
            	buttonSelect.hitCode = DefaultId.HitDoneButton;
            }
            if (allowed_to_edit)
            {
              if (G.handleRoundButton(gc, editRect, buttonSelect, s.get(EditAction),
                                HighlightColor, rackBackGroundColor))
                    {
                    	buttonSelect.hitCode = DefaultId.HitEditButton;
                    }
              }
        }

		drawPlayerStuff(gc,(state==ExxitState.PUZZLE_STATE),moving?null:selectPos,HighlightColor,rackBackGroundColor);


            standardGameMessage(gc,
            		state==ExxitState.GAMEOVER_STATE?gameOverMessage():s.get(state.getDescription()),
            				state!=ExxitState.PUZZLE_STATE,
            				gb.whoseTurn,
            				stateRect);
            goalAndProgressMessage(gc,selectPos,s.get("expand the board with your color tiles"),progressRect, goalRect);

        drawVcrGroup(nonDraggingSelect, gc, HighlightColor, vcrButtonColor);

    }
    public boolean PerformAndTransmit(commonMove m, boolean transmit,replayMode mode)
    {	// the super method in commonCanvas is where the history is actually recorded
       	if(((m.op==MOVE_DONE) 
       			&& (b.getState()==ExxitState.PASS_STATE)
       			&& OurMove() 
       			&& (mode==replayMode.Live)
       			))
       		{	// insert a "pass" before "done"
       		PerformAndTransmit("Pass"); 
       		}
       	boolean val =  super.PerformAndTransmit(m,transmit,mode);
    	return(val);
    }
    /**
     * Execute a move by the other player, or as a result of local mouse activity,
     * or retrieved from the move history, or replayed form a stored game. 
     * @param mm the parameter is a commonMove so the superclass commonCanvas can
     * request execution of moves in a generic way.
     * @return true if all went well.  Normally G.Error would be called if anything went
     * seriously wrong.
     */
     public boolean Execute(commonMove mm,replayMode replay)
    {	Exxitmovespec m = (Exxitmovespec)mm;
 
    
        if(b.getState()==ExxitState.PUZZLE_STATE)
    	{   mm.setSliderNumString("--");
    		switch(m.op)
        	{
        	case MOVE_PICK: 
        		break;
        	case MOVE_PICKB: 
        		break;
    		case MOVE_DROPB:
    			//this is used in the aux_slider code 
    			lastDropped = b.pickedObject;
    			// fall into default
				//$FALL-THROUGH$
			default:
    			mm.setLineBreak(true);
        	}
    	}
 
        handleExecute(b,m,replay);
        b.labelCells();
        switch(m.op)
        {
        case MOVE_MOVE:
        	m.shortMoveString = b.distributionLabel();
        	break;
        case MOVE_EXCHANGE:
        	m.shortMoveString = b.exchangeLabel();
        	break;
        case MOVE_DROPB:
        case MOVE_PICKB:
        	{
        	ExxitCell c = b.GetExxitCell(m.from_col,m.from_row);
        	m.shortMoveString = c.cellName;
        	}
        	break;
		default:
			break;
        }
        if(replay!=replayMode.Replay) { playSounds(m); }

         return (true);
    }
     
 void playSounds(Exxitmovespec mm)
 {
	switch(mm.op)
	{
	case MOVE_EXCHANGE:
	case MOVE_MOVE:
		int n = mm.undoDistributionInfo;
		while(n-- >0) { playASoundClip(light_drop,100); }
		//playASoundClip(heavy_drop,50);
		break;
	case MOVE_PICK:
	case MOVE_PICKB:
	case MOVE_DROPB:
		playASoundClip(light_drop,100);
		break;
	default: break;
	}
 }
/**
 * parse a move specifier on behalf of the current player.  This is called by the 
 * "game" object when it receives a move from the other player.  Note that it may
 * be called while we are in review mode, so the current state of the board should
 * not be considered.
 */
    public commonMove ParseNewMove(String st)
    {
        return (new Exxitmovespec(st, -1));
    }
/**
 * prepare to add nmove to the history list, but also edit the history
 * to remove redundant elements, so that indecisiveness by the user doesn't
 * result in a messy replay.
 * This may require that move be merged with an existing history move
 * and discarded.  Return null if nothing should be added to the history
 * One should be very cautious about this, only to remove real pairs that
 * result in a null move.
 * 
 */
    public commonMove EditHistory(commonMove nmove)
    {	// allow forced passes that are in the game record for appearance sake
    	return(super.EditHistory(nmove,(nmove.op==MOVE_PASS)));
    }


/**
 * the preferred mouse gesture style is to let the user "pick up" objects
 * by simply clicking on them, but we also allow him to click and drag. 
 * StartDragging is called when he has done this.
 */
    public void StartDragging(HitPoint hp)
    {
        int mo = b.movingObjectIndex();
        
        if ((mo <0) && (hp.hitCode instanceof ExxitId)) // not dragging anything yet, so maybe start
        {
       	ExxitId hitObject = (ExxitId)hp.hitCode;
		ExxitCell cell = (ExxitCell)hp.hitObject;
		ExxitPiece bug = (cell==null) ? null : cell.topPiece();
		ExxitState state = b.getState();
      		
  		switch(hitObject)
	    {
	    default: break;
	    case Black_Tile_Pool:
	    case White_Tile_Pool:
            {
            String col = hitObject.shortName;
            if(state==ExxitState.DROPTILE_STATE) { col = TILE_NAMES[b.whoseTurn]; }
            PerformAndTransmit("Pick "+col);
            }
            break;
	    case Flip_Tiles:
	    	//fliptiles = !fliptiles;	// local action only
	    	break;
        case InvisibleDragBoard:
        	if(b.moveNumber<=1)
        	{ break;
        	}
        	break;
	    case LiftRect:
        case ZoomSlider:
        	break;
	    case Black_Chip_Pool:
	    	PerformAndTransmit("Pick B "+cell.row+" "+CHIP_NAMES[bug.player]);
	    	break;
	    case White_Chip_Pool:
	    	PerformAndTransmit("Pick W "+cell.row+" "+CHIP_NAMES[bug.player]);
	    	break;
	    case BoardLocation:
	    	switch(state)
	    	{
	    	case DROPTILE_STATE:
	    		PerformAndTransmit("Dropb "+TILE_NAMES[b.whoseTurn]+" "+hp.col+" "+hp.row);
	    		break;
	    	case DROP_STATE:
	    	case EXCHANGE_STATE:
	    	case DROP_OR_EXCHANGE_STATE:
	    		if(cell.canExchange())
	    				{
	    				PerformAndTransmit("Exchange " + hp.col+" "+hp.row+" "+CHIP_NAMES[b.whoseTurn]);
	    				}
	    		else 
	    			{PerformAndTransmit("Dropb "+CHIP_NAMES[b.whoseTurn]+" "+hp.col+" "+hp.row);
	    			}
	    		break;
	    	case CONFIRM_STATE:
	    	case PUZZLE_STATE:
	    	case DISTRIBUTE_STATE:
	    		PerformAndTransmit("Pickb "+hp.col+" "+hp.row+" "+CHIP_NAMES[bug.player]);
	    		break;
	    	case CONFIRM_DISTRIBUTE_STATE:
	    	case CONFIRM_EXCHANGE_STATE:
	    		PerformAndTransmit(RESET);
	    		break;
	    	default: throw G.Error("Not expecting state "+state);
	    	}
	    	break;
        }

        if (b.movingObjectIndex() >= 0)
	        {	// if we got something started, inform the mouse handler
	            hp.dragging = true;
	        } 
         }
    }

	/** 
	 * this is called on "mouse up".  We may have been just clicking
	 * on something, or we may have just finished a click-drag-release.
	 * We're guaranteed just one mouse up, no bounces.
	 */
    public void StopDragging(HitPoint hp)
    {
        CellId id = hp.hitCode;
        if(!(id instanceof ExxitId)) {  missedOneClick = performStandardActions(hp,missedOneClick); }
    	else {
    	missedOneClick = false;
    	ExxitId hitObject = (ExxitId)hp.hitCode;
        ExxitState state = b.getState();
		ExxitCell cell = (ExxitCell)hp.hitObject;
		ExxitPiece bug = (cell==null) ? null : cell.topPiece();
       	
		switch (hitObject)
        {
        default:
        	throw G.Error("Hit Unknown object " + hitObject);
        case ZoomSlider:
        case LiftRect:
        case InvisibleDragBoard:
        	break;
        case EmptyBoard:
        case BoardLocation:	// we hit an occupied part of the board 
			switch(state)
			{
			default: throw G.Error("Not expecting drop on filled board in state "+state);
			case CONFIRM_STATE:
			case CONFIRM_DISTRIBUTE_STATE:
			case CONFIRM_EXCHANGE_STATE:
				break;
				
			case DISTRIBUTE_STATE:
			case DROP_STATE:
			case DROP_OR_EXCHANGE_STATE:
			case EXCHANGE_STATE:
			case PUZZLE_STATE:
			case DROPTILE_STATE:
			{
				String name = b.movingObjectName();
				if(name!=null)
				{ ExxitCell source = b.pickedSource;
				  if((state==ExxitState.DISTRIBUTE_STATE) && (cell != source))
					{ int dir = b.findDirection(source.col,source.row,cell.col,cell.row);
					  PerformAndTransmit("Move "+name+" "+source.col+" "+source.row+" "+dir);
					}
					else
					{ PerformAndTransmit("Dropb "+name+" "+cell.col+" "+cell.row); 
					}
				}
				else if((bug!=null) && (bug.typecode==TILE_TYPE))
				{
				PerformAndTransmit( "pickb "+TILE_NAMES[bug.player]+" "+cell.col+" "+cell.row);
				}
				break;
			}}
			break;
        case Black_Tile_Pool:
        case White_Tile_Pool:
    	{
            String name = b.movingObjectName();
            if(name!=null) 
			{//if we're dragging a black chip around, drop it.
            	switch(state)
            	{
            	default: throw G.Error("can't drop on pool in state "+state);
            	case DROPTILE_STATE:
               	case PUZZLE_STATE:
                	PerformAndTransmit("Drop "+name);
            		break;
            	}
			}
        	}
    	break;
        case Black_Chip_Pool:
        case White_Chip_Pool:
    	{
        	String name = b.movingObjectName();
            if(name!=null) 
			{//if we're dragging a black chip around, drop it.
            	switch(state)
            	{
            	default: throw G.Error("can't drop on rack in state "+state);
            	case DROP_OR_EXCHANGE_STATE:
               	case DROP_STATE:
               	case DISTRIBUTE_STATE:
               	case EXCHANGE_STATE:
               		performReset();
            		break;

               	case PUZZLE_STATE:
            		PerformAndTransmit("Drop "+name);
            		break;
            	}
			}
        	}
            break;

        case Flip_Tiles: break; // no action here
        }
    	}
//        movingObject = null;
        repaint(20);
    }



    /** this is the place where the canvas is actually repainted.  We get here
     * from the event loop, not from the normal canvas repaint request.
     */
    public void drawCanvas(Graphics offGC, boolean complete,HitPoint hp)
    {
    	b.SetDisplayParameters(zoomRect.value,1.0,board_center_x,board_center_y,30.0); // shrink a little and rotate 30 degrees
    	b.SetDisplayRectangle(boardRect);

     	drawFixedElements(offGC,complete);
   	
    	// draw the board contents and changing elements.
        redrawBoard(offGC,hp);
        //      draw clocks, sprites, and other ephemera
        drawClocksAndMice(offGC, null);
        DrawTileSprite(offGC,hp); //draw the floating tile, if present
        DrawArrow(offGC,hp);
        drawSprites(offGC);
 
    }
    
    // return what will be the init type for the game
    public String gameType() { return(b.gametype); }
    public String sgfGameType() { return(Exxit_SGF); }
    public void performHistoryInitialization(StringTokenizer his)
    {   //the initialization sequence
    	String token = his.nextToken();
        b.doInit(token);
    }



    /** return the player whose turn it really is.  This is used by the game controller
     * to key sounds and other per player turn actions.
     */
    public BoardProtocol getBoard()
    {
        return (b);
    }


    /** this is used by the game controller to supply entertainment strings to the lobby */
    public String gameProgressString()
    {	   return ((mutable_game_record ? Reviewing : ("" + viewMove)) + " " +
            b.scoreForPlayer(FIRST_PLAYER_INDEX,true) + " " +
            b.scoreForPlayer(SECOND_PLAYER_INDEX,false));

    }

    /** handle action events
     * 
     */
    public boolean handleDeferredEvent(Object target)
    {
        boolean handled = super.handleDeferredEvent(target);
        if (target == useWoodenTiles)
        {	handled=true;
        	redblack_tiles = !useWoodenTiles.getState();
        	setMouseColors();
        	generalRefresh();
        }
        return (handled);
    }
    public SimpleRobotProtocol newRobotPlayer() { return(new ExxitPlay()); }


    /** replay a move specified in SGF format.  
     * this is mostly standard stuff, but the key is to recognise
     * the elements that we generated in sgf_save
     */
    public void ReplayMove(sgf_node no)
    {
        String comments = "";
        sgf_property prop = no.properties;

        while (prop != null)
        {
            String name = prop.getName();
            String value = (String) prop.getValue();

            if (setup_property.equals(name))
            {
                b.doInit(value);
             }
            else if (name.equals(comment_property))
            {
                comments += value;
            }
            else if (name.equals(game_property))
            {
                if (!(value.toLowerCase().equals("exxit") || value.equals(Exxit_SGF)))
                {
                	throw G.Error("game type " + value + " is not this game");
                }
            }
            else if (parseVersionCommand(name,value,2)) {}
            else if (parsePlayerCommand(name,value)) {}
            else
            {
                replayStandardProps(name,value);
            }

            prop = prop.next;
        }

        if (!"".equals(comments))
        {
            setComment(comments);
        }
    }
}
