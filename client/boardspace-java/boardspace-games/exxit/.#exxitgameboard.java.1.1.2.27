package exxit;

import online.common.*;
import online.game.*;

import java.util.*;

/**
 * ExxitGameBoard knows all about the game of Exxit, which is played
 * on a heagonal board which is constructed as you play
 * common.hexBoard, which knows about the coordinate system.  
 * 
 * Exxit was cloned from Hive, so the board representation is initially
 * very similar.  In particular, the edgeless board with a diameter of about
 * 26 is a shared feature.
 * 
 * This class doesn't do any graphics or know about anything graphical, 
 * but it does know about states of the game that should be reflected 
 * in the graphics.
 * 
 *  The principle interface with the game viewer is the "Execute" method
 *  which processes moves.  Note that this
 *  
 *  In general, the state of the game is represented by the contents of the board,
 *  whose turn it is, and an explicit state variable.  All the transitions specified
 *  by moves are mediated by the state.  In general, my philosophy is to be extremely
 *  restrictive about what to allow in each state, and have a lot of tripwires to
 *  catch unexpected transitions.   We expect to be fed only legal moves, but mistakes
 *  will be made and it's good to have the maximum opportunity to catch the unexpected.
 *  
 * Note that none of this class shows through to the game controller.  It's purely
 * a private entity used by the viewer and the robot.
 * 
 * @author ddyer
 *
 */

public class ExxitGameBoard extends hexBoard implements BoardProtocol,ExxitConstants
{ 	static final boolean debug=false;
     //
    // private variables
    //
    public ExxitCell rack[]=new ExxitCell[2];						// pieces in reserve, one cell per player with a stack of chips
    public ExxitCell tiles = null;									// tiles in reserve, one cell with a stack of hexes
    private ExxitCell transportCell = null;							// spare cell used in distribution moves
    private ExxitCell undoCell = null;								// stack of pieces in the last move
    private ExxitPiece allPieces[] = new ExxitPiece[2*NUMPIECES];	// all the pieces all the chips regardless of color or location
    private ExxitPiece allTiles[] = new ExxitPiece[NUMTILES];		// all the tiles regargless of location
    private ExxitPiece everyThing[]=new ExxitPiece[2*NUMPIECES+NUMTILES];	// all chips and all tiles
    private int numberOfThings=0;
    private int blob_index[] = new int[2];							// how many blobs per player
    private int blob_size[][] = new int[2][NUMTILES];				// size of each blob per player
    private boolean blobs_valid = false;								// true when the a sweep is known to be unnecessary
    private int sweep_counter=0;									// incremented when a sweep of cells is needed
    private int tilesInGame = NUMTILES;								// number of tiles actually in the game, some may be discarded for short games
	private int tilesOnBoard = 0;									// count of tiles played
    private boolean prosetup = false;								// true if playing the pro game 
	private boolean pass_ends_game = false; // after one pass
	// these are used only for labeling
	private int prisonerCount = 0;					// number of prisoner groups that have been created
	private int droppedTileCount = 0;				// number of pregame tiles
	
    // intermediate states in the process of an unconfirmed move should
    // be represented explicitly, so unwinding is easy and reliable.
    public ExxitPiece pickedObject = null;		// the object in the air being moved
    public ExxitCell pickedSource = null;		// the source of the object
    public ExxitCell droppedDest = null;		// the place it was dropped
    
    // temporary list of destination cells allocate as a resource for speed
    private ExxitCell[][]tempDestResource = new ExxitCell[6][];
    private int tempDestIndex=-1;
    public synchronized ExxitCell []getTempDest() 
    	{ if(tempDestIndex>=0) { return(tempDestResource[tempDestIndex--]); }
    	  return(new ExxitCell[NUMTILES+6]);
    	}
    public synchronized void returnTempDest(ExxitCell[]d) { tempDestResource[++tempDestIndex]=d; }
    

    public final ExxitCell GetExxitCell(char c,int row) 
    { return((ExxitCell)GetBoardCell(c,row)); 
    }
     
    // construct an array of all the places the moving tile or chip can be dropped
    private int legalDropDests(ExxitCell dests[])
    {	int n=0;
    	boolean droptile = (pickedObject!=null) && (pickedObject.typecode==TILE_TYPE);
    	boolean puzzle = (board_state==PUZZLE_STATE);
    	sweep_counter++;
   		for(int i=0;i<tilesInGame;i++)
		{	ExxitCell c = allTiles[i].location;
			if((c!=null)&&c.onBoard)
			{	if(droptile)
				{	G.Assert(c.height()>0,"cell isn't empty");
					// tiles can be dropped adjacent to existing tiles
					{ for(int dir=0;dir<6;dir++) 
						{ ExxitCell dc = (ExxitCell)c.exitToward(dir);
						  if((dc.sweep_counter!=sweep_counter) && (dc.height()==0)) 
						  	{ dc.sweep_counter=sweep_counter; 
						  	  dests[n++]=dc; 
						    }
						}
					}
				}
				else if(puzzle || c.isEmptyTile()) 
				{ // chips can be dropped on empty tiles
				  dests[n++] = c; 
				}
			}
		}
   		return(n);
    }
    //
    // note that this has to work correctly both when "picked" has been picked
    // up, and when it is still sitting on top of "source"
    //
    private int legalDests(ExxitCell source,ExxitPiece picked,ExxitCell dests[])
    {	
       	int nadded = 0;
       	switch(board_state)
    	{
     	case DISTRIBUTE_STATE:
    		if(source!=null) 
    			{	// source already picked
    			unPickObject();				// temporarily undo the pick
    			dests[nadded++] = source;
    			Vector all = GetListOfMoves();
    			for(int i=0;i<all.size();i++)
    			{	Exxitmovespec sp = (Exxitmovespec)all.elementAt(i);
    				if(source!=null)
    				{
    					if((sp.from_col == source.col) && (sp.from_row==source.row))
	    				{	
	    					int dir = sp.direction;
	    					int height = source.height()-1;
	    					ExxitCell tc = (ExxitCell)source.exitToward(dir);
	    					while((height>0)) 
	    					{	dests[nadded++]=tc;
	    						height--;
	       						if(tc.height()==0) break;
	       					 	tc = (ExxitCell)tc.exitToward(dir);
	    					}
	    				}
    				}
    			}
    			pickObject(source);
    			}
    			else 
    			{
    			Vector all = GetListOfMoves();
    			for(int i=0;i<all.size();i++)
    				{
    				Exxitmovespec sp = (Exxitmovespec)all.elementAt(i);
    				dests[nadded++] = GetExxitCell(sp.from_col,sp.from_row);
    				}
    			}
    			return(nadded);
     		// otherwise fall into the general drop logic
    		
      	case DROP_STATE:
    	case DROP_OR_EXCHANGE_STATE:
    	case EXCHANGE_STATE:
    	case DROPTILE_STATE:
    		if(source!=null) { unPickObject(); }
    		Vector all =  new Vector();
     	 	if(board_state==DROPTILE_STATE) { GetListOfDroptileMoves(all,whoseTurn); }
    	 	else { GetListOfDropMoves(all,whoseTurn); }
     		if(source==null) {  GetListOfExchangeMoves(all,whoseTurn); }

     		for(int i=0;i<all.size();i++)
    		{	Exxitmovespec sp = (Exxitmovespec)all.elementAt(i);
    			dests[nadded++] = GetExxitCell(sp.from_col,sp.from_row);
    		}
     		if(source!=null) { pickObject(source); }
     		return(nadded);
    	default:
    		G.Error("Not expecting state "+board_state);
       	case PUZZLE_STATE:
    		return(legalDropDests(dests));
    	}
    }
	
	// factory method for cells on the board
	public cell newcell(char c,int r)
	{	return(new ExxitCell(c,r));
	}
	// make a new chip
	private void makepiece(int pl,int idx,int typ,int seq)
	{	// create a piece and place it in the rack.  Create cells for the rack.
		int pidx = idx;
		ExxitPiece p = allPieces[pidx]=new ExxitPiece(typ*2+pl,typ,pl,seq,SCALES[typ]);
		everyThing[numberOfThings++] = p;
		ExxitCell c = rack[pl];
		if(c==null) 
			{ c = rack[pl]= new ExxitCell((char)('a'+pl),typ);
			  c.onBoard=false;
			}
		c.addPiece(p);
		p.home_location=c;		// note the home position for each piece
	}
	// make a new tile
	private void maketile(int player,int typ,int seq)
	{	ExxitPiece p = new ExxitPiece(typ*2+player,typ,player,seq,SCALES[typ]);
		if(tiles==null) { tiles = new ExxitCell('t',typ,NUMTILES); tiles.onBoard=false;  }
		tiles.addPiece(p);
		allTiles[seq]=p;
		everyThing[numberOfThings++]=p;
		p.home_location=tiles;
	}
	
    public ExxitGameBoard(String init) // default constructor
    {
        drawing_style = STYLE_CELL;//STYLE_NOTHING; // don't draw the cells.  STYLE_CELL to draw them
        Grid_Style = EXXITGRIDSTYLE;
        isTorus=true;
        transportCell = new ExxitCell('t',0); 
        transportCell.onBoard=false;
        undoCell = new ExxitCell('u',0);
        undoCell.onBoard=false;
        // create the set of pieces used in the game.
        int idx=0;
        for(int pl=FIRST_PLAYER_INDEX; pl<=SECOND_PLAYER_INDEX;pl++)
        { 
          for(int j=0;j<NUMPIECES;j++) { makepiece(pl,idx,CHIP_TYPE,idx); idx++;}	// 8 chips
        }
        // make the tiles second so they're on the end of the "everyThing" list
        for(int j=0;j<NUMTILES;j++) { maketile(j&1,TILE_TYPE,j); }
        doInit(init); // do the initialization 
    }


    // not a draw state for us, but an end of game state
    public void SetDrawState()
    	{ setBoardState(DRAW_STATE); }
    

    // standared init for Hex.  Presumably there could be different
    // initializations for variation games.
    private void Init_Standard(String game)
    {	int[] firstcol = null;
    	int[] ncol = null;
    	boolean blitz = Exxit_BLITZ.equals(game);
    	boolean beginner = Exxit_Beginner.equals(game);
    	int tilecount = blitz ? 29 : (beginner ? 19 : NUMTILES);
    	prosetup = Exxit_PRO.equals(game);
    	firstcol = ExxitCols; 
    	ncol = ExxitNInCol;
        gametype = game;
        setBoardState(PUZZLE_STATE);
        initBoard(firstcol, ncol, null); //this sets up the hex board
        whoseTurn = FIRST_PLAYER_INDEX;
        numberOfThings = everyThing.length;
        
        while(tiles.height()>tilecount) 
        	{ ExxitPiece p = tiles.removeTop();
        	  int h = tiles.height();
           	  --numberOfThings;
           	  G.Assert(allTiles[h]==p,"same piece for allTiles");
        	  G.Assert(everyThing[numberOfThings]==p,"same piece");
        	  //allTiles[h]=null;
        	  //everyThing[numberOfThings]=null;
        	  tilesInGame=h;
        	}
  
        pickObject(tiles);
        pickedObject.setColor(SECOND_PLAYER_INDEX);
        dropObject(BoardLocation,'M',14);
        labelCell('M',14);
        acceptPlacement();
        
        pickObject(tiles);
        pickedObject.setColor(FIRST_PLAYER_INDEX);
        dropObject(BoardLocation,'N',14);
        labelCell('N',14);
        acceptPlacement();
 
        if(!prosetup)
        {          
        pickObject(tiles);
        pickedObject.setColor(FIRST_PLAYER_INDEX);
        dropObject(BoardLocation,'M',13);
        labelCell('M',13);
        acceptPlacement();
        
        pickObject(tiles);
        pickedObject.setColor(SECOND_PLAYER_INDEX);
        dropObject(BoardLocation,'N',13);
        labelCell('N',13);
        acceptPlacement(); 
        }
        
        if(Exxit_INIT.equals(game))
        {
        }
        else if(blitz || beginner)
        {	
        }
        else if(prosetup)
        { 
        }
        else { G.Error("Not init named "+game); }
        droppedDest = null;
        pickedSource = null;
        pickedObject = null;
    }

    /**
     * Robots use this to verify a copy of a board.  If the copy method is
     * implemented correctly, there should never be a problem.  This is mainly
     * a bug trap to see if BOTH the copy and sameboard methods agree.
     * @param from_b
     */
    public void sameboard(ExxitGameBoard from_b)
    {
        super.sameboard(from_b); // hexboard compares the boards
        for(ExxitCell c = (ExxitCell)allCells,d=(ExxitCell)from_b.allCells;  
        			c!=null;
        			c=(ExxitCell)c.next, d=(ExxitCell)d.next)
        			{G.Assert(c.sameCell(d),"cells match");
        			}
        for (int i = FIRST_PLAYER_INDEX; i <= SECOND_PLAYER_INDEX; i++)
        {
            G.Assert(win[i] == from_b.win[i], "Win[] matches");
            ExxitCell myRack=rack[i];
            ExxitCell hisRack=from_b.rack[i];
            // check the rack contents
            myRack.sameCell(hisRack); 
        }

        // here, check any other state of the board to see if
        G.Assert((whoseTurn == from_b.whoseTurn) &&
            (board_state == from_b.board_state) &&
            (moveNumber == from_b.moveNumber) &&
            (pass_ends_game == from_b.pass_ends_game) &&
            (tilesOnBoard == from_b.tilesOnBoard) &&
            (resign_planned == from_b.resign_planned), "Boards not the same");
        G.Assert(Digest()==from_b.Digest(),"Digest matches");
    }

    /** this is used in fraud detection to see if the same game is being played
     * over and over. Each game in the database contains a digest of the final
     * state of the game.  Other site machinery looks for duplicate digests.
     * @return an integer representing the digested state of the game.
     */
    public int Digest()
    {	int v = 0;
        // the basic digestion technique is to xor a bunch of random numbers. The key
        // trick is to always generate exactly the same sequence of random numbers, and
        // xor some subset of them.  Note that if you tweak this, all the existing
        // digests are invalidated.
        //
        Random r = new Random(64 * 1000); // init the random number generator
        int pos[] = new int[6];
        v = tilesOnBoard*r.nextInt();
        for(int i=0;i<6;i++) { pos[i]=r.nextInt(); }
		for(int i=0;i<numberOfThings; i++)
		{	int rv = 0;
			ExxitPiece p = everyThing[i];
			ExxitCell c = p.location;
			if((c!=null) && c.onBoard && (p==c.topPiece())) 
				{	cell adjacent[] = c.adjacent;
					rv = c.Digest(r);
					for(int j=0;j<adjacent.length;j++)
					{	ExxitCell ac = (ExxitCell)adjacent[j];
						rv += (pos[j]^ac.Digest(r));
					}
					v += rv;
				}
		}
	   int w1 = r.nextInt();
	   int w2 = r.nextInt();
	   v ^= (whoseTurn==FIRST_PLAYER_INDEX) ? w1 : w2;
       if(resign_planned) { v^=r.nextInt(); }
       return (v);
    }
    
    // this visitor method implements copying the contents of a cell on the board
    public void cloneCell(cell c,cell from)
    {	ExxitCell cc = (ExxitCell)c;
    	cc.copyFrom((ExxitCell)from,allPieces,allTiles);
    }
    public BoardProtocol cloneBoard() 
	{ ExxitGameBoard dup = new ExxitGameBoard(gametype); 
	  dup.clone(this);
	  return(dup); 
   	}

    /* make a copy of a board.  This is used by the robot to get a copy
     * of the board for it to manupulate and analyze without affecting 
     * the board that is being displayed.
     *  */
    public void clone(ExxitGameBoard from_board)
    {
        ExxitGameBoard from_b = from_board;
        G.Assert(from_b != this, "can clone from myself");
        doInit(from_b.gametype);
        
        super.clone(from_b);

        whoseTurn = from_b.whoseTurn;
        board_state = from_b.board_state;
        moveNumber = from_b.moveNumber;
        resign_planned = from_b.resign_planned;
        pass_ends_game = from_b.pass_ends_game;
        prisonerCount = from_b.prisonerCount;
        droppedTileCount = from_b.droppedTileCount;
        tilesOnBoard = from_b.tilesOnBoard;
        for(int i=FIRST_PLAYER_INDEX;i<=SECOND_PLAYER_INDEX;i++) 
		{  win[i] = from_b.win[i];
		   ExxitCell myRack=rack[i];
		   ExxitCell hisRack=from_board.rack[i];
		   // clone the rack cells
		   cloneCell(myRack,hisRack);
		}
		cloneCell(tiles,from_board.tiles);
        if(debug) { sameboard(from_b); }
    }

    /* initialize a board back to initial empty state */
    public void doInit(String gtype)
    {

       rack[0].doInit(); 
       rack[1].doInit();
       undoCell.doInit();
       transportCell.doInit();
       tiles.doInit();
       blob_index[0]=blob_index[1]=0;
       tilesInGame = NUMTILES;
       for(int i=0;i<allPieces.length;i++)
       { 	ExxitPiece p = allPieces[i];
       		p.location=null;
       	    p.home_location.addPiece(p);
       }
       for(int i=0;i<tilesInGame;i++)
       {	ExxitPiece p = allTiles[i];
       		p.location=null;
       		tiles.addPiece(p);
       }
       prisonerCount = 0;
       droppedTileCount = 0;
       tilesOnBoard = 0;
       blobs_valid = false;
       droppedDest=null;
       pickedSource=null;
       pickedObject=null;
       win[0] = win[1] = false;
       resign_planned = false;
       pass_ends_game = false;
       moveNumber = 1;
       board_state=PUZZLE_STATE;

       Init_Standard(gtype.toLowerCase());
       
        // note that firstPlayer is NOT initialized here
    }

    public void setWhoseTurn(int who)
    {	
        whoseTurn = (who<0)?FIRST_PLAYER_INDEX:who;
    }

    //
    // change whose turn it is, increment the current move number
    //
    public void setNextPlayer()
    {
        switch (board_state)
        {
        default:
            G.Error("Move not complete, can't change the current player");
        case PUZZLE_STATE:
            break;
        case CONFIRM_DISTRIBUTE_STATE:
        case CONFIRM_EXCHANGE_STATE:
        case CONFIRM_STATE:
        case PASS_STATE:
        case DRAW_STATE:
        case RESIGN_STATE:
            moveNumber++; //the move is complete in these states
            setWhoseTurn(nextPlayer[whoseTurn]);
            return;
        }
    }

    /** this is used to determine if the "Done" button in the UI is live
     *
     * @return true if the "done" button should be active
     */
    public boolean DoneState()
    {	if(resign_planned) { return(true); }
        switch (board_state)
        {
        case CONFIRM_STATE:
        case CONFIRM_DISTRIBUTE_STATE:
        case CONFIRM_EXCHANGE_STATE:
        case PASS_STATE:
        case DRAW_STATE:
            return (true);

        default:
            return (false);
        }
    }
    public boolean DigestState()
    {	if(resign_planned) { return(false); }
    	return(DoneState());
    }
    public void setGameOver(boolean winCurrent,boolean winNext)
    {	if(winCurrent && winNext) { winCurrent=winNext=false; }	// simultaneous win is a draw
    	win[whoseTurn]=winCurrent;
    	win[nextPlayer[whoseTurn]]=winNext;
    	setBoardState(GAMEOVER_STATE);
    }
    
    // count the number of cells whose top color matches "pl"
    // this is used as a factor in some evaluators
    int countTopCells(int pl)
    {  	int n = 0;
    	for(int i=0;i<tilesInGame;i++)
    	{	ExxitPiece p = allTiles[i];
    		if(p!=null)
    		{	ExxitCell c = p.location;
    			if((c!=null) && c.onBoard)
    			{	ExxitPiece p1 = c.topPiece();
    				if((p1.typecode==CHIP_TYPE)&&(p1.player==pl)) { n++; }
    			}
    		}
    	}
    	return(n);
    }
    // sweep from a particular cell, counting the size of the blobs
    void sweep_from(int player,int blob,ExxitCell cell)
    {	cell.sweep_counter = sweep_counter;
    	blob_size[player][blob]++;
    	cell.blobNumber = blob; 
    	
     	for(int i=0;i<6;i++) 
    	{	ExxitCell c = (ExxitCell)cell.exitToward(i);
    		if((c!=null)	// there is a cell 
    			&&(c.sweep_counter!=sweep_counter)	// and we haven't counted it
     			&& (c.height()>0))					// and it's not empty
    		{	ExxitPiece p = c.pieceAtIndex(0);	// top piece
    			if((p.typecode==TILE_TYPE)		// is contains a tile
    				&&(p.player==player))		// and it's our color
    			{	sweep_from(player,blob,c);
    			}
    		}
    	}
    }
    // sweep the board and count the blobs
    void sweep()
    {	sweep_counter++;
    	blob_index[FIRST_PLAYER_INDEX]=blob_index[SECOND_PLAYER_INDEX]=0;
    	for(int i=0;i<tilesInGame;i++)
    	{	ExxitPiece tile = allTiles[i];
    		ExxitCell loc = tile.location;
    		if((loc!=null) && loc.onBoard && (loc.sweep_counter!=sweep_counter))
    		{	int thisPlayer = tile.player;
    			int thisBlob = blob_index[thisPlayer]++;
    			blob_size[thisPlayer][thisBlob]=0;
    			sweep_from(thisPlayer,thisBlob,loc);
    		}
    	}
    	blobs_valid=true;
    }
    int scoreForPlayer(int pl,boolean sweep)
    {	if(!blobs_valid) { sweep(); }
    	int total=0;
    	int big = 0;
    	for(int i=0;i<blob_index[pl];i++)
    	{	int sz = blob_size[pl][i];
    		total += sz;
    		if(sz>big) { big=sz; }
    	}
    	return(total+big);
    }
    



    //
    // return true if balls[rack][ball] should be selectable, meaning
    // we can pick up a ball or drop a ball there.  movingBallColor is 
    // the ball we would drop, or -1 if we want to pick up
    //
    public void acceptPlacement()
    {
        pickedObject = null;
        droppedDest = null;
        pickedSource = null;

     }
    //
    // undo the drop, restore the moving object to moving status.
    //
    private void unDropObject()
    {
        ExxitCell dr = droppedDest;
        if(dr!=null)
        	{
        	droppedDest = null;
        	switch(pickedObject.typecode)
        	{
        	case TILE_TYPE:	
        		if(dr.onBoard) { tilesOnBoard--; }
        		//System.out.println("tiles "+tilesOnBoard);
        		blobs_valid=false;
        		break;
        	default: break;
        	}
        	dr.removeTop(pickedObject);
        	}

    }
    // 
    // undo the pick, getting back to base state for the move
    //
    private void unPickObject()
    {	ExxitPiece po = pickedObject;
    	if(po!=null)
    	{
    	ExxitCell ps = pickedSource;
    	if((po.typecode==TILE_TYPE) && pickedSource.onBoard) { tilesOnBoard++; }
    	pickedObject = null;
    	ps.addPiece(po);
      	}
      	pickedSource=null;
     }
    // 
    // drop the floating object.
    //
    private void dropObject(int dest, char col, int row)
    {
       G.Assert((pickedObject!=null)&&(droppedDest==null),"ready to drop");
       switch (dest)
        {
        default: G.Error("Not expecting dest "+dest);
        case BoardLocation:
           	droppedDest = GetExxitCell(col,row);
        	droppedDest.addPiece(pickedObject);
           	switch(pickedObject.typecode)
        	{
        	case TILE_TYPE:	
        		tilesOnBoard++; 
        		//System.out.println("tiles "+tilesOnBoard);
        		blobs_valid = false;
        		break;
        	default: break;
        	}

        	break;
        case Black_Tile_Pool:
        case White_Tile_Pool:
        	droppedDest = tiles;
        	droppedDest.addPiece(pickedObject);
        	break;
        case Black_Chip_Pool:		// back in the pool
        	droppedDest = rack[SECOND_PLAYER_INDEX];
        	droppedDest.addPiece(pickedObject);
        	break;
        case White_Chip_Pool:		// back in the pool
        	droppedDest = rack[FIRST_PLAYER_INDEX];
        	droppedDest.addPiece(pickedObject);
            break;
        }
    }   
    //
    // true if col,row is the place where something was dropped and not yet confirmed.
    // this is used to mark the one square where you can pick up a marker.
    //
    public boolean isDest(ExxitCell cell)
    {	return(droppedDest==cell);
    }
    
	//get the index in the image array corresponding to movingObjectChar 
    // or HitNoWhere if no moving object.  This is used to determine what
    // to draw when tracking the mouse.
    public int movingObjectIndex()
    {	if((pickedObject!=null)&&(droppedDest==null))
    		{ return(pickedObject.imageIndex(false));
    		}
        return (HitNoWhere);
    }
    public String movingObjectName()
    {
    	if((pickedObject!=null)&&(droppedDest==null))
    		{ return(pickedObject.file);
    		}
    	return (null);
    }
    public int movingObjectType()
    {	return((pickedObject!=null)?pickedObject.typecode:-1);
    }
    // This is a service routine for the displayer.  Return
    // a hash array of cells where the currently moving insect
    // could land.
    //
    public Hashtable movingObjectDests()
    {	Hashtable dd = new Hashtable();
    	if(movingObjectIndex()>=0)
    	{ExxitCell tempDests[]=getTempDest();
    		if(pickedSource.onBoard)
    		{ 
    		  int dests = legalDests(pickedSource,pickedObject,tempDests);
    		  for(int i=0;i<dests;i++) { dd.put(tempDests[i],tempDests[i]); }
    		}
    		else
    		{ 
    	    int nn = legalDropDests(tempDests);
    	    for(int i=0;i<nn;i++) { dd.put(tempDests[i],tempDests[i]); }
    		}
    	    returnTempDest(tempDests);
    	}
    return(dd);
    }
    

    private final ExxitPiece pickObject(ExxitCell c)
    {  	G.Assert((pickedObject==null)&&(pickedSource==null),"not ready to pick");
    	pickedSource = c;
    	pickedObject = c.removeTop();
    	return(pickedObject);
    }

	// pick something up.  Note that when the something is the board,
    // the board location really becomes empty, and we depend on unPickObject
    // to replace the original contents if the pick is cancelled.
    private void pickObject(int source, char col, int row)
    {	
    
        switch (source)
        {
        default:
            G.Error("Not expecting source " + source);

        case BoardLocation:
         	{
        	ExxitCell c = GetExxitCell(col,row);
        	ExxitPiece pp = pickObject(c);
        	if(pp.typecode==TILE_TYPE) { tilesOnBoard--; }
         	break;
         	}
        case White_Chip_Pool:
        	{
        	ExxitCell c = rack[FIRST_PLAYER_INDEX];
        	pickObject(c);
        	break;
        	}
        case Black_Chip_Pool:
        	{
        	ExxitCell c = rack[SECOND_PLAYER_INDEX];
        	pickObject(c);
         	break;
        	}
        case Black_Tile_Pool:
        case White_Tile_Pool:
        	pickObject(tiles);
        	pickedObject.setColor((source==White_Tile_Pool)?FIRST_PLAYER_INDEX:SECOND_PLAYER_INDEX);
        	break;
        }
   }
    //	
    //true if col,row is the place where something was picked up.  This is used
    // by the board display to provide a visual marker where the floating chip came from.
    //
    public boolean isSource(ExxitCell c)
    {
        return (pickedSource==c);
    }
    //
    // in the actual game, picks are optional; allowed but redundant.
    //

    private void setNextStateAfterDrop()
    {
        switch (board_state)
        {
        default:
            G.Error("Not expecting drop in state " + board_state);
        case DROP_STATE:
        case DROPTILE_STATE:
        case DROP_OR_EXCHANGE_STATE:
        	setBoardState(CONFIRM_STATE);
        	break;
        case PUZZLE_STATE:
        	acceptPlacement();
            break;
        }
    }
    private void setNextStateAfterDone()
    {
       	switch(board_state)
    	{
    	default: G.Error("Not expecting state "+board_state);
    	case DRAW_STATE:
    		setWin();
    		break;
    	case CONFIRM_DISTRIBUTE_STATE:
    	case CONFIRM_EXCHANGE_STATE:
    		confirmExchange();
    		// fall through
    	case CONFIRM_STATE:
     	case PASS_STATE:
    		setBoardState(nextPlayState(whoseTurn));
    		break;
    	case PUZZLE_STATE:
    		break;
    	}

    }    
    private void setWin()
    {	int score1 = scoreForPlayer(whoseTurn,true);
    	int score2 = scoreForPlayer(nextPlayer[whoseTurn],false);
    	setGameOver(score1>score2,score2>score1);
    }
    private void doDone()
    {	boolean gameo = false;
        acceptPlacement();
        if(board_state==CONFIRM_EXCHANGE_STATE)
        {	if(tiles.height()==0) 
        	{ 	setWin();
        		confirmExchange();
        		gameo = true;
        	}
        }
        if((board_state==PASS_STATE)||(board_state==DRAW_STATE))
        {	if(pass_ends_game) { setWin(); gameo = true; }
        	else { pass_ends_game=true; }
        }
        else 
        {
        pass_ends_game = false;
        }
        
        if (resign_planned)
        {	setGameOver(false,true);
        	confirmExchange();
        	gameo = true;
         }
        if(!gameo)
        {	setNextPlayer();
        	setNextStateAfterDone(); 
        }
    }
  
    private int nextPlayState(int who)
    {	if(prosetup && (tilesOnBoard<6))
    	{ return(DROPTILE_STATE);
    	}
    	{int nDist = nDistributionMoves(who);
    	if(nDist==0)
    	{	int nExchange = nExchangeMoves(who);
    		int nDrop = nDropMoves(who);
    		if((nDrop>0)&&(nExchange>0)) { return(DROP_OR_EXCHANGE_STATE); }
    		if(nDrop>0) { return(DROP_STATE); }
    		if(nExchange>0) { return(EXCHANGE_STATE); }
    		return(PASS_STATE);
    	}
    	return(DISTRIBUTE_STATE);
    	}
    }
    
    // used to load and unload the special "transportCell" as a stack
    private void loadCell(ExxitCell from,ExxitCell to)
    {	G.Assert(from!=to,"different cells");
    	while (from.height()>0)
    	{ ExxitPiece p = from.topPiece();
    	  if((p==null) || (p.typecode==TILE_TYPE)) { return; }
    	  from.removeTop();
    	  to.addPiece(p);
    	} 
    }
    // do a distribution move from some center in some direction
    private void doDistribution(ExxitCell c,int dir)
    {	ExxitCell nx = (ExxitCell)c.exitToward(dir);
    	G.Assert(transportCell.height()==0,"transport is free");
    	G.Assert(undoCell.height()==0,"undo cell is free");
    	loadCell(c,transportCell);
    	pickedSource = c;
    	while(transportCell.height()>0)
    	{	ExxitPiece p = transportCell.topPiece();
    	   	if(nx.height()==0) // off the board
    			{ loadCell(transportCell,nx);
    			  undoCell.push(p);
    			}
    	    else  { transportCell.removeTop(); nx.addPiece(p); undoCell.push(p); nx = (ExxitCell)nx.exitToward(dir); }
    	}
    }
    
    // construct the label for printing the game record
    public String distributionLabel()
    {	String val = pickedSource.cellName + "x";
    	boolean targetSeen=false;
    	int hgt = undoCell.height()-1;
    	for(int i=0;i<=hgt;i++)
    	{	ExxitPiece p = undoCell.pieceAtIndex(i);
    		ExxitCell loc = p.location;
    		if(!targetSeen && (loc.height()>2)) 
    		{ // target cell of the distribution is the opposite colored stack
    		  // which will be the first thing taller than 2 now
    			val += loc.cellName; targetSeen=true; 
    		}
    		else if(i==hgt)
    		{	// last cell, maybe a drop
    			ExxitPiece p1 = loc.pieceAtIndex(0);
    			if(p1.typecode==CHIP_TYPE) { val += "=" + loc.cellName; }
    		}
    	}
    	return(val);
    }
    private void undoDistribution()
    {	
    	while(undoCell.height()>0)
    	{	ExxitPiece p = undoCell.pop();
    		ExxitCell location = p.location;
    		if((location.pieceAtIndex(0).typecode==CHIP_TYPE))
    				{	// a stack dropped off the board
    				loadCell(location,transportCell);
    				}
    		else
    		{	transportCell.addPiece(location.removeTop());
    		}
    	}
    	loadCell(transportCell,pickedSource);
    }
    // do undos a little differently for the robot, because we want to 
    // minimuze the baggage rather than keep it as simple as possible
    // the Execute process records the initial height, we retrace the
    // path and load the undo stack, the carry on with the usual undo
    private void robotUndoDistribution(ExxitCell cell,int dir,int idepth)
    {	int depth = idepth;
    	G.Assert(undoCell.height()==0,"Undo cell is available");
    	G.Assert(transportCell.height()==0,"Transport cell is available");
    	ExxitCell nx = cell;
    	while(depth > 0)
    	{	nx = (ExxitCell)nx.exitToward(dir);		// step to next cell
    		if(nx.pieceAtIndex(0).typecode==TILE_TYPE)
    		{	// this an onboard spot
    			depth--;
    			ExxitPiece tp = nx.topPiece();
    			G.Assert(tp.location!=transportCell,"not on transport");
    			undoCell.push(tp);
    		}
    		else	// an off board stack
    		{	G.Assert(nx.height()==depth,"got the rest");
    			ExxitPiece tp = nx.pieceAtIndex(0); 
    			G.Assert(tp.location!=transportCell,"not on transport");
    			undoCell.push(tp); 
    			depth=0;
    		}
    	}
    	pickedSource = cell;
    	undoDistribution();
    }
    private void doExchange(ExxitCell c)
    {	// return the pieces to the reserve
    	while(c.height()>0)
    	{	ExxitPiece p = c.removeTop();
    		undoCell.push(p);
    		switch(p.typecode)
    		{
    		default: G.Error("not expecting piece type "+p.typecode);
    		case CHIP_TYPE:
    			rack[p.player].addPiece(p);
    		}
    	}
    	// add a new hex
    	ExxitPiece p = tiles.removeTop();
    	p.setColor(whoseTurn);
    	undoCell.push(p);
    	c.addPiece(p);
    	tilesOnBoard++;
    	blobs_valid = false;
    	for(int dir=0;dir<6;dir++)
    		{	ExxitCell cx = (ExxitCell)c.exitToward(dir);
    			if((tiles.height()>0) && cx.canExchange()) { doExchange(cx); }
    		}
     }
    
    // generate a label for an exchange move
    public String exchangeLabel()
    {	String val = "";
    	ExxitCell ploc = null;
     	int hgt = undoCell.height()-1;
    	for(int i=0;i<=hgt;i++)
    	{	ExxitPiece p = undoCell.pieceAtIndex(i);
    		if(p.typecode==TILE_TYPE)
    		{
    			ExxitCell loc = p.location;
    			if(loc!=ploc)
    			{
    			 val += "+" + loc.cellName;
    			 ploc=loc;
    			}
    		}
     	}
    	return(val);
    }
    private void undoExchange()
    {	ExxitCell location = null;		// the cell we're restoring
    	while(undoCell.height()>0)
    	{	ExxitPiece p = undoCell.pop();
    		switch(p.typecode)
    		{	
    		case TILE_TYPE:	// this is a tile that was placed.  Put it back in the reserve
    			location = p.location;
    			location.removeTop();
    			tilesOnBoard--;
    			blobs_valid = false;
    			tiles.addPiece(p);
    			break;
    		case CHIP_TYPE:
    			// this is a chip that was restored to the reserve, put it back on the board
    			ExxitPiece newp = p.location.removeTop();
    			G.Assert(newp==p,"same top piece");
    			location.addPiece(p);
    		}
    	}
    }

    private void confirmExchange()
    {	undoCell.doInit();
    }
    
    public boolean Execute(commonMove mm)
    {	Exxitmovespec m = (Exxitmovespec)mm;
        boolean next_rp = false;

        //System.out.println("E "+m+" for "+whoseTurn+" "+board_state);
        switch (m.op)
        {
        case MOVE_PASS:
        	setBoardState(PASS_STATE);
        	break;
        case MOVE_DONE:
         	doDone();
            break;
        case MOVE_EXCHANGE:
        	if(pickedObject!=null) { unPickObject(); }
        	G.Assert(undoCell.height()==0,"undo cell available");
        	int cells = tilesOnBoard;
        	doExchange(GetExxitCell(m.from_col,m.from_row));
        	m.undoDistributionInfo=tilesOnBoard-cells;	// used by playSounds;
        	setBoardState(CONFIRM_EXCHANGE_STATE);
        	break;
        case MOVE_MOVE:
        	if(pickedObject!=null) { unPickObject(); }
        	ExxitCell cell = GetExxitCell(m.from_col,m.from_row);
        	m.undoDistributionInfo = cell.height()-1;		// initial height for robot undo
        		// also used for playSounds
        	doDistribution(cell,m.direction);
        	setBoardState(CONFIRM_DISTRIBUTE_STATE);
        	break;
        	// fall into dropb
        case MOVE_DROPB:
            { ExxitCell c = GetExxitCell(m.from_col,m.from_row);
              if(isSource(c)) { unPickObject(); }
              else
              {
              switch(board_state)
              {
              case DISTRIBUTE_STATE:
              default: G.Error("Not expecting drop in state "+board_state);
              case DROP_OR_EXCHANGE_STATE:
              case DROP_STATE:
              case DROPTILE_STATE:
             	  { if(pickedObject==null) { pickObject(m.object,m.from_col,m.from_row); }
            	   dropObject(m.source, m.from_col, m.from_row);
            	   setNextStateAfterDrop();
            	  }
            	  break;
           	  case PUZZLE_STATE:
           		  if(pickedObject==null) { pickObject(m.object,m.from_col,m.from_row); }
           		  dropObject(m.source, m.from_col, m.from_row);
           		  setNextStateAfterDrop();
           		  break;
            }}}
            break;

        case MOVE_PICKB:
        	// come here only where there's something to pick, which must
        	switch(board_state)
        	{
            default: G.Error("Not expecting pickb in state "+board_state);
            case DISTRIBUTE_STATE:
            case DRAW_STATE:
            case CONFIRM_STATE:
            case DROPTILE_STATE:
        		if(isDest(GetExxitCell(m.from_col,m.from_row)))
        		{ unDropObject(); 
        		  ExxitCell c = pickedSource;
        		  if(c!=null) { unPickObject(); }
        		  setBoardState(nextPlayState(whoseTurn));
        		  if(c!=null) { pickObject(c); }
        		}
        		else 
        		{ // pickup for a distribution move
        		  pickObject(BoardLocation,m.from_col,m.from_row);  
        		}
        		break;
        	case PUZZLE_STATE:
        		pickObject(BoardLocation, m.from_col, m.from_row);
        		break;
        	};
        	break;
        	
        case MOVE_DROP: // drop on chip pool;
            dropObject(m.source, m.from_col, m.from_row);
            setNextStateAfterDrop();

            break;

        case MOVE_PICK:
            unDropObject();
            unPickObject();
            pickObject(m.source, m.from_col, m.from_row);
 
            break;


        case MOVE_START:
            setWhoseTurn(m.player);
            unDropObject();
            unPickObject();
            undoCell.doInit();
            transportCell.doInit();
            setBoardState(PUZZLE_STATE);
            setBoardState(nextPlayState(whoseTurn)); 
            break;

        case MOVE_RESIGN:
            next_rp = !resign_planned;
        case MOVE_RESET:
        	switch(board_state)
        	{
        	case PUZZLE_STATE: 
        		if(droppedDest!=null) { acceptPlacement(); }
        		unPickObject();
        		break;
        	case CONFIRM_DISTRIBUTE_STATE:
        		undoDistribution();
        		// fall through
           	case CONFIRM_EXCHANGE_STATE:
        		undoExchange();
        		// fall through
        	default:
       		  	unDropObject(); 
        		unPickObject(); 
        		setBoardState(nextPlayState(whoseTurn)); 
   			  break;
        	case GAMEOVER_STATE:

        		break;
        	}
            undoCell.doInit();
            transportCell.doInit();
        	break;
        case MOVE_EDIT:
            setWhoseTurn(FIRST_PLAYER_INDEX);
            setBoardState(PUZZLE_STATE);
            undoCell.doInit();
            transportCell.doInit();
            break;

        default:
            G.Error("Can't execute " + m);
        }

        resign_planned = next_rp;
        //System.out.println("Ex "+m+" for "+whoseTurn+" "+board_state);
        //System.out.println("Digest "+Digest());
        return (true);
    }

    // service routine for the viewer
    public boolean LegalToHitChips(int player)
    {
        switch (board_state)
        {
        default:
            G.Error("Not expecting state " + board_state);

        case CONFIRM_EXCHANGE_STATE:
        case DISTRIBUTE_STATE:
        case EXCHANGE_STATE:
        case PASS_STATE:
        case CONFIRM_STATE:
        case CONFIRM_DISTRIBUTE_STATE:
        case DRAW_STATE:
		case GAMEOVER_STATE:
		case DROPTILE_STATE:
			return(false);
        case DROP_STATE:
        case DROP_OR_EXCHANGE_STATE:
        	return(player==whoseTurn);
        case PUZZLE_STATE:
        	return(true);
        }
    }
    // service routine for the viewer
    public boolean LegalToHitTiles()
    {
        switch (board_state)
        {
        default:
            G.Error("Not expecting state " + board_state);
        case CONFIRM_EXCHANGE_STATE:
        case DROP_STATE:
        case EXCHANGE_STATE:
        case DROP_OR_EXCHANGE_STATE:
        case DISTRIBUTE_STATE:
		case GAMEOVER_STATE:
		case CONFIRM_DISTRIBUTE_STATE:
		case CONFIRM_STATE:
		case PASS_STATE:
		case DRAW_STATE:
			return(false);
        case PUZZLE_STATE:
        	return((pickedObject==null)||(pickedObject.typecode==TILE_TYPE));
        case DROPTILE_STATE: 
            return (true);
        }
    }
    // service routine for the viewer
    public boolean LegalToHitBoard(ExxitCell cell)
    {
        switch (board_state)
        {
		case DISTRIBUTE_STATE:
		case EXCHANGE_STATE:
		case DROP_OR_EXCHANGE_STATE:
		case DROP_STATE:
		case DROPTILE_STATE:
			ExxitCell tempDests[]=getTempDest();
			boolean val = G.arrayContains(tempDests,cell,legalDests(pickedSource,pickedObject,tempDests));
			returnTempDest(tempDests);
			return(val);

		case CONFIRM_EXCHANGE_STATE:
			for(int i=0;i<undoCell.height();i++)
			{	ExxitPiece p = undoCell.pieceAtIndex(i);
				if(p.typecode==TILE_TYPE)
				{	ExxitCell c = p.location;
					if(c==cell) { return(true); }
				}
			}
			return(false);
			
		case CONFIRM_DISTRIBUTE_STATE:
			if(cell==pickedSource) { return(true); }
			for(int i=0;i<undoCell.height();i++)
			{	ExxitPiece p = undoCell.pieceAtIndex(i);
				ExxitCell c = p.location;
				if(c==cell) { return(true); }
			}
			return(false);
		case DRAW_STATE:
		case CONFIRM_STATE:
			return(cell==droppedDest);
		case PASS_STATE:
		case GAMEOVER_STATE:
			return(false);


        default:
            G.Error("Not expecting state " + board_state);

        case PUZZLE_STATE:
        	return((pickedObject==null) 
        			? ((cell!=null)&&(cell.height()>0)) 	// something available to pick up
        			: ( (pickedObject.typecode==CHIP_TYPE)	// dropping a beetle?
        					?true								// beetles go anywhere
        					:(cell.height()==0)));				// others only on level 0
        }
    }
    

 /** assistance for the robot.  In addition to executing a move, the robot
    requires that you be able to undo the executetion.  The simplest way
    to do this is to record whatever other information is needed before
    you execute the move.  It's also convenient to automatically supply
    the "done" confirmation for any moves that are not completely self
    executing.
    */
    public void RobotExecute(Exxitmovespec m)
    {
        m.state = board_state; //record the starting state. The most reliable
        // to undo state transistions is to simple put the original state back.
 
        G.Assert(m.player == whoseTurn, "whoseturn doesn't agree");

        if (Execute(m))
        {	if(m.op==MOVE_EXCHANGE)
        	{	// save a copy of the undo stack
        		int ncells = undoCell.height();
        		ExxitPiece pc[]=new ExxitPiece[ncells];
         		for(int i=0;i<ncells;i++) { pc[i]=undoCell.pieceAtIndex(i); }
        		m.undoExchangeInfo = pc;
        		setBoardState(CONFIRM_EXCHANGE_STATE);
        		doDone();
        	} 
        	else
            if ((m.op == MOVE_DONE)||(m.op==MOVE_PASS))
            {
            }
            else if (DoneState())
            {
                doDone();
            }
            else
            {
                G.Error("Robot move should be in a done state");
            }
        }
    }
 

   //
    // un-execute a move.  The move should only be unexecuted
    // in proper sequence.  This only needs to handle the moves
    // that the robot might actually make.
    //
    public void UnExecute(Exxitmovespec m)
    {
        //System.out.println("U "+m+" for "+whoseTurn);
        switch (m.op)
        {
        case MOVE_START:
        case MOVE_PICK:
        case MOVE_DROP:
        case MOVE_RESET:
        case MOVE_EDIT: // robot never does these
   	    	
   	    default:
            G.Error("Can't unexecute " + m);
   	    	break;
   	    case MOVE_EXCHANGE:
   	    	{
   	    	ExxitPiece pc[] = m.undoExchangeInfo;
   	    	G.Assert(undoCell.height() == 0,"undo cell is available");
   	    	G.Assert(pc!=null,"undo info is available");
   	    	for(int i=0;i<pc.length;i++) { undoCell.push(pc[i]); }
   	    	undoExchange();
   	    	break;
   	    	}
        case MOVE_DROPB:
        	{
        	ExxitCell c = GetExxitCell(m.from_col,m.from_row);
        	ExxitPiece p = c.removeTop();
        	switch(p.typecode)
        	{ 
        	default: G.Error("not expecting "+p);
        	case CHIP_TYPE: 
        		rack[p.player].addPiece(p);
        		break;
        	case TILE_TYPE: 
        		tiles.addPiece(p);
        		tilesOnBoard--;
        		break;
        	}
        	break;
        	}
   	    case MOVE_MOVE:
   	    	{
   	    	ExxitCell c = GetExxitCell(m.from_col,m.from_row);
   	    	robotUndoDistribution(c,m.direction,m.undoDistributionInfo);
   	    	break;
   	    	}
   	    case MOVE_PASS:
   	    	break;
        case MOVE_DONE:
            break;
        case MOVE_RESIGN:
            break;
        }
    	droppedDest=null;
  	    pickedSource=null;
  	   	pickedObject=null;
        resign_planned = false;
        pass_ends_game=(m.state==PASS_STATE);
	    win[FIRST_PLAYER_INDEX]=win[SECOND_PLAYER_INDEX]=false;
	    setBoardState(m.state);
	    if(whoseTurn!=m.player)
	    {	moveNumber--;
	    	setWhoseTurn(m.player);
	    }
 }

static double TOP_WEIGHT = -0.1;
static double RESERVE_WEIGHT = 0.5;
// evaluator for "smartbot"
double nextEvaluation(int pl,boolean print)
{ 	// simple evaluation based on piece mobility and importance
	//double val = 0.0;
	//String msg = "";
	double score = scoreForPlayer(pl,true);
	int hh = rack[pl].height();
	int tc = countTopCells(pl);
	double aux_weight = ((tilesOnBoard+10)<tilesInGame)?1.0:((tilesInGame-tilesOnBoard)/10.0);
	double val = score+aux_weight*TOP_WEIGHT*tc+RESERVE_WEIGHT*hh;
	if(print)
		{ System.out.println(""+val+"="+score+" r="+hh*RESERVE_WEIGHT*aux_weight+" t="+tc*TOP_WEIGHT*aux_weight); 
		}
	return(val);
}
// evaluator for "dumbot"
double simpleEvaluation(int pl,boolean print)
{ 	// simple evaluation based on piece mobility and importance
 	// simple evaluation based on piece mobility and importance
	//double val = 0.0;
	//String msg = "";
	return(scoreForPlayer(pl,true));
	//if(print) { System.out.println(msg); }
	//return(val);
}
// evaluator for "bestbot"
double maxEvaluation(int pl,boolean print)
{  	// simple evaluation based on piece mobility and importance
	// simple evaluation based on piece mobility and importance
	//double val = 0.0;
	//String msg = "";
	double score = scoreForPlayer(pl,true);
	int hh = rack[pl].height();
	int tc = countTopCells(pl);
	double aux_weight = ((tilesOnBoard+10)<tilesInGame)?1.0:((tilesInGame-tilesOnBoard)/10.0);
	double val = score+aux_weight*TOP_WEIGHT*tc+RESERVE_WEIGHT*hh;
	if(print)
		{ System.out.println(""+val+"="+score+" r="+hh*RESERVE_WEIGHT*aux_weight+" t="+tc*TOP_WEIGHT*aux_weight); 
		}
	return(val);
}

public int CanDistributeToward(ExxitCell c,int dir,int who)
{	// c is known to be a cell suitable to distribute
	int oheight = c.height();
	int height = oheight;
	ExxitCell cell = (ExxitCell)c.exitToward(dir);
	boolean found = false;
	boolean foundsome = false;
	boolean offboard = false;
	while((height>1) && (cell!=null))
	{	ExxitPiece p = cell.topPiece();
		if(p==null) 
			{ offboard|=found; 
			  break; 
			}	// fell off the board
		if(cell.pieceAtIndex(0).typecode==CHIP_TYPE) { found=false; break; }	// found a chip off the board, no distribution
		if(!foundsome && (p.typecode==CHIP_TYPE))
		{	// first hex in this direction that contains a piece
			foundsome = true;
			if((p.player==nextPlayer[who])&&(cell.height()<=oheight)) { found=true; } else { break; }
		}
		height--;
		cell = (ExxitCell)cell.exitToward(dir);
	}
	if(!found) { return(NODIST); }
	if(offboard) 
		{ return(DISTRIBUTE_OFFBOARD); 
		}
	return(DISTRIBUTE_ONBOARD);
}
public int GetListOfDistributionMoves(Vector all,int who)
{	int nadded = 0;
	boolean offBoard=false;
	int initialSize = (all!=null) ? all.size() : 0;
	for(int pidx=0;pidx<allPieces.length;pidx++)
	{	ExxitPiece p = allPieces[pidx];
		if(p.player==who)
		{	ExxitCell c = p.location;
			if((c!=null) && c.onBoard && (p==c.topPiece()) && (c.pieceAtIndex(0).typecode==TILE_TYPE))
			{
				for(int dir=0;dir<6;dir++)
				{	// look in all directions
					int dist=CanDistributeToward(c,dir,who);
					switch(dist)
					{
					case NODIST:	break;
					case DISTRIBUTE_ONBOARD: 
						if(!offBoard)
							{if(all!=null) 
							{ // add a move type move
							 all.addElement(new Exxitmovespec(c.col,c.row,dir,who)); }
							 nadded++;
							}
						break;
					case DISTRIBUTE_OFFBOARD: 
						if(!offBoard) 
						{	// first offboard distribution mode
							if(nadded>0)
							{
							// throw away any onboard distribution moves we've found
							if(all!=null) { all.setSize(initialSize); }
							nadded=0;
							}
							offBoard = true;
						}
						if(all!=null) 
						{ all.addElement(new Exxitmovespec(c.col,+c.row,dir,who)); 
						}
						nadded++;
					}
				}
			}
			
		}
	}
	return(nadded);
}
// list of drop moves, given that there are no distribution moves
public int GetListOfDropMoves(Vector all,int who)
{	int nfound=0;
	if(rack[who].height()>0)
	{	for(int i=0;i<tilesInGame;i++)
		{	ExxitPiece tile = allTiles[i];
			ExxitCell c = tile.location;
			if(c.onBoard)
			{	if((c.height()==1) && (c.pieceAtIndex(0).typecode==TILE_TYPE))
				{	if(all!=null) 
					{ all.addElement(new Exxitmovespec(MOVE_DROPB,chipPoolIndex[who],c.col,c.row,who)); }
					nfound++;
				}
			}
		}
	}
	return(nfound);
}
//list of droptile moves, only used during expert setup phase
public int GetListOfDroptileMoves(Vector all,int who)
{	int nfound=0;
	if(board_state==DROPTILE_STATE)
	{
	sweep_counter++;
	for(int i=0;i<allTiles.length;i++)
	{	ExxitPiece p = allTiles[i];
		ExxitCell c = (p!=null) ? p.location : null;
		if(c!=null && c.onBoard)
		{	// a piece on top of a stack on the board
			//if(c.pieceAt(0).typecode==CHIP_TYPE)
			for(int dir=0;dir<6;dir++)
			{	ExxitCell nx = (ExxitCell)c.exitToward(dir);
				if((nx.sweep_counter!=sweep_counter) && (nx.height()==0))
				{	nx.sweep_counter=sweep_counter;
					if(all!=null) 
					{ all.addElement(new Exxitmovespec(MOVE_DROPB,tilePoolIndex[who],nx.col,nx.row,who)); 
					}
				nfound++;
				}
			}
		}
	}}
	return(nfound);
}

// list of excange moves, given that there are no distribution moves
public int GetListOfExchangeMoves(Vector all,int who)
{	int nfound=0;
	if(tiles.height()>0)
	{
	for(int i=0;i<allPieces.length;i++)
	{	ExxitPiece p = allPieces[i];
		ExxitCell c = p.location;
		
		if((c!=null) && c.onBoard && (c.topPiece()==p) && c.canExchange())
		{	// a piece on top of a stack on the board
			//if(c.pieceAt(0).typecode==CHIP_TYPE)
			if(all!=null) 
			{ all.addElement(new Exxitmovespec(MOVE_EXCHANGE,chipPoolIndex[who],c.col,c.row,who)); 
			}
			nfound++;
		}
	}}
	return(nfound);
}
public int nDistributionMoves(int who)
{	return(GetListOfDistributionMoves(null,who));
}
public int nExchangeMoves(int who)
{	return(GetListOfExchangeMoves(null,who));
}
public int nDropMoves(int who)
{	return(GetListOfDropMoves(null,who));
}
 public Vector GetListOfMoves()
 {	Vector all = new Vector();
 	if(board_state==DROPTILE_STATE)
 		{
 		GetListOfDroptileMoves(all,whoseTurn);
  		}
 	else
 	{
 	int n = GetListOfDistributionMoves(all,whoseTurn);
 	if(n==0)
 	{	// if no distribution moves
 		n += GetListOfDropMoves(all,whoseTurn);
 		n += GetListOfExchangeMoves(all,whoseTurn);
 	}
	if(all.size()==0) { all.addElement(new Exxitmovespec(whoseTurn,MOVE_PASS)); }
 	}
	return(all);
  }
 public int nLegalMoves()
 {	Vector v = GetListOfMoves();
 	return(v.size());
 }
 
 
 //
 // cell labeling is a service we provide for the viewer, to help
 // it maintain the game record.  We do this work only in the viewer,
 // so the robot speed is not affected, and overhead is pretty unimportant.
 //
 // adjust the labels on the cell based on the current contents.  Except for the
 // transition from unoccupied to occupied, labels are static.  We also depend
 // on the fact that cells change one at a time.
 // 
 public void labelCells()
 {	for(ExxitCell c = (ExxitCell)allCells; c!=null; c=(ExxitCell)c.next)
 	{	labelCell(c);
  	}
 }
 // label once cell known to have changed
 private void labelCell(char col,int row) { labelCell(GetExxitCell(col,row)); }
 
 // set the label for one cell
 private void labelCell(ExxitCell c)
 {	if(c.height()>=1)
 	{
 	if("".equals(c.cellName))
 			{ int typecode = c.pieceAtIndex(0).typecode;
 			  switch(typecode)
				{
				default: G.Error("not expecting piece type "+typecode);
				case TILE_TYPE:
					int cn = 'A';
					c.cellName = ""+(char)(cn + droppedTileCount);
					droppedTileCount++;
					break;
				case CHIP_TYPE:
					prisonerCount++;
					c.cellName = ""+ prisonerCount;
					break;
				}
 			}
 	}
 	else if(!"".equals(c.cellName))
 	{	// needs a labelectomy
 		String name =c.cellName;
 		char ct = name.charAt(0);
 		c.cellName = "";
 		switch(Character.isDigit(ct)?CHIP_TYPE:TILE_TYPE)
	    {
		  default: G.Error("Not expecting typecode "+pickedObject.typecode);
		  case CHIP_TYPE:	
		  	{ int label = G.IntToken(name);
			  while(label<prisonerCount) { label++; changeCellLabel(""+label,""+(label-1)); }
			  prisonerCount--;
		  	}
		  	break;
		  case TILE_TYPE:
			  {	int label = ct-'A';
		  	  	while(label<droppedTileCount) 
		  	  		{ label++; changeCellLabel(""+(char)('A'+label),""+(char)('A'+label-1)); 
		  	  		}
				droppedTileCount--;
			  }
			break;
		  }

 	}
 }
 // this is used to effect a pulldown of labels
 private void changeCellLabel(String label,String newlabel)
 {	for(ExxitCell c = (ExxitCell)allCells; c!=null; c=(ExxitCell)c.next)
 	{	if(label.equals(c.cellName)) { c.cellName = newlabel; }
 	}
 }

}