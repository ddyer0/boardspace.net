package exxit;

import java.awt.*;
import javax.swing.JCheckBoxMenuItem;

import online.common.*;
import online.game.*;
import online.game.sgf.sgf_names;
import online.game.sgf.sgf_node;
import online.game.sgf.sgf_property;
import online.search.SimpleRobotProtocol;

import java.util.*;

import lib.CellId;
import lib.ExtendedHashtable;
import lib.G;
import lib.HitPoint;
import lib.Random;


/**
 * 
 * Change History
 *
 * December 2006  Initial version, derived from Hive  

*/
public class ExxitGameViewer extends commonCanvas 
	implements ViewerProtocol, ExxitConstants, sgf_names
{
     /**
	 * 
	 */
	static final long serialVersionUID = 1L;
	// colors
    private Color reviewModeBackground = new Color(220,165,200);
    private Color HighlightColor = new Color(0.2f, 0.95f, 0.75f);
    private Color logrectHighlightColor = new Color(0.9f,0.9f,0.3f);
    private Color ZoomColor = new Color(0.0f,0.0f,1.0f);
    private Color rackBackGroundColor = new Color(165,155,155);
    private Color boardBackgroundColor = new Color(165,155,155);
    private Color vcrButtonColor = new Color(0.7f, 0.7f, 0.75f);
 
    private Font gameLogBoldFont=null;
    private Font gameLogFont = null;
    // images
    private static Image[] images = null; // images of black and white bugs
    private boolean redblack_tiles = true;
    private JCheckBoxMenuItem useWoodenTiles = null;

    private static Image[] textures = null;// background textures
    // private state
    private ExxitGameBoard b = null; //the board from which we are displaying
    private int CELLSIZE; 	//size of the layout cell
    private final double INITIAL_TILE_SCALE = 3.0;
    private double BOARD_TILE_SCALE = 4.0;
    private double SPRITE_TILE_SCALE = 3.5;
    private double RACK_TILE_SCALE = 2.0;
    // addRect is a service provided by commonCanvas, which supports a mode
    // to visualize the layout during development.  Look for "show rectangles"
    // in the options menu.
    //private Rectangle fullRect = addRect("fullRect"); //the whole viewer area
    //private Rectangle boardRect = addRect("boardRect"); //the actual board, normally at the left edge
    //public Rectangle stateRect = addRect("stateRect");
    //public Rectangle noChatRect = addRect("nochat");
    private Rectangle logRect = addRect("logRect"); //the game log, normally off the the right
    private Rectangle doneRect = addRect("doneRect");
    private Rectangle repRect = addRect("repRect");
    private Rectangle editRect = addRect("editRect");
    private Rectangle goalRect = addRect("goalRect");
    private Rectangle progressRect = addRect("progressRect");
    private Rectangle secondPlayerChipRect = addRect("secondPlayerChipRect");
    private Rectangle firstPlayerChipRect = addRect("firstPlayerChipRect");
    private Rectangle secondPlayerScoreRect = addRect("secondPlayerScoreRect");
    private Rectangle firstPlayerScoreRect = addRect("firstPlayerScoreRect");
    private Rectangle tilePoolRect = addRect("tilePoolRect");
    private Rectangle liftRect = addRect("liftRect");
    private boolean lifted=false;
    
	// whem moving, these remember the object we're dragging around
    //private HitPoint movingObject = null; // 

    public void preloadImages()
    {	
	    if (textures == null)
	    { // note that dfor this to work correctly, the images and masks must be the same size.  
	      // Refer to http://www.andromeda.com/people/ddyer/java/imagedemo/transparent.html
	      // this doesn't use the "-mask" suffix form of load images because some masks are
	      // shared.
	        images = load_masked_images(ImageDir, ImageFileNames); // load the main images
	        textures = load_images(ImageDir,TextureNames);
	    }
	    gameIcon = textures[LIFT_ICON_INDEX];
    }
    Color StandardMouseColors[] = MouseColors;
    Color StandardMouseDotColors[] = MouseDotColors;
    Color ExxitMouseColors[] = {Color.red,Color.black};
    Color ExxitMouseDotColors[] = {Color.black,Color.white};
    void setMouseColors()
    {	if(redblack_tiles)
    	{
        MouseColors = ExxitMouseColors;
        MouseDotColors = ExxitMouseDotColors;
    	}
    	else
    	{
    	MouseColors = StandardMouseColors;
    	MouseDotColors = StandardMouseDotColors;
    	}
    }
	/**
	 * 
	 * this is the real instance intialization, performed only once.
	 * info contains all the goodies from the environment.
	 * */
    public void init(ExtendedHashtable info,LFrameProtocol frame)
    {
        super.init(info,frame);
        use_grid = false;
        gridOption.setState(false);

        setMouseColors();
        gameLogBoldFont = G.getFont(standardPlainFont, G.Style.Bold, FontHeight+2);
        gameLogFont = G.getFont(standardPlainFont,G.Style.Plain,FontHeight);
        zoomRect = addSlider(TileSizeMessage,s.get(TileSizeMessage),ExxitId.ZoomSlider);
        zoomRect.min=1.0;
        zoomRect.max=5.0;
        zoomRect.value=2.0;
        zoomRect.barColor=ZoomColor;
        zoomRect.highlightColor = HighlightColor;

        useWoodenTiles = myFrame.addOption(s.get("use Wooden tiles"),false,deferredEvents);
       
        b = new ExxitGameBoard(info.getString(OnlineConstants.GAMETYPE, "Exxit"),(int[])info.get(exHashtable.COLORMAP));
        doInit(false);
    }

    /** 
     *  used when starting up or replaying and also when loading a new game 
     *  */
    public void doInit(boolean preserve_history)
    {
        //System.out.println(myplayer.trueName + " doinit");
        super.doInit(preserve_history);				// let commonViewer do it's things
        b.doInit(b.gametype);						// initialize the board
        if(!preserve_history)
        	{zoomRect.setValue(INITIAL_TILE_SCALE);
        	 board_center_x = board_center_y = 0.0;
        	 PerformAndTransmit(reviewOnly?"Edit":"Start P"+b.getColorMap()[0], false,replayMode.Replay);
        	}
   } 
    
    public int midGamePoint()
    {	return(40);		// exxit games are long
    }


    /**
     * calculate a metric for one of three layouts, "normal" "wide" or "tall",
     * which should normally correspond to the area devoted to the actual board.
     * these don't have to be different, but devices with very rectangular
     * aspect ratios make "wide" and "tall" important.  
     * @param width
     * @param height
     * @param wideMode
     * @param tallMode
     * @return a metric corresponding to board size
     */
    int chatCols = 20;
    public int setLocalBoundsSize(int width,int height,boolean wideMode,boolean tallMode)
    {	int chatHeight = selectChatHeight(height);
    	boolean noChat = chatHeight==0;
    	int ncols = b.ncols+(tallMode ? 14 : 20+(wideMode ? chatCols : 0)); // more cells wide to allow for the aux displays
        int nrows = b.nrows/2 + (tallMode ? 15 : (noChat&&!wideMode?12:0));
        int cellw = width / ncols;
        int cellh = (height-(wideMode?0:chatHeight)) / nrows;
        CELLSIZE = Math.max(2,Math.min(cellw, cellh)); //cell size appropriate for the aspect ration of the canvas
       return(CELLSIZE);	// board size
    }

    public void setLocalBoundsWT(int x, int y, int width, int height,boolean wideMode,boolean tallMode)
    {   
        int chatHeight = selectChatHeight(height);
        int playerWidth = 12*CELLSIZE;
        int rackWidth = tallMode ? 0 : playerWidth;
        int rackHeight = tallMode ? 7*CELLSIZE : 0;
        boolean noChat = chatHeight==0;
        int C2 = CELLSIZE/2;
        int vcrH = 3*CELLSIZE;
        int logW = CELLSIZE * 14;
        int logXX = (width-logW-CELLSIZE);
        int hcells = height/CELLSIZE;
        boolean logBottom = tallMode&&!noChat&&(hcells>75);
        int logH = wideMode|noChat|logBottom ? CELLSIZE*10 : chatHeight;

        G.SetRect(fullRect,0, 0,width, height);

        // game log.  This is generally off to the right, and it's ok if it's not
        // completely visible in all configurations.
        int boardX = C2;
        int boardY = (wideMode?0:noChat ? logH : chatHeight)+CELLSIZE*2;
        G.SetRect(boardRect,boardX,boardY,
        		width-CELLSIZE-rackWidth-(wideMode ? chatCols*CELLSIZE:0),
        		height-boardY-CELLSIZE*2-rackHeight-(logBottom?logH:0));
     
        {	
        	int stateY =G.Top(boardRect)-2*CELLSIZE;
        	int stateH = 3*CELLSIZE/2;
        	int liftW = 2*CELLSIZE-CELLSIZE/4;
        	int zoomW = CELLSIZE*7;
            G.SetRect(stateRect,boardX,stateY,G.Width(boardRect)-stateH-liftW-zoomW-CELLSIZE,stateH);
            G.SetRect(liftRect,G.Right( stateRect),stateY,
            		liftW,liftW);
            G.SetRect(zoomRect, G.Right(liftRect)+C2,stateY, zoomW,stateH);            
            G.SetRect(noChatRect, G.Right(zoomRect)+C2,stateY,stateH,stateH);
        }

     
 
   

		//this sets up the "vcr cluster" of forward and back controls.
        SetupVcrRects(C2,
            G.Bottom(boardRect) - vcrH, 
            vcrH*2,
            vcrH);

        G.SetRect(goalRect, CELLSIZE * 3,G.Bottom(boardRect),G.Width(boardRect)-CELLSIZE*3, CELLSIZE*2 );
        
        setProgressRect(progressRect,goalRect);

        int xpos = (tallMode ? x : (G.Right(boardRect)))+CELLSIZE;
        int logX = wideMode ? rackWidth+xpos : logXX;
 
        {
            commonPlayer pl0 = getPlayerOrTemp(0);
            commonPlayer pl1 = getPlayerOrTemp(1);
            Rectangle p0time = pl0.timeRect;
            Rectangle p1time = pl1.timeRect;
            Rectangle p0xtime = pl0.extraTimeRect;
            Rectangle p1xtime = pl1.extraTimeRect;
            Rectangle p0anim = pl0.animRect;
            Rectangle p1anim = pl1.animRect;
            Rectangle firstPlayerRect = pl0.nameRect;
            Rectangle secondPlayerRect = pl1.nameRect;
            Rectangle firstPlayerPicRect = pl0.picRect;
            Rectangle secondPlayerPicRect = pl1.picRect;
            
            //first player name
            G.SetRect(firstPlayerRect,
            		xpos,
            		tallMode 
            			? G.Bottom(boardRect)+CELLSIZE*3 
            			: wideMode ? G.Top(boardRect) : (logH+CELLSIZE), CELLSIZE * 6, (3 * CELLSIZE) / 2);

            int logY = logBottom?G.Bottom(firstPlayerPicRect)+CELLSIZE : y;
            G.SetRect(logRect, logX,logY ,logW, 
            		logBottom?height-logY-C2 : logH);

            // time display for first player
            G.SetRect(p0time,G.Right( firstPlayerRect),G.Top( firstPlayerRect), CELLSIZE * 3, CELLSIZE);
            G.AlignLeft(p0xtime,G.Bottom(p0time),p0time);
            
    		// first player "i'm alive" animation ball
            G.SetRect(p0anim, G.Right(p0time) ,G.Top( p0time), CELLSIZE, CELLSIZE);
            // time display for second player
            
 
           G.SetRect(firstPlayerScoreRect,G.Left( p0time),G.Top(p0time)+3*CELLSIZE, CELLSIZE*3,CELLSIZE*2);
           
           // first player portrait
           G.SetRect(firstPlayerPicRect,G.Left( firstPlayerRect), G.Bottom(firstPlayerRect), CELLSIZE * 4,CELLSIZE * 4);
           
           // "edit" rectangle, available in reviewers to switch to puzzle mode
           G.SetRect(editRect, 
        		   tallMode ? G.Right(p0anim)+CELLSIZE : G.Right(boardRect)+C2,
        		   tallMode ? G.Top(firstPlayerRect) : G.Bottom( firstPlayerPicRect)+C2,
        		    CELLSIZE*4, CELLSIZE+C2);

           //second player name
           G.AlignXY(
        		   secondPlayerRect,
        		   tallMode 
        		   		? G.Right(boardRect)-playerWidth+CELLSIZE*2 
        				: G.Left( firstPlayerRect),
        		   tallMode ? G.Top(firstPlayerRect) : G.Bottom(boardRect) - G.Height(firstPlayerRect),
        		   firstPlayerRect);

           G.AlignXY(p1time,G.Right( secondPlayerRect),G.Top( secondPlayerRect),p0time);
                    // player 2 portrait
           
           
           G.AlignLeft(p1xtime, G.Bottom(p1time),p1time);
           
           G.AlignXY(p1anim,G.Right(p1time), G.Top(p1time),p0anim);

           G.AlignXY(secondPlayerPicRect,
        		   G.Left(secondPlayerRect),
        		   tallMode ? G.Bottom(secondPlayerRect) : G.Top(secondPlayerRect) - G.Height( firstPlayerPicRect) ,
        		   firstPlayerPicRect);
 
           G.AlignXY(secondPlayerScoreRect,
        		   G.Left( p1time),
        		   tallMode ? G.Bottom(p1time)+2*CELLSIZE : G.Top(p1time)-4*CELLSIZE,
        		   firstPlayerScoreRect);

           // "done" rectangle, should always be visible, but only active when a move is complete.
           G.AlignXY(doneRect,
        		   tallMode ? G.Right(editRect)+CELLSIZE : G.Left( editRect),
        		   tallMode ? G.Top(editRect) : G.Top( secondPlayerPicRect)-G.Height(editRect)-C2,
        		   editRect);
           int chatY = wideMode ? G.Bottom(logRect)+C2 : y;
           G.SetRect(chatRect,
        		   wideMode ? logX : C2,
        		   chatY,
        		   wideMode ? width-logX-C2 : (logBottom?width:logX)-CELLSIZE,
        		   wideMode&!noChat ? height-chatY-C2 : chatHeight);
       
        G.SetRect(repRect,
        		G.Right( doneRect)+CELLSIZE,G.Top( doneRect),CELLSIZE*6 ,G.Height( doneRect));
        
		// a pool of chips for the first player at the top
        G.SetRect(firstPlayerChipRect, 
        		tallMode ? G.Right(p0anim)+CELLSIZE : G.Right(boardRect) + C2,
        		tallMode ? G.Top(firstPlayerRect)+CELLSIZE*2 : G.Bottom(editRect)+C2,
        		4*CELLSIZE, 3*CELLSIZE);
        
      
        // and for the second player at the bottom
        G.AlignXY(secondPlayerChipRect,
        		tallMode ? G.Left(secondPlayerRect)-G.Width(firstPlayerChipRect)-CELLSIZE : G.Left(firstPlayerChipRect),
        		tallMode ? G.Top(firstPlayerChipRect) : G.Top( doneRect)-G.Height(firstPlayerChipRect)-C2,
        		firstPlayerChipRect);
        
        G.SetRect(tilePoolRect,
        		tallMode ? G.Right(firstPlayerChipRect)+CELLSIZE 
        				: G.Right( firstPlayerChipRect)+CELLSIZE,
        		G.Top( firstPlayerChipRect),
        		tallMode
        			? G.Left(secondPlayerChipRect)-G.Right(firstPlayerChipRect)-CELLSIZE*2 
        			: CELLSIZE*7-CELLSIZE/4 ,
        		G.Bottom(secondPlayerChipRect)-G.Top(firstPlayerChipRect));
		
        }
              
        positionTheChat(chatRect,Color.white,Color.white);
        
        generalRefresh();
    }

    private void DrawLiftRect(Graphics gc,HitPoint highlight)
    {	
		G.centerImage(gc,textures[LIFT_ICON_INDEX],liftRect,this); 
		G.frameRect(gc,Color.black,liftRect);
    	if(G.pointInRect(highlight,liftRect))
    	{	
    		highlight.hitCode = ExxitId.LiftRect;
    		highlight.dragging=lifted=highlight.down;
    		highlight.spriteRect = liftRect;
    		highlight.spriteColor = Color.red;
    	}
    }
    
	// draw a box of spare chips. For hex it's purely for effect.
    private boolean fliptiles = false;
    private void DrawTilePool(Graphics gc, Rectangle r, HitPoint highlight)
    {
      boolean canhit = b.LegalToHitTiles() && G.pointInRect(highlight, r);
      ExxitCell c = b.tiles;
      if(gc!=null) { G.frameRect(gc, Color.black, r); }
      Random rand = new Random(4321); // consistant randoms, different for black and white 
      boolean canDrop = canhit && (b.movingObjectIndex()>=0);
      boolean hitPiece = false;
      int height = c.height();
     // if(r.height>CELLSIZE*4)	// r can be not laid out during initialization
      {for(int i=0;i<height;i++)
        {
        	ExxitPiece p = c.pieceAtIndex(i);
            int cs = CELLSIZE*7;
            int spacex = Math.max(10, G.Width(r) - CELLSIZE*2);
            int spacey = Math.max(10, G.Height(r)- CELLSIZE*2);
 
            int rx = G.Left(r)+ G.nextInt(rand,spacex);
            int ry = G.Top(r)+ G.nextInt(rand,spacey);
            int index = p.imageIndex(fliptiles)
	  			+ (redblack_tiles ? REDBLACK_OFFSET : STANDARD_OFFSET);
	  			 
            if(gc!=null) 
        	{drawImage(gc, images[index], SCALES[index], rx + CELLSIZE, ry +CELLSIZE, cs, 1.0,0.0,null,false);
        	}
        	 if(canhit && !canDrop && G.pointInRect(highlight,rx,ry,CELLSIZE*2,CELLSIZE*2))
	        		{ highlight.hitObject = b.tiles;
	        		  highlight.arrow = StockArt.UpArrow;
	        		  highlight.awidth = CELLSIZE;
	        		  highlight.spriteColor = Color.red;
	        		  highlight.hit_x = rx;
	        		  highlight.hit_y = ry;
	        		  hitPiece = true;
	         		  highlight.hitCode = (b.playerIndex(p)==(fliptiles?SECOND_PLAYER_INDEX:FIRST_PLAYER_INDEX))?ExxitId.White_Tile_Pool:ExxitId.Black_Tile_Pool;
	        		}

        }
       if(gc!=null)
    	   {G.Text(gc,true,G.Right(r)-CELLSIZE,G.Bottom(r)-CELLSIZE,CELLSIZE,CELLSIZE,Color.black,null,
    		   	""+height);
    	   }
       if(canhit && canDrop) 
       	{ highlight.hitObject = b.tiles;
       	  highlight.hitCode = ExxitId.White_Tile_Pool;
       	  highlight.arrow = StockArt.DownArrow;
       	  highlight.awidth = CELLSIZE;
       	  highlight.spriteColor = Color.red;

       	  hitPiece = true;
       	}
       else if (canhit && !canDrop)
       {	if(!hitPiece) { highlight.hitCode = ExxitId.Flip_Tiles; }
       }
      }
    }
    private void DrawScore(Graphics gc,Rectangle r,int player)
    {
    	G.setFont(gc,gameLogBoldFont);
    	G.Text(gc,true,r,0,Color.black,rackBackGroundColor,""+b.scoreForPlayer(player,true));
    	G.frameRect(gc,Color.black,r);
    }
	// draw a box of spare gobblets. Notice if any are being pointed at.  Highlight those that are.
    private void DrawChipPool(Graphics gc, ExxitState state,Rectangle r, int player,HitPoint highlight)
    {	ExxitCell thisCell= b.rack[player];
        boolean canhit = b.LegalToHitChips(player) && G.pointInRect(highlight, r);
        boolean canDrop = canhit && (b.movingObjectIndex() == player) && G.pointInRect(highlight,r);
        boolean doesHit = canDrop;
        int cellW = G.Width(r)/2;
        if(gc!=null) { G.frameRect(gc, Color.black, r); }
        {	
        	if(thisCell!=null)
        	{
	    		int left = G.Left(r)+cellW/2;
	    		int height=thisCell.height();
    		
        		for(int bug=height; bug>0;bug--)
        		{
        		ExxitPiece topCup = thisCell.pieceAtIndex(height-bug);
        		if(topCup!=null)
        		{ int rx = left+((bug<=height/2)?cellW:0);
        		  int ry = G.Top(r)+5*G.Height(r)/8+2-CELLSIZE/3*((bug<=height/2)?height/2-bug:height-bug);
        		  int index = topCup.imageIndex(false)
        		  			+ (redblack_tiles ? REDBLACK_OFFSET : STANDARD_OFFSET);
	           	  if(canhit 
	           			&& G.pointInRect(highlight,rx-cellW/2,ry-CELLSIZE/2,cellW,CELLSIZE*2)
	           			&& (height>0)
	           			)
	        		{ doesHit = true;
	        		  highlight.hit_x = rx;
	      			  highlight.hit_y = ry;
 	        		}

        		  if(gc!=null)
                	{drawImage(gc, images[index], SCALES[index],rx,  ry,
                			CELLSIZE*7, 1.0,0.0,null,false);
                	//G.frameRect(gc,Color.black,left,top,cellW,SQUARESIZE);
                	}
       		}}
        		
      		if(doesHit)
      			{highlight.hitObject = thisCell;
      			highlight.hitCode = chipPoolIndex[player];
      			highlight.arrow = canDrop ? StockArt.DownArrow : StockArt.UpArrow;
      			highlight.awidth = CELLSIZE;
      			highlight.spriteColor = Color.red;
      			}

        		//if((gc!=null)&&(hitCell==thisCell)) { G.frameRect(gc,Color.red,left-cellW/2,top-CELLSIZE/2,cellW,2*CELLSIZE); }
           	if((gc!=null) && ((thisCell==b.pickedSource)||(thisCell==b.droppedDest)))
        	{ 
            G.DrawAACircle(gc,left,G.Top(r)+CELLSIZE/2,2,Color.green,Color.yellow,true);
            }
        	}
 

        }
    }

    public void drawSprite(Graphics g,int obj,int xp,int yp)
    {
    	int idx = obj + (redblack_tiles ? REDBLACK_OFFSET : STANDARD_OFFSET);
      	 ;
       	int cellS = (int)(CELLSIZE*zoomRect.value);
       	double scale = boardRect.contains(xp,yp)?SPRITE_TILE_SCALE:RACK_TILE_SCALE;
           drawImage(g, images[idx],SCALES[idx], xp, yp,cellS*scale);
	
    }


    /* draw the deep unchangable objects, including those that might be rather expensive
     * to draw.  This background layer is used as a backdrop to the rest of the activity.
     * in our cease, we draw the board and the chips on it. 
     * */
    public void drawFixedElements(Graphics gc)
    { boolean reviewBackground = reviewMode() && !mutable_game_record;
      G.setColor(gc,reviewBackground ? reviewModeBackground : boardBackgroundColor);
      G.tileImage(gc,textures[BACKGROUND_TILE_INDEX],fullRect, this);   
          G.tileImage(gc,textures[reviewBackground 
                                 ? BROWN_FELT_INDEX
                                 : (redblack_tiles ? YELLOW_FELT_INDEX : OLD_YELLOW_FELT_INDEX)],
          		boardRect, this); 
      G.frameRect(gc,Color.black,boardRect);
 
      // draw a picture of the board. In this version we actually draw just the grid
      // to draw the cells, set gb.Drawing_Style in the board init method
      //gb.DrawGrid(gc, tbRect, use_grid, boardBackgroundColor, Color.blue, Color.blue,Color.black);

     }

    /* draw the board and the chips on it. */
     private int liftSteps = 0;
     private void drawBoardElements(Graphics gc, ExxitGameBoard gb, Rectangle tbRect,
    		 HitPoint ourTurnSelect,HitPoint anySelect)
     {	liftSteps = lifted ? Math.min(++liftSteps,12) : Math.max(--liftSteps,0);
     	int liftdiv = 40;
     	boolean dolift = (liftSteps>0);
        Rectangle oldClip = G.combinedClip(gc,tbRect);
     	setDraggingBoard(dolift);	// inhibit touch zoom while in contact
    	if(dolift && (liftSteps<12))
     		{ // this induces a very simple animation
     		repaint(20); 
     		}
     	HitPoint mo = getDragPoint();
     	boolean dragging = (anySelect!=null) && (mo!=null) ;
     	boolean draggingBoard = dragging && (mo.hitCode==ExxitId.InvisibleDragBoard);
     	setDraggingBoard(draggingBoard);
     	if(draggingBoard)
     	{	double center_x = (board_center_x*G.Width(tbRect))+(G.Left(anySelect)-G.Left(mo))*12;
     	    double center_y = (board_center_y*G.Height(tbRect))-(G.Top(anySelect)-G.Top(mo))*12;
     	    board_center_x = center_x / G.Width(tbRect);
     	    board_center_y = center_y / G.Height(tbRect);
     	    G.SetTop(mo,G.Top( anySelect));
     	    G.SetLeft(mo,G.Left(anySelect));
     	    repaint();
     	}
     	//
       	// now draw the contents of the board and anything it is pointing at
        //
         ExxitCell hitCell = null;
         Hashtable<ExxitCell,ExxitCell> dests = gb.movingObjectDests();
         ExxitCell sourceCell = gb.pickedSource; 
         ExxitCell destCell = gb.droppedDest;
         double cs = (gb.cellToX('B',2)-gb.cellToX('A',2))/zoomRect.value;
    	 Point empty = gb.emptyColumn();	// get an empty col/row to start the display
        // calculate the spanning size of the board.
         int cellSize =  (int)(cs*zoomRect.value);
         int ncols = gb.ncols;
         int liftYval =  cellSize/6+(dolift?(liftSteps*cellSize)/liftdiv : 0);
         int liftXval = dolift?(liftSteps*cellSize)/(2*liftdiv) : 0;
         double actCellSize = cellSize*BOARD_TILE_SCALE;
         //System.out.println("cs "+cs/CELLSIZE+ " "+cs+" "+CELLSIZE);
         for (int col0 = ncols-1; col0 >=0 ; col0--)
         {	int col = (col0+G.Left(empty))%ncols;
            char thiscol = (char) ('A' + col);
            int lastincol = gb.nInCol[col];
            for (int thisrow0 = lastincol-1;
              	   thisrow0 >= 0; 
              	   thisrow0--) // start at row 1 (0 is the grid) 
             { //where we draw the grid
               	int dispRow = (thisrow0+G.Top(empty))%lastincol+1 + gb.firstRowInCol[col];
                Point cp = gb.cellToXY(thiscol,dispRow,tbRect);	// calculate xy wrapped
                int xpos = G.Left(cp);
                int ypos = G.Top(cp);               
                //if(tbRect.contains(xpos,ypos))
                 {
                 ExxitCell cell = gb.GetExxitCell(thiscol,dispRow);
                 boolean isADest = dests.get(cell)!=null;
                 boolean isASource = (cell==sourceCell)||(cell==destCell);
                 ExxitPiece piece = cell.topPiece();
                 boolean hitpoint = !draggingBoard
                		 && gb.LegalToHitBoard(cell)
                		 && cell.closestPointToCell(ourTurnSelect,cellSize, xpos, ypos);
                 if(hitpoint) 
                 { hitCell = cell;
                 }

                 boolean drawhighlight = hitpoint ||
                     gb.isDest(cell) ||
                     gb.isSource(cell);
  

                 if (gc != null)
                 {
                 //G.DrawAACircle(gc,xpos,ypos,1,tiled?Color.green:Color.blue,Color.yellow,true);
                 if(piece!=null)
                 {	for(int hgt=cell.height()-1,lvl=0; lvl<=hgt; lvl++)
                 	{
                 	ExxitPiece drawPiece = cell.pieceAtIndex(lvl);
                     int pi = drawPiece.imageIndex(false) 
                     			+ (redblack_tiles ? REDBLACK_OFFSET : STANDARD_OFFSET);  
                     if (drawhighlight)
                     { // checking for pointable position
                       //  drawChip(gc, SELECTION_INDEX, xpos, ypos, actcellSize, 1.0,0.0);
                     }

                     if (pi >= 0)
                     {	double pscale[] = SCALES[pi];
                     	String id=null;
                     	
                        if(use_grid && (lvl==hgt)) 
                        { id= cell.cellName;
                        }
 
                     	// adjustScales(pscale,piece);
      
                     	drawImage(gc, images[pi], SCALES[pi], xpos+liftXval*lvl,ypos-liftYval*lvl, actCellSize, 1.0,0,id,false);

                     }
                 	}
                }
                 if(isASource)
                 {G.DrawAACircle(gc,xpos,ypos,2,Color.green,Color.yellow,true);
                 } else
                 if(isADest)
                 {G.DrawAACircle(gc,xpos,ypos,2,Color.red,Color.yellow,true);
                 }
                 }}
             }
         }

         // drawing
         if (hitCell!=null)
         {	 //if(gc!=null) { gc.drawOval(xpos-cellSize/2,ypos-cellSize/2,cellSize,cellSize); }
             ourTurnSelect.hitCode = ExxitId.BoardLocation;
             ourTurnSelect.arrow = hasMovingObject() ? StockArt.DownArrow:StockArt.UpArrow;
             ourTurnSelect.awidth = CELLSIZE;
             ourTurnSelect.spriteColor = Color.red;
         }
 
        if(startBoardDrag(anySelect,tbRect)) { anySelect.hitCode = ExxitId.InvisibleDragBoard; }
         
  		G.setClip(gc,oldClip);
     }


    //
    // draw the board and things on it.  If gc!=null then actually 
    // draw, otherwise just notice if the highlight should be on
    //
    public void redrawBoard(Graphics gc, HitPoint selectPos)
    {  ExxitGameBoard gb = b;
       boolean moving = hasMovingObject();
       HitPoint ourTurnSelect = OurMove() ? selectPos : null;
       HitPoint buttonSelect = moving?null:ourTurnSelect;
       HitPoint nonDraggingSelect = (moving && !reviewMode()) ? null : selectPos;
  
   
       ExxitState state = gb.getState();
        redrawGameLog(gc, nonDraggingSelect, logRect, Color.black, logrectHighlightColor,gameLogBoldFont,gameLogFont);
        drawBoardElements(gc, gb, boardRect, ourTurnSelect,nonDraggingSelect);
        DrawChipPool(gc, state, secondPlayerChipRect, SECOND_PLAYER_INDEX, ourTurnSelect);
        DrawChipPool(gc, state, firstPlayerChipRect, FIRST_PLAYER_INDEX, ourTurnSelect);
        DrawScore(gc,firstPlayerScoreRect,FIRST_PLAYER_INDEX);
        DrawScore(gc,secondPlayerScoreRect,SECOND_PLAYER_INDEX);
        DrawTilePool(gc, tilePoolRect,ourTurnSelect);
        zoomRect.draw(gc,nonDraggingSelect);
        DrawLiftRect(gc,nonDraggingSelect);
        DrawRepRect(gc,b.Digest(),repRect);
        //System.out.println("dig "+b.Digest());
        
        G.setFont(gc,standardBoldFont);
		if (state != ExxitState.PUZZLE_STATE)
        {
             if (G.handleRoundButton(gc, doneRect, 
            		((b.DoneState()) ? buttonSelect : null), 
            		s.get(DoneAction),
                    HighlightColor, rackBackGroundColor))
            {	// always display the done button, but only make it active in
            	// the appropriate states
            	buttonSelect.hitCode = GameId.HitDoneButton;
            }
            if (allowed_to_edit)
            {
              if (G.handleRoundButton(gc, editRect, buttonSelect, s.get(EditAction),
                                HighlightColor, rackBackGroundColor))
                    {
                    	buttonSelect.hitCode = GameId.HitEditButton;
                    }
              }
        }

		drawPlayerStuff(gc,(state==ExxitState.PUZZLE_STATE),nonDraggingSelect,HighlightColor,rackBackGroundColor);


            standardGameMessage(gc,
            		state==ExxitState.GAMEOVER_STATE?gameOverMessage():s.get(state.getDescription()),
            				state!=ExxitState.PUZZLE_STATE,
            				gb.whoseTurn,
            				stateRect);
            goalAndProgressMessage(gc,nonDraggingSelect,s.get("expand the board with your color tiles"),progressRect, goalRect);

        drawVcrGroup(nonDraggingSelect, gc, HighlightColor, vcrButtonColor);

    }
    public boolean PerformAndTransmit(commonMove m, boolean transmit,replayMode mode)
    {	// the super method in commonCanvas is where the history is actually recorded
       	if(((m.op==MOVE_DONE) 
       			&& (b.getState()==ExxitState.PASS_STATE)
       			&& OurMove() 
       			&& (mode==replayMode.Live)
       			))
       		{	// insert a "pass" before "done"
       		PerformAndTransmit(PASS); 
       		}
       	boolean val =  super.PerformAndTransmit(m,transmit,mode);
    	return(val);
    }
    /**
     * Execute a move by the other player, or as a result of local mouse activity,
     * or retrieved from the move history, or replayed form a stored game. 
     * @param mm the parameter is a commonMove so the superclass commonCanvas can
     * request execution of moves in a generic way.
     * @return true if all went well.  Normally G.Error would be called if anything went
     * seriously wrong.
     */
     public boolean Execute(commonMove mm,replayMode replay)
    {	Exxitmovespec m = (Exxitmovespec)mm;
 
    
        if(b.getState()==ExxitState.PUZZLE_STATE)
    	{   mm.setSliderNumString("--");
    		switch(m.op)
        	{
        	case MOVE_PICK: 
        		break;
        	case MOVE_PICKB: 
        		break;
    		case MOVE_DROPB:
    			//this is used in the aux_slider code 
    			//lastDropped = b.pickedObject;
    			// fall into default
				//$FALL-THROUGH$
			default:
    			mm.setLineBreak(true);
        	}
    	}
 
        handleExecute(b,m,replay);
        b.labelCells();
        switch(m.op)
        {
        case MOVE_MOVE:
        	m.shortMoveString = b.distributionLabel();
        	break;
        case MOVE_EXCHANGE:
        	m.shortMoveString = b.exchangeLabel();
        	break;
        case MOVE_DROPB:
        case MOVE_PICKB:
        	{
        	ExxitCell c = b.GetExxitCell(m.from_col,m.from_row);
        	m.shortMoveString = c.cellName;
        	}
        	break;
		default:
			break;
        }
        if(replay!=replayMode.Replay) { playSounds(m); }

         return (true);
    }
     
 void playSounds(Exxitmovespec mm)
 {
	switch(mm.op)
	{
	case MOVE_EXCHANGE:
	case MOVE_MOVE:
		int n = mm.undoDistributionInfo;
		while(n-- >0) { playASoundClip(light_drop,100); }
		//playASoundClip(heavy_drop,50);
		break;
	case MOVE_PICK:
	case MOVE_PICKB:
	case MOVE_DROPB:
		playASoundClip(light_drop,100);
		break;
	default: break;
	}
 }
/**
 * parse a move specifier on behalf of the current player.  This is called by the 
 * "game" object when it receives a move from the other player.  Note that it may
 * be called while we are in review mode, so the current state of the board should
 * not be considered.
 */
    public commonMove ParseNewMove(String st, int player)
    {
        return (new Exxitmovespec(st, player));
    }
/**
 * prepare to add nmove to the history list, but also edit the history
 * to remove redundant elements, so that indecisiveness by the user doesn't
 * result in a messy replay.
 * This may require that move be merged with an existing history move
 * and discarded.  Return null if nothing should be added to the history
 * One should be very cautious about this, only to remove real pairs that
 * result in a null move.
 * 
 */
    public commonMove EditHistory(commonMove nmove)
    {	// allow forced passes that are in the game record for appearance sake
    	return(super.EditHistory(nmove,(nmove.op==MOVE_PASS)));
    }


/**
 * the preferred mouse gesture style is to let the user "pick up" objects
 * by simply clicking on them, but we also allow him to click and drag. 
 * StartDragging is called when he has done this.
 */
    public void StartDragging(HitPoint hp)
    {
        if (hp.hitCode instanceof ExxitId) // not dragging anything yet, so maybe start
        {
       	ExxitId hitObject = (ExxitId)hp.hitCode;
		ExxitCell cell = (ExxitCell)hp.hitObject;
		ExxitPiece bug = (cell==null) ? null : cell.topPiece();
		ExxitState state = b.getState();
      		
  		switch(hitObject)
	    {
	    default: break;
	    case Black_Tile_Pool:
	    case White_Tile_Pool:
            {
            String col = hitObject.shortName;
            if(state==ExxitState.DROPTILE_STATE) { col = TILE_NAMES[b.getColorMap()[b.whoseTurn]]; }
            PerformAndTransmit("Pick "+col);
            }
            break;
	    case Flip_Tiles:
	    	//fliptiles = !fliptiles;	// local action only
	    	break;
        case InvisibleDragBoard:
        	break;
	    case LiftRect:
        case ZoomSlider:
        	break;
	    case Black_Chip_Pool:
	    	PerformAndTransmit("Pick B "+cell.row+" "+CHIP_NAMES[bug.colorIndex]);
	    	break;
	    case White_Chip_Pool:
	    	PerformAndTransmit("Pick W "+cell.row+" "+CHIP_NAMES[bug.colorIndex]);
	    	break;
	    case BoardLocation:
	    	switch(state)
	    	{
	    	case DROPTILE_STATE:
	    		PerformAndTransmit("Dropb "+TILE_NAMES[b.getColorMap()[b.whoseTurn]]+" "+cell.col+" "+cell.row);
	    		break;
	    	case DROP_STATE:
	    	case EXCHANGE_STATE:
	    	case DROP_OR_EXCHANGE_STATE:
	    		if(cell.canExchange())
	    				{
	    				PerformAndTransmit("Exchange " + cell.col+" "+cell.row+" "
	    						+CHIP_NAMES[b.getColorMap()[b.whoseTurn]]);
	    				}
	    		else 
	    			{PerformAndTransmit("Dropb "+CHIP_NAMES[b.getColorMap()[b.whoseTurn]]+" "+cell.col+" "+cell.row);
	    			}
	    		break;
	    	case CONFIRM_STATE:
	    	case PUZZLE_STATE:
	    	case DISTRIBUTE_STATE:
	    		PerformAndTransmit("Pickb "+cell.col+" "+cell.row+" "+CHIP_NAMES[bug.colorIndex]);
	    		break;
	    	case CONFIRM_DISTRIBUTE_STATE:
	    	case CONFIRM_EXCHANGE_STATE:
	    		PerformAndTransmit(RESET);
	    		break;
	    	default: throw G.Error("Not expecting state "+state);
	    	}
	    	break;
        }

         }
    }

	/** 
	 * this is called on "mouse up".  We may have been just clicking
	 * on something, or we may have just finished a click-drag-release.
	 * We're guaranteed just one mouse up, no bounces.
	 */
    public void StopDragging(HitPoint hp)
    {
        CellId id = hp.hitCode;
        if(!(id instanceof ExxitId)) {  missedOneClick = performStandardActions(hp,missedOneClick); }
    	else {
    	missedOneClick = false;
    	ExxitId hitObject = (ExxitId)hp.hitCode;
        ExxitState state = b.getState();
		ExxitCell cell = (ExxitCell)hp.hitObject;
		ExxitPiece bug = (cell==null) ? null : cell.topPiece();
       	
		switch (hitObject)
        {
        default:
        	throw G.Error("Hit Unknown object %s", hitObject);
        case ZoomSlider:
        case LiftRect:
        case InvisibleDragBoard:
        	break;
        case BoardLocation:	// we hit an occupied part of the board 
			switch(state)
			{
			default: throw G.Error("Not expecting drop on filled board in state %s",state);
			case CONFIRM_STATE:
			case CONFIRM_DISTRIBUTE_STATE:
			case CONFIRM_EXCHANGE_STATE:
				break;
				
			case DISTRIBUTE_STATE:
			case DROP_STATE:
			case DROP_OR_EXCHANGE_STATE:
			case EXCHANGE_STATE:
			case PUZZLE_STATE:
			case DROPTILE_STATE:
			{
				String name = b.movingObjectName();
				if(name!=null)
				{ ExxitCell source = b.pickedSource;
				  if((state==ExxitState.DISTRIBUTE_STATE) && (cell != source))
					{ int dir = b.findDirection(source.col,source.row,cell.col,cell.row);
					  PerformAndTransmit("Move "+name+" "+source.col+" "+source.row+" "+dir);
					}
					else
					{ PerformAndTransmit("Dropb "+name+" "+cell.col+" "+cell.row); 
					}
				}
				else if((bug!=null) && (bug.typecode==TILE_TYPE))
				{
				PerformAndTransmit( "pickb "+TILE_NAMES[bug.colorIndex]+" "+cell.col+" "+cell.row);
				}
				break;
			}}
			break;
        case Black_Tile_Pool:
        case White_Tile_Pool:
    	{
            String name = b.movingObjectName();
            if(name!=null) 
			{//if we're dragging a black chip around, drop it.
            	switch(state)
            	{
            	default: throw G.Error("can't drop on pool in state "+state);
            	case DROPTILE_STATE:
               	case PUZZLE_STATE:
                	PerformAndTransmit("Drop "+name);
            		break;
            	}
			}
        	}
    	break;
        case Black_Chip_Pool:
        case White_Chip_Pool:
    	{
        	String name = b.movingObjectName();
            if(name!=null) 
			{//if we're dragging a black chip around, drop it.
            	switch(state)
            	{
            	default: throw G.Error("can't drop on rack in state %s",state);
            	case DROP_OR_EXCHANGE_STATE:
               	case DROP_STATE:
               	case DISTRIBUTE_STATE:
               	case EXCHANGE_STATE:
               		performReset();
            		break;

               	case PUZZLE_STATE:
            		PerformAndTransmit("Drop "+name);
            		break;
            	}
			}
        	}
            break;

        case Flip_Tiles: break; // no action here
        }
    	}
//        movingObject = null;
    }



    /** this is the place where the canvas is actually repainted.  We get here
     * from the event loop, not from the normal canvas repaint request.
     */
    public void drawCanvas(Graphics offGC, boolean complete,HitPoint hp)
    {
    	b.SetDisplayParameters(zoomRect.value,1.0,board_center_x,board_center_y,30.0); // shrink a little and rotate 30 degrees
    	b.SetDisplayRectangle(boardRect);
		super.drawCanvas(offGC,complete,hp);
 
    }  
    // return what will be the init type for the game
    public String gameType() { return(b.gametype); }
    public String sgfGameType() { return(Exxit_SGF); }
    public void performHistoryInitialization(StringTokenizer his)
    {   //the initialization sequence
    	String token = his.nextToken();
        b.doInit(token);
    }



    /** return the player whose turn it really is.  This is used by the game controller
     * to key sounds and other per player turn actions.
     */
    public BoardProtocol getBoard()
    {
        return (b);
    }


    /** this is used by the game controller to supply entertainment strings to the lobby */
    public String gameProgressString()
    {	   return ((mutable_game_record ? Reviewing : ("" + History.viewMove)) + " " +
            b.scoreForPlayer(FIRST_PLAYER_INDEX,true) + " " +
            b.scoreForPlayer(SECOND_PLAYER_INDEX,false));

    }

    /** handle action events
     * 
     */
    public boolean handleDeferredEvent(Object target, String command)
    {
        boolean handled = super.handleDeferredEvent(target, command);
        if (target == useWoodenTiles)
        {	handled=true;
        	redblack_tiles = !useWoodenTiles.getState();
        	setMouseColors();
        	generalRefresh();
        }
        return (handled);
    }
    public SimpleRobotProtocol newRobotPlayer() { return(new ExxitPlay()); }


    /** replay a move specified in SGF format.  
     * this is mostly standard stuff, but the key is to recognize
     * the elements that we generated in sgf_save
     */
    public void ReplayMove(sgf_node no)
    {
        String comments = "";
        sgf_property prop = no.properties;

        while (prop != null)
        {
            String name = prop.getName();
            String value = (String) prop.getValue();

            if (setup_property.equals(name))
            {
                b.doInit(value);
             }
            else if (name.equals(comment_property))
            {
                comments += value;
            }
            else if (name.equals(game_property))
            {
                if (!(value.equalsIgnoreCase("exxit") || value.equalsIgnoreCase(Exxit_SGF)))
                {
                	throw G.Error(WrongInitError,value);
                }
            }
            else if (parseVersionCommand(name,value,2)) {}
            else if (parsePlayerCommand(name,value)) {}
            else
            {
                replayStandardProps(name,value);
            }

            prop = prop.next;
        }

        if (!"".equals(comments))
        {
            setComment(comments);
        }
    }
}
