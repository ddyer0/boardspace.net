package exxit;

import online.game.*;
import online.search.*;

import lib.*;

/** 
 * the Robot player only has to implement the basic methods to generate and evaluate moves.
 * the actual search is handled by the search driver framework.
 * 
 * TODO: make the robot exit if it has lost
 * 
 * in general, the Robot has it's own thread and operates on a copy of the board, so the
 * main UI can continue unaffected by the processing of the robot.
 * @author ddyer
 *
 */
public class ExxitPlay extends commonRobot<ExxitGameBoard> implements Runnable, ExxitConstants,
    RobotProtocol
{	boolean KILLER_HEURISTIC = false;
    boolean SAVE_TREE = false;				// debug flag for the search driver
    int DUMBOT_DEPTH = 4;
    int SMARTBOT_DEPTH = 6;
    int BESTBOT_DEPTH = 9;
    int WEAKBOT_DEPTH = 3;
    int MAX_DEPTH = DUMBOT_DEPTH;
    final double VALUE_OF_WIN = 1000.0;
    final double VALUE_OF_DRAW = -100;
    /* strategies */
    int Strategy = DUMBOT_LEVEL;
    

    /* constructor */
    public ExxitPlay()
    {
    }
    /** 
     * this is a debugging hack, use this board when the "alternate board"
     * item is selected from the extraactions menu
     */
    public BoardProtocol getBoard()
    {
    	return(board);
    }
    /** return true if the search should be depth limited at this point.
     * 
     */
    public boolean Depth_Limit(int current, int max)
    {	// for simple games where there is always one move per player per turn
    	// current>=max is good enough.  For more complex games where there could
    	// be several moves per turn, we have to keep track of the number of turn changes.
    	// it's also possible to implement quiescence search by carefully adjusting when
    	// this method returns true.
    	
        return(current>=max);
   }
/** undo the effect of a previous Make_Move.  These
 * will always be done in reverse sequence
 */
    public void Unmake_Move(commonMove m)
    {	Exxitmovespec mm = (Exxitmovespec)m;
        board.UnExecute(mm);
    }
/** make a move, saving information needed to unmake the move later.
 * 
 */
    public void Make_Move(commonMove m)
    {   Exxitmovespec mm = (Exxitmovespec)m;
        board.RobotExecute(mm);
    }
/** return true if the game is over.
 * 
 */
    public boolean Game_Over_P()
    {
        return (board.GameOver());
    }
/** return an enumeration of moves to consider at this point.  It doesn't have to be
 * the complete list, but that is the usual procedure. Moves in this list will
 * be evaluated and sorted, then used as fodder for the depth limited search
 * pruned with alpha-beta.
 */
    public CommonMoveStack  List_Of_Legal_Moves()
    {
        return(board.GetListOfMoves());
    }
    /** return a value of the current board position for the specified player.
     * this should be greatest for a winning position.  The evaluations ought
     * to be stable and greater scores should indicate some degree of progress
     * toward winning.
     * @param player
     * @return
     */
    double ScoreForPlayer(ExxitGameBoard evboard,int player,boolean print)
    {	boolean win = evboard.WinForPlayer(player);
     	// score wins as slightly better if in fewer moves
    	double val = win ? VALUE_OF_WIN+1.0/(1+board.robotDepth) : 0.0;		// points for a win, less for everything else
    	if(print && win) { System.out.println("+ win =");}

    	// basic evaluation, mobility weighted by piece importance
    	if(!win) 
    	{ switch(Strategy)
    		{
    		default: throw G.Error("not expecting "+Strategy);
    		case WEAKBOT_LEVEL:
   			case DUMBOT_LEVEL: val = evboard.simpleEvaluation(player,print);
   				break;
   			case SMARTBOT_LEVEL: val = evboard.nextEvaluation(player,print);
   				break;
   			case BESTBOT_LEVEL: val = evboard.maxEvaluation(player,print);
   				break;
    			
    		}
    	}

     	return(val);
    }
    
    /**
     * this is it! just tell me that the position is worth.  
     */
    public double Static_Evaluate_Position(commonMove m)
    {	int playerindex = m.player;
        double val0 = ScoreForPlayer(board,playerindex,false);
        double val1 = ScoreForPlayer(board,nextPlayer[playerindex],false);
        // score wins alone, to avoid the "lesser loss" syndrone, where
        // the robot commits suicide because it makes the overall position 
        // look "better" than letting the opponent win.
        if(val0>=VALUE_OF_WIN) 
        	{ if(val1>=VALUE_OF_WIN) 
        		{ return(VALUE_OF_DRAW+val0-val1); // simultaneous win is a draw
        		}
        	  return(val0); 
        	}
         else if(val1>=VALUE_OF_WIN) { return(-val1); }
        return(val0-val1);
    }
    /**
     * called as a robot debugging hack from the viewer.  Print debugging
     * information about the static analysis of the current position.
     * */
    public void StaticEval()
    {
            ExxitGameBoard evboard = new ExxitGameBoard(GameBoard.gametype,GameBoard.getColorMap());
            evboard.clone(GameBoard);
            double val0 = ScoreForPlayer(evboard,FIRST_PLAYER_INDEX,true);
            double val1 = ScoreForPlayer(evboard,SECOND_PLAYER_INDEX,true);
            System.out.println("Eval is "+ val0 +" "+val1+ " = " + (val0-val1));
    }


/** prepare the robot, but don't start making moves.  G is the game object, gboard
 * is the real game board.  The real board shouldn't be changed.  Evaluator and Strategy
 * are parameters from the applet that can be interpreted as desired.
 */
 public void InitRobot(ViewerProtocol newParam, ExtendedHashtable info, BoardProtocol gboard,  String evaluator, int stragegy)
    {
        InitRobot(info);
        GameBoard = (ExxitGameBoard) gboard;
        board = new ExxitGameBoard(GameBoard.gametype,GameBoard.getColorMap());
        Strategy = stragegy;
        switch(stragegy)
        {
        default: throw G.Error("Not expecting "+Strategy);
        case WEAKBOT_LEVEL: MAX_DEPTH = WEAKBOT_DEPTH; break;
        case DUMBOT_LEVEL:   MAX_DEPTH = DUMBOT_DEPTH; break;
        case SMARTBOT_LEVEL: MAX_DEPTH = SMARTBOT_DEPTH;break;
        case BESTBOT_LEVEL: MAX_DEPTH = BESTBOT_DEPTH; break;
        }
    }
    /** copy the game board, in preparation for a search */
    public void InitBoardFromGame()
    {
        board.clone(GameBoard);
    }
    
/** PrepareToMove is called in the thread of the main game run loop at 
 * a point where it is appropriate to start a move.  We must capture the
 * board state at this point, so that when the robot runs it will not
 * be affected by any subsequent changes in the real game board state.
 * The canonical error here was the user using the < key before the robot
 * had a chance to capture the board state.
 */
public void PrepareToMove(int playerIndex)
{
    InitBoardFromGame();

}
/** search for a move on behalf onf player p and report the result
 * to the game.  This is called in the robot process, so the normal
 * game UI is not encumbered by the search.
 */
 public commonMove DoFullMove()
    {
        Exxitmovespec move = null;

        // it's important that the robot randomize the first few moves a little bit.
        int randomn = ((RANDOMIZE&&(board.moveNumber <= 17)) ? (20 - board.moveNumber) : 0);
        board.robotDepth = 0;
        int depth = MAX_DEPTH;
        Search_Driver search_state = Setup_For_Search(depth, false);
       try
        {
 
            if (board.DoneState())
            { // avoid problems with gameover by just supplying a done
                move = new Exxitmovespec("Done", board.whoseTurn);
            }
            search_state.save_all_variations = SAVE_TREE;
            search_state.verbose=verbose;
            search_state.allow_killer = KILLER_HEURISTIC && ((Strategy!=DUMBOT_LEVEL)&&(Strategy!=WEAKBOT_LEVEL));
            search_state.save_digest=false;			// debugging only
            search_state.check_duplicate_digests = false; 	// debugging only

            if (move == null)
            {
                move = (Exxitmovespec) search_state.Find_Static_Best_Move(randomn);
            }
        }
        finally
        {
            Accumulate_Search_Summary();
            Finish_Search_In_Progress();
        }

        if (move != null)
        {
            if(G.debug() && (move.op!=MOVE_DONE)) 
            { move.showPV("exp final pv: ");
            // normal exit with a move
            search_state.Describe_Search(System.out);
            System.out.flush();
            }
            return (move);
        }

        continuous = false;
        // abnormal exit
        return (null);
    }

/* reference game 2/87/2008 depth 8 no random
 (;
 GM[28] VV[1]
 DT[]
 GN[null-null]
 SU[exxit-pro]
 P0[id "null"]
 P1[id "null"]
 ; P0[0 Start P0]
 ; P0[1 dropb wt O 15 @C]
 ; P0[2 done]
 ; P1[3 dropb bt L 13 @D]
 ; P1[4 done]
 ; P0[5 dropb wt M 13 @E]
 ; P0[6 done]
 ; P1[7 dropb bt L 14 @F]
 ; P1[8 done]
 ; P0[9 dropb w O 15 @C]
 ; P0[10 done]
 ; P1[11 dropb b N 14 @B]
 ; P1[12 done]
 ; P0[13 move w O 15 0 @CxB]
 ; P0[14 done]
 ; P1[15 dropb b M 13 @E]
 ; P1[16 done]
 ; P0[17 move w N 14 0 @BxE=1]
 ; P0[18 done]
 ; P1[19 exchange L 12 b @+1]
 ; P1[20 done]
 ; P0[21 dropb w M 14 @A]
 ; P0[22 done]
 ; P1[23 move b M 13 2 @ExA=2]
 ; P1[24 done]
 ; P0[25 exchange M 15 w @+2]
 ; P0[26 done]
 ; P1[27 dropb b L 12 @1]
 ; P1[28 done]
 ; P0[29 dropb w M 15 @2]
 ; P0[30 done]
 ; P1[31 move b M 14 2 @Ax2=3]
 ; P1[32 done]
 ; P0[33 dropb w L 13 @D]
 ; P0[34 done]
 ; P1[35 move b L 12 2 @1xD]
 ; P1[36 done]
 ; P0[37 dropb w L 14 @F]
 ; P0[38 done]
 ; P1[39 move b L 13 2 @DxF=4]
 ; P1[40 done]
 ; P0[41 exchange L 15 w @+4+3]
 ; P0[42 done]
 ; P1[43 dropb b M 13 @E]
 ; P1[44 done]
 ; P0[45 move w M 15 5 @2xE]
 ; P0[46 done]
 ; P1[47 dropb b L 13 @D]
 ; P1[48 done]
 ; P0[49 move w M 13 1 @ExD=5]
 ; P0[50 done]
 ; P1[51 move b L 13 3 @DxA=6]
 ; P1[52 done]
 ; P0[53 move w L 14 4 @FxA]
 ; P0[54 done]
 ; P1[55 exchange N 15 b @+6]
 ; P1[56 done]
 ; P0[57 exchange K 13 w @+5]
 ; P0[58 done]
 ; P1[59 dropb b L 14 @F]
 ; P1[60 done]
 ; P0[61 move w M 14 1 @AxF=7]
 ; P0[62 done]
 ; P1[63 exchange K 14 b @+7]
 ; P1[64 done]
 ; P0[65 dropb w M 15 @2]
 ; P0[66 done]
 ; P1[67 dropb b L 15 @4]
 ; P1[68 done]
 ; P0[69 move w L 14 2 @Fx4=8]
 ; P0[70 done]
 ; P1[71 move b L 15 4 @4x2]
 ; P1[72 done]
 ; P0[73 move w N 14 2 @Bx6]
 ; P0[74 done]
 ; P1[75 move b M 15 4 @2x6]
 ; P1[76 done]
 ; P0[77 move w N 15 4 @6xC=9]
 ; P0[78 done]
 ; P1[79 exchange L 16 b @+8]
 ; P1[80 done]
 ; P0[81 dropb w N 14 @B]
 ; P0[82 done]
 ; P1[83 move b O 15 0 @CxB]
 ; P1[84 done]
 ; P0[85 dropb w L 12 @1]
 ; P0[86 done]
 ; P1[87 move b M 13 0 @Ex1]
 ; P1[88 done]
 ; P0[89 dropb w L 14 @F]
 ; P0[90 done]
 ; P1[91 move b L 12 2 @1xF]
 ; P1[92 done]
 ; P0[93 dropb w N 15 @6]
 ; P0[94 done]
 ; P1[95 move b N 14 2 @Bx6=10]
 ; P1[96 done]
 ; P0[97 exchange N 16 w @+10]
 ; P0[98 done]
 ; P1[99 move b L 14 5 @FxD]
 ; P1[100 done]
 ; P0[101 move w L 13 5 @Dx1=11]
 ; P0[102 done]
 ; P1[103 dropb b N 16 @10]
 ; P1[104 done]
 ; P0[105 move w N 15 2 @6x10=12]
 ; P0[106 done]
 ; P1[107 dropb b N 15 @6]
 ; P1[108 done]
 ; P0[109 move w N 16 5 @10x6]
 ; P0[110 done]
 ; P1[111 move b N 15 5 @6xB=13]
 ; P1[112 done]
 ; P0[113 move w L 12 3 @1xB]
 ; P0[114 done]
 ; P1[115 exchange N 13 b @+13]
 ; P1[116 done]
 ; P0[117 move w N 14 0 @BxE=14]
 ; P0[118 done]
 ; P1[119 dropb b M 15 @2]
 ; P1[120 done]
 ; P0[121 move w M 13 2 @Ex2]
 ; P0[122 done]
 ; P1[123 dropb b N 16 @10]
 ; P1[124 done]
 ; P0[125 move w M 15 3 @2x10=15]
 ; P0[126 done]
 ; P1[127 exchange N 17 b @+12+15]
 ; P1[128 done]
 ; P0[129 dropb w L 14 @F]
 ; P0[130 done]
 ; P1[131 move b N 16 0 @10xF]
 ; P1[132 done]
 ; P0[133 dropb w M 16 @3]
 ; P0[134 done]
 ; P1[135 move b M 15 2 @2x3]
 ; P1[136 done]
 ; P0[137 dropb w K 13 @5]
 ; P0[138 done]
 ; P1[139 move b L 14 0 @Fx5=16]
 ; P1[140 done]
 ; P0[141 dropb w L 13 @D]
 ; P0[142 done]
 ; P1[143 move b M 14 0 @AxD]
 ; P1[144 done]
 ; P0[145 move w K 13 4 @5xD]
 ; P0[146 done]
 ; P1[147 move b L 12 3 @1xE]
 ; P1[148 done]
 ; P0[149 move w L 13 4 @DxE=17]
 ; P0[150 done]
 ; P1[151 dropb b M 14 @A]
 ; P1[152 done]
 ; P0[153 move w M 13 2 @ExA]
 ; P0[154 done]
 ; P1[155 dropb b L 13 @D]
 ; P1[156 done]
 ; P0[157 move w M 14 0 @AxD=18]
 ; P0[158 done]
 ; P1[159 dropb b M 14 @A]
 ; P1[160 done]
 ; P0[161 move w M 16 5 @3x2]
 ; P0[162 done]
 ; P1[163 move b M 14 5 @AxE=19]
 ; P1[164 done]
 ; P0[165 move w M 15 5 @2xE]
 ; P0[166 done]
 ; P1[167 exchange K 12 b @+18+16+14+11+19]
 ; P1[168 done]
 ; P0[169 move w M 13 1 @ExD=20]
 ; P0[170 done]
 ; P1[171 dropb b N 14 @B]
 ; P1[172 done]
 ; P0[173 move w L 13 3 @DxA=21]
 ; P0[174 done]
 ; P1[175 exchange O 16 b @+21]
 ; P1[176 done]
 ; P0[177 dropb w O 16 @21]
 ; P0[178 done]
 ; P1[179 move b N 15 3 @6x21]
 ; P1[180 done]
 ; P0[181 dropb w N 16 @10]
 ; P0[182 done]
 ; P1[183 move b O 16 1 @21x10]
 ; P1[184 done]
 ; P0[185 move w N 16 5 @10xB]
 ; P0[186 done]
 ; P1[187 move b M 14 4 @AxB=22]
 ; P1[188 done]
 ; P0[189 dropb w O 15 @C]
 ; P0[190 done]
 ; P1[191 move b N 14 3 @BxC=23]
 ; P1[192 done]
 ; P0[193 exchange O 14 w @+22+9+23+17]
 ; P0[194 done]
 ; P1[195 move b O 15 1 @Cx6]
 ; P1[196 done]
 ; P0[197 move w N 15 1 @6x2]
 ; P0[198 done]
 ; P1[199 move b M 16 0 @3x4]
 ; P1[200 done]
 ; P0[201 move w M 15 1 @2x4=24]
 ; P0[202 done]
 ; P1[203 exchange K 15 b @+24]
 ; P1[204 done]
 ; P0[205 exchange J 13 w @+20]
 ; P0[206 done]
 ; P1[207 dropb b M 16 @3]
 ; P1[208 done]
 ; P0[209 dropb w N 14 @B]
 ; P0[210 done]
 ; P1[211 move b N 13 2 @13xB]
 ; P1[212 done]
 ; P0[213 dropb w N 13 @13]
 ; P0[214 done]
 ; P1[215 move b N 14 5 @Bx13=25]
 ; P1[216 done]
 ; P0[217 dropb w J 13 @20]
 ; P0[218 done]
 ; P1[219 move b L 15 0 @4x20=26]
 ; P1[220 done]
 ; P0[221 move w K 14 5 @7x5]
 ; P0[222 done]
 ; P1[223 move b J 13 4 @20x5]
 ; P1[224 done]
 ; P0[225 move w K 13 4 @5xD]
 ; P0[226 done]
 ; P1[227 move b L 13 4 @DxE]
 ; P1[228 done]
 ; P0[229 dropb w L 15 @4]
 ; P0[230 done]
 ; P1[231 move b M 16 0 @3x4]
 ; P1[232 done]
 ; P0[233 dropb w K 14 @7]
 ; P0[234 done]
 ; P1[235 move b L 15 0 @4x7]
 ; P1[236 done]
 ; P0[237 dropb w L 11 @11]
 ; P0[238 done]
 ; P1[239 move b N 13 0 @13x11=27]
 ; P1[240 done]
 ; P0[241 exchange K 10 w @+27]
 ; P0[242 done]
 ; P1[243 move b M 13 5 @Ex19=28]
 ; P1[244 done]
 ; P0[245 dropb w J 12 @16]
 ; P0[246 done]
 ; P1[247 move b J 13 5 @20x16]
 ; P1[248 done]
 ; P0[249 dropb w J 13 @20]
 ; P0[250 done]
 ; P1[251 move b J 12 2 @16x20=29]
 ; P1[252 done]
 ; P0[253 exchange N 12 w @+25+28]
 ; P0[254 done]
 ; P1[255 exchange I 12 b @+26]
 ; P1[256 done]
 ; P0[257 exchange J 14 w @+29]
 ; P0[258 done]
 ; P1[259 dropb b N 12 @25]
 ; P1[260 done]
 ; P0[261 move w M 12 4 @19x25=30]
 ; P0[262 done]
 ; P1[263 exchange O 12 b @+30]
 ; P1[264 done]
 ; P0[265 dropb w O 13 @17]
 ; P0[266 done]
 ; P1[267 dropb b O 14 @22]
 ; P1[268 done]
 ; P0[269 move w O 13 2 @17x22]
 ; P0[270 done]
 ; P1[271 dropb b O 16 @21]
 ; P1[272 done]
 ; P0[273 move w O 14 2 @22x21]
 ; P0[274 done]
 ; P1[275 dropb b J 12 @16]
 ; P1[276 done]
 ; P0[277 move w J 13 5 @20x16=31]
 ; P0[278 done]
 ; P1[279 exchange J 11 b @+31]
 ; P1[280 done]
 ; P0[281 move w O 16 5 @21xC]
 ; P0[282 done]
 ; P1[283 move b O 15 5 @Cx22]
 ; P1[284 done]
 ; P0[285 move w N 12 3 @25x17=32]
 ; P0[286 done]
 ; P1[287 dropb b N 13 @13]
 ; P1[288 done]
 ; P0[289 move w L 11 3 @11x13]
 ; P0[290 done]
 ; P1[291 move b O 14 0 @22x13]
 ; P1[292 done]
 ; P0[293 move w N 13 4 @13x17=33]
 ; P0[294 done]
 ; P1[295 exchange P 14 b @+32+33]
 ; P1[296 done]
 ;
 P0[time 0:01:32 ]
 P1[time 0:01:43 ]
 )
 */

 }
