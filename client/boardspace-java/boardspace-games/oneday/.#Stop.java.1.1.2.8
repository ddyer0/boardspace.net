package oneday;
import java.awt.Graphics;
import java.awt.Rectangle;

import lib.G;
import lib.OStack;
import online.game.commonCanvas;

class StopStack extends OStack<Stop>
{
	public Stop[] newComponentArray(int n) { return(new Stop[n]); }
}
/* stops with the same values as in the database, but linked to objects for stations and lines */
class Stop
{	Station station;
	Line line;
	int ordinal;
	static StopStack stops = new StopStack();
	
	public double distanceTo(Stop next)
	{	return(station.distanceTo(next.station));
	}
	public String toString()
	{
		return("<stop "+ordinal+" on "+line+">");
	}
	public Stop(String station,String line,int num)
	{
		this(Station.getStation(station),Line.getLine(line),num);
	}
	Stop(Station c,Line l,int n)
	{	station = c; 
		line = l;
		ordinal = n;
		stops.push(this);
		line.addStop(this);
	}
	Station findStop(int n)
	{	Stop st = line.getStop(n);
		return((st==null)?null:st.station);
	}
	Station prevStop() { return(findStop(ordinal-1)); }
	Station nextStop() { return(findStop(ordinal+1)); }
	static Stop findStop(Station station,Line line)
	{
		for(int idx=stops.size()-1; idx>=0; idx--)
		{
			Stop id = stops.elementAt(idx);
			if((id.station==station)&&(id.line==line)) { return(id); }
		}
		throw G.Error("Stop "+line+" not found for "+station);
	}
	public void drawLines(Graphics g,Rectangle r,double scl)
		{
		line.drawSegments(g,r,scl);
		}
	public void drawStops(Graphics g,commonCanvas forCan,Rectangle r)
	{
		line.drawStops(g,forCan,r);
	}
	//
	// true if you can make a direct connection from a prev to this stop
	// 
	public boolean legalConnection(Stop prev)
	{
		return((prev!=this) 								// can't connect to ourself
				&& ((prev==null)||(prev.line==line)));		// can connect if we're on the same line
	}
	
	// true if you can travel from prev1 through prev2 to this station
	public boolean legalConnection(Stop prev1,Stop prev2)
	{	return( legalConnection(prev2)
				&& ((prev1==null)
						|| ((prev1.line==line)
								// this tests that the 3 stops are in the same direction
								&& (((prev1.ordinal-prev2.ordinal)*(prev2.ordinal-ordinal))>0)
								)
						));
	}
	public Stop firstStop(Stop toward)
	{	G.Assert((toward!=this) && (toward.line==line),"same line");
		return(line.getStop(ordinal-1+(toward.ordinal>ordinal?1:-1)));
	}
	// get the last stop before "toward" on this line
	public Stop lastStop(Stop toward)
	{	
		Stop prev = this;
		Stop next = this;
		while((next= prev.firstStop(toward))!=toward) 
			{ prev = next; }
		return(prev);
	}
	// prev1 and prev2 are previous stops. If both stops are also on
	// the same line as this stop, they must be in order.
	public boolean illegalConnection(Stop prev1,Stop prev2)
	{	Stop p1stop = prev1.station.getStopOnLine(line);
		Stop p2stop = prev2.station.getStopOnLine(line);
		return((p1stop!=null)
			&& (p2stop!=null)
			&& !legalConnection(p1stop,p2stop)
			&& (prev1.lastStop(prev2).station==p2stop.firstStop(p1stop).station)	// uses the same track
			);
	}
    // true if lines prev and st run concurrently
    public boolean isConcurrentLine(Stop prev)
    {
		  if(prev!=null)
		  {	Station prevNext = prev.nextStop();
		    Station prevPrev = prev.prevStop();
		    Station n = nextStop();
		    Station p = prevStop();
			  if( ((prevNext==n) || (prevNext==p) ) && ((prevPrev==n)||(prevPrev==p)))
			  {	  return(true);
			  }
			  else { return(false); }
		  }
		  return(false);
    }
	// true if we can travel from previousStop1 to here by changing at previousStop2
	public Stop legalChange(Stop previousStop1,Stop previousStop2)
	{
		if(previousStop2.legalConnection(previousStop1)
				&& !legalConnection(previousStop1)
				// this was intended to prevent station hopping in the same direction
				// but it actually prevented forward hops that should be legal.
				&& (!station.directConnection(previousStop1)
						// added this qualifier which is if the current line isn't common
						// which means we switched out even though the endpoints are directly connected
						|| (previousStop1.station.getStopOnLine(line)==null))
				)
		{
			Stop changes[]=previousStop2.station.stops;
			for(Stop changeto : changes)
			{
				if((changeto.line!=previousStop1.line) 
						&& (changeto.line==line)
						&& !changeto.illegalConnection(previousStop1,previousStop2)
						)
				{	
					return(changeto);
				}
			}
		}
		return(null);
	}
}