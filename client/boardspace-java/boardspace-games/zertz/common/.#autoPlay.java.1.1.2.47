package zertz.common;

import lib.*;
import online.common.*;
import online.game.*;
import online.search.*;


public class autoPlay extends commonRobot<GameBoard> implements Runnable, GameConstants,
    RobotProtocol
{
    /* strategies */
    final int SIMPLE_MAX = 1;
    int MaxDepth = 1;
    int Strategy = SIMPLE_MAX;
    GameBoard sequence_board = null;
    movespec planned_sequence = null;
    movespec start_of_sequence = null;
    int searchForPlayer=-1;
    /* constructor */
    public autoPlay()
    {
    }

    public BoardProtocol getBoard()
    {
        return (board);
    }

    public boolean Depth_Limit(int current, int max)
    {
    	throw G.Error("unimplemented"); /* return(current>=max);*/
  }

    public void Unmake_Move(commonMove m)
    {
    	throw G.Error("Unimplemented");
    }

    public void Make_Move(commonMove m)
    {
    	throw G.Error("unimplemented");
    }

    public boolean Game_Over_P()
    {
        return (board.GameOver());
    }

    // this method is used in the advanced robot which uses the usual search mechanism
    public CommonMoveStack  List_Of_Legal_Moves()
    { //Vector moves = new Vector();
      //getBoardMoveList(lvl,moves,(board.whoseTurn==searchForPlayer.index);
    	throw G.Error("unimplemented");
     }



    /** initialize the robot, but don't run yet */
    public void InitRobot(ViewerProtocol newParam, exHashtable info, BoardProtocol gboard,
        String evaluator, int stragegy)
    {
        InitRobot(info);
        GameBoard = (GameBoard) gboard;
        board = new GameBoard(GameBoard.gametype);
        sequence_board = new GameBoard(GameBoard.gametype);
    }

    public void StaticEval()
    {
        if (!robotRunning)
        {
            InitBoardFromGame(false);

            double w1 = board.balls_to_win(FIRST_PLAYER_INDEX);
            double w2 = board.balls_to_win(SECOND_PLAYER_INDEX);
            System.out.println("Eval is " + w1 + " - " + w2 + " = " +
                (w1 - w2));
        }
    }

    public void InitBoardFromGame(boolean prefer_board)
    {
        board.clone(GameBoard);
        sequence_board.clone(GameBoard);
    }

    public movespec ExtendSequence(movespec m)
    {
        movespec pm = m;

        while (pm.best_move != null)
        {
            movespec bm = (movespec) pm.best_move;

            if (bm.player != pm.player)
            {
                movespec splice = new movespec(pm.player, MOVE_DONE);
                splice.best_move = pm.best_move;
                pm.best_move = splice;
                pm = splice;
            }

            pm = (movespec) pm.best_move;
        }

        return (m);
    }

    public commonMove FinishMove(int playerindex, movespec m)
    {
        boolean val = false;
        planned_sequence = m;

        do
        {
            if (planned_sequence.player != sequence_board.whoseTurn)
            {
            	sequence_board.SetNextPlayer();
            }

            val = sequence_board.Execute(planned_sequence); //make the local board execute the move we plan
            planned_sequence = (movespec) planned_sequence.best_move; //remember the rest of the plan
            start_of_sequence = sequence_board.lastMove; //remember the result, as cleaned up
        }
        while (val && (planned_sequence != null) &&
                (planned_sequence.player != playerindex) &&
                (sequence_board.getState() != ZertzState.GAMEOVER_STATE));

        return (m);
    }
    public void PrepareToMove(int playerindex)
    {
        InitBoardFromGame(false);   
        searchForPlayer = playerindex;
    }
    public commonMove DoFullMove()
    {
        if (verbose > 0)
        {
            System.out.println("begin robot" );
        }
       if (planned_sequence != null)
        {
            if ((start_of_sequence != null) && (planned_sequence != null) &&
                    (start_of_sequence.Same_Move_P(GameBoard.lastMove)))
            {
                if ((game != null) && game.extraactions)
                {
                    System.out.println("Continue with " + planned_sequence);
                }

                return (FinishMove(searchForPlayer, planned_sequence));
            }

            planned_sequence = start_of_sequence = null;
        }

        movespec move = DoMoveStep(1, MaxDepth, searchForPlayer);

        if (move != null)
        {
            if(debug) { move.showPV("final pv: "); }
            FinishMove(searchForPlayer, ExtendSequence(move));
            return (move);
        }

        continuous = false;

        return (null);
    }

    public movespec DoMoveStep(int lvl, int nsteps, int player)
    {
    	CommonMoveStack  moves = new CommonMoveStack();
        boolean restricted_to_captures = getBoardMoveList(lvl, moves,board.whoseTurn==searchForPlayer);
        int n = moves.size();

        if (verbose > 1)
        {
            System.out.println("Movestep, stepn = " + nsteps + " Total of " +
                n);
        }
    
        if (n > 0)
        {
            int choice = (int) (rand.nextDouble() * n);

            switch (Strategy)
            {
 
            case SIMPLE_MAX:
            {
                movespec bestm = null;
                double bestv = -1;

                for (int i = 0; (i < n) && robotRunning; i++)
                {
                    movespec mv = (movespec) moves.elementAt(i);

                    if (verbose > 1)
                    {
                        System.out.println("Evaluating " + mv.moveString() +
                            " at step " + nsteps);
                    }

                    if (lvl == 1)
                    {
                        setProgress(i / (double) n);
                    }

                    double val = Score_for_move(mv, lvl, nsteps, searchForPlayer);

                    if (lvl == 1)
                    {
                       // mv.showPV("next val: ");
                    }

                    if (restricted_to_captures)
                    { //heres the scoop.  if we start out with a sacrifice, we only consider
                      //follpwups that are also sacrifices, until they finally end with a rebound
                      // capture.  However, if the sacrifices go nowhere and there is no final
                      // capture, we are left with a pointless sacrifice, which is always bad.
                      // in that case, ignore the whole sequence.

                        movespec l = mv;

                        while (l.best_move != null)
                        {
                            l = (movespec) l.best_move;
                        }

                        if ((l.player != player) || (l.op != MOVE_BtoB))
                        { //System.out.println("Cancel "+mv);
                            mv = null;
                        }
                    }

                    if (verbose > 1)
                    {
                        System.out.println("Value " + mv.moveString() +
                            " at step " + nsteps + " = " + val);
                    }

                    if (((mv != null) && (bestm == null)) || (val >= bestv))
                    {
                        if ((bestm == null) || (val > bestv) || (i < choice))
                        {
                            // choose among equals not quite randomly, but not consistantly       
                            bestm = mv;
                            bestv = val;
                        }

                        if (lvl == 1)
                        {
                            //bestm.showPV("next pv: ");
                        }
                    }
                }

                if (verbose > 1)
                {
                    if (bestm != null)
                    {
                        System.out.println(nsteps + " Moves: expectation is " +
                            bestv + bestm.moveString());
                    }
                    else
                    {
                        System.out.println("No Best Move!");
                    }
                }

                return (bestm);
            }

            default:
                continuous = false;
                System.out.println("no strategy #" + Strategy);
            }
        }
        else
        {
            if (verbose > 1)
            {
                System.out.println("zero moves");
            }
        }

        return (null);
    }

    /** find the actual score for a proposed move. */
    double Score_for_move(movespec m, int lvl, int nsteps,
        int player)
    {
    	ZertzState state = board.getState();

        //GameBoard bb = new GameBoard(board.gametype);
        //bb.clone(board);
        board.ExpressExecute(m);

        double val = Static_Evaluate_Position(m);
        m.local_evaluation = val;
        m.evaluation = val;

        //System.out.println(lvl+" "+nsteps + ": " + m + " = " + val);
        switch (board.getState())
        {
        default:
        // if next state is a capturing state, recurse, otherwise we are done.
        {
            movespec newm = DoMoveStep(lvl + 1, nsteps, player);

            if (newm != null)
            {
                m.evaluation = (newm.player == m.player)
                    ? newm.evaluation : (-newm.evaluation);
                m.best_move = newm;
                val = m.evaluation;
            }
        }

        break;

        case DONE_CAPTURE_STATE:
        case DONE_STATE:

            // if next state is a capturing state, recurse, otherwise we are done.
            if (Game_Over_P())
            {
                break;
            }

            ZertzState nextstate = board.Capture_Is_Possible() ? ZertzState.CAPTURE_STATE
                                                        : ZertzState.MOVE_STATE;

            if ((nextstate == ZertzState.CAPTURE_STATE)// || (state==CAPTURE_STATE)
            // || (state==CONTINUE_STATE)
            )
            {
                nsteps++;
            }

            if (nsteps > 0)
            {
            	ZertzState oldstate = board.getState();
                int oldturn = board.whoseTurn;
                board.whoseTurn = nextPlayer[oldturn];
                board.moveNumber++;
                board.setState(nextstate);

                movespec newm = DoMoveStep(lvl + 1, nsteps - 1, player);

                if (newm != null)
                {
                    m.evaluation = (newm.player == m.player)
                        ? newm.evaluation : (-newm.evaluation);
                    m.best_move = newm;
                    val = m.evaluation;
                }

                board.moveNumber--;
                board.whoseTurn = oldturn;
                board.setState(oldstate);
            }

            break;
        }

        board.ExpressUnExecute(m);

        //bb.sameboard(board);
        if (state != board.getState())
        {
        	throw G.Error("Error unwinding state for " + m);
        }

        return (val);
    }

    public double Static_Evaluate_Position(commonMove m)
    {
        double val = 0;
        int playerIndex = m.player;
        int otherplayerindex = nextPlayer[playerIndex];

       // if (board.balls[playerIndex][UNDECIDED_INDEX] > 0)
       // {
       //     return (BindAndEvaluateBest(playerIndex));
       // }
       // else if (board.balls[otherplayerindex][UNDECIDED_INDEX] > 0)
       // {
       //     return (BindAndEvaluateWorst(playerIndex, otherplayerindex));
       // }
       // else
        {
            switch (Strategy)
            {
            case SIMPLE_MAX:
            {
                double oval = board.balls_to_win(otherplayerindex);
                double mval = board.balls_to_win(playerIndex);
                val = oval - mval;
            }

            break;
			default:
				break;
            }
        }

        return (val);
    }

  //  private double BindAndEvaluateBest(int playerindex)
  //  { // the player on move got to place the undecided balls, so he'll choose
  //    // the best score
//
//        int besti = -1;
//        double bestv = 0.0;
//        int[] ball = board.balls[RESERVE_INDEX];
//
//        for (int i = 0; i < NCOLORS; i++)
//        {
//            if (ball[i] > 0)
//            {
//                ball[i]--;
//                board.balls[playerindex][i]++;
//                board.balls[playerindex][UNDECIDED_INDEX]--;
//
//                double v = EvaluatePosition(playerindex);
//
//                if ((besti < 0) || (v < bestv))
//                {
//                    besti = i;
//                    bestv = v;
//                }
//
//                ball[i]++;
//                board.balls[playerindex][i]--;
//                board.balls[playerindex][UNDECIDED_INDEX]++;
//            }
//        }
//
//       if (besti < 0)
//        { // no balls in the reserve, take from player rack.  This corresponds
//          // to the case where we would play a ball from the rack under duress, then
//          // capture it back.  Not a likley scenario
//
//            int[] pball = board.balls[playerindex];
//
//            for (int i = 0; i < NCOLORS; i++)
//            {
//                if (pball[i] > 0)
//                {
//                    board.balls[playerindex][UNDECIDED_INDEX]--;
//
//                    double v = EvaluatePosition(playerindex);
//
//                    if ((besti < 0) || (v < bestv))
//                    {
//                        besti = i;
//                        bestv = v;
//                    }
//
//                    board.balls[playerindex][UNDECIDED_INDEX]++;
//                }
//            }
//        }
//
//        //System.out.println("Worst index "+besti+" = "+bestv);
//        return (bestv);
//    }

//    private double BindAndEvaluateWorst(int playerindex, int otherplayerindex)
//    { // the player on move got to place the undecided balls, so he'll choose
//      // the best score
//
//        int besti = -1;
//        double bestv = 0.0;
//        int[] ball = board.balls[RESERVE_INDEX];
//
//        for (int i = 0; i < NCOLORS; i++)
//        {
//            if (ball[i] > 0)
//            {
//                ball[i]--;
//                board.balls[otherplayerindex][i]++;
//                board.balls[otherplayerindex][UNDECIDED_INDEX]--;
//
//                double v = EvaluatePosition(playerindex);
//
//                if ((besti < 0) || (v > bestv))
//                {
//                    besti = i;
//                    bestv = v;
//                }
//
//                ball[i]++;
//                board.balls[otherplayerindex][i]--;
//                board.balls[otherplayerindex][UNDECIDED_INDEX]++;
//            }
//        }
//
//        if (besti < 0)
//        { // no balls in the reserve, take from player rack.  This corresponds
//          // to the case where we would play a ball from the rack under duress, then
//         // allow the opponent to capture them.
//
//            int[] pball = board.balls[playerindex];
//
//            for (int i = 0; i < NCOLORS; i++)
//            {
//                if (pball[i] > 0)
//                {
//                    board.balls[otherplayerindex][UNDECIDED_INDEX]--;
//                    board.balls[otherplayerindex][i]++;
//                    board.balls[playerindex][i]--;
//
//                    double v = EvaluatePosition(playerindex);
//
//                    if ((besti < 0) || (v > bestv))
//                    {
//                        besti = i;
//                        bestv = v;
//                   }
//
//                    board.balls[otherplayerindex][UNDECIDED_INDEX]++;
//                    board.balls[otherplayerindex][i]--;
//                    board.balls[playerindex][i]++;
//                }
//            }
//        }
//
//        // System.out.println("Best index "+besti+" = "+bestv);
//        return (bestv);
//    }
//
    /** get the move list from the private board */
    public boolean getBoardMoveList(int lvl, CommonMoveStack  result,boolean forme)
    {	int who = board.whoseTurn;
        boolean restricted = false;
        ZertzState state = board.getState();

        switch (state)
        {
        case SWAP_CONFIRM_STATE:
        case DONE_STATE:
        case DONE_CAPTURE_STATE:
            result.addElement(new movespec(who, MOVE_DONE));

            break;
            
        case MOVE_OR_SWAP_STATE:
        	result.addElement(new movespec(who,MOVE_SWAP)); 

			//$FALL-THROUGH$
		case BALL_STATE:
        case MOVE_STATE:

            //place a ball in each possible position
            if ((Strategy > SIMPLE_MAX) || forme)
            {
                int cols = board.ncols;
                int rack_index = RESERVE_INDEX;
                int[] ball = board.balls[RESERVE_INDEX];
                int tot = 0;
                boolean useUndecided = false; //(board.whoseTurn==forplayer);
                restricted = (Strategy >= SIMPLE_MAX) && (lvl > 1) && forme;

                for (int j = 0; j < ball.length; j++)
                { //note, include negative counts on deployed undecided balls
                    tot += ball[j];
                }

                if (tot == 0)
                {
                    rack_index = who;
                    ball = board.balls[rack_index];
                }

                if (board.moveNumber == 1)
                { //on the first move, only do one quadrant
                    cols = (cols / 2) + 1;
                }

                for (int i = 0; i < cols; i++)
                {
                    char thiscol = (char) ('A' + i);
                    int lastcol = board.nInCol[i];

                    if (board.moveNumber == 0)
                    {
                        lastcol = (lastcol / 2) + 1;
                    }

                    for (int thisrow = 1; thisrow <= lastcol; thisrow++)
                    {	zCell c = board.getCell(thiscol,thisrow);
                    
                        if ((c.contents == Empty) &&
                                (!restricted || board.Capure_Is_Possible_From(c)))
                        {
                            if (!useUndecided)
                            {
                                for (int color = 0; color < NCOLORS; color++)
                                {
                                    if (ball[color] > 0)
                                    {
                                        result.addElement(new movespec(who,
                                                MOVE_RtoB, rack_index, color,
                                                thiscol, thisrow));
                                    }
                                }
                            }
                            else
                            { //this is part of an optimization to play balls
                              //of ambigous color, and let them flow through
                                result.addElement(new movespec(who, MOVE_RtoB,
                                        rack_index, zChip.UNDECIDED_INDEX, thiscol,
                                        thisrow));
                            }
                        }
                    }
                }
            }

            break;
            
        case SETRING_STATE:
        	if(board.rings_removed>15) 
        		{ result.addElement(new movespec(who, MOVE_DONE)); break; 
        		}
			//$FALL-THROUGH$
		case RING_STATE:
        // remove possible rings
        //place a ball in each possible position
        {
            boolean limitrings = (lvl > 2) && (Strategy <= SIMPLE_MAX);
            board.addRingMoves(result,limitrings);
        }

        break;

        case CAPTURE_STATE:
        	// start a capture
        	board.addCaptureMoves(result);
        	break;

        case CONTINUE_STATE:
        	// continue a capture in progress
        	board.addContinueCaptures(result);
            break;

         default:
            G.Error("Can't move in this state: " + state);
        }

        //for(int i=0;i<result.size();i++)
        // { movespec el = (movespec)result.elementAt(i);
        //   System.out.println(el.toString());
        // }
        return (restricted);
    }
}
