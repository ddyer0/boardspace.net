package trax;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.Rectangle;
import java.util.StringTokenizer;

import javax.swing.JCheckBoxMenuItem;

import lib.G;
import online.common.CellId;
import online.common.HitPoint;
import online.common.Slider;
import online.common.StockArt;
import online.common.exHashtable;
import online.game.BoardProtocol;
import online.game.SimpleRobotProtocol;
import online.game.ViewerProtocol;
import online.game.commonCanvas;
import online.game.commonMove;
import online.game.commonPlayer;
import online.game.replayMode;
import online.game.sgf.sgf_names;
import online.game.sgf.sgf_node;
import online.game.sgf.sgf_property;

/**
 * 
 * Change History
 *
 * Aug 2005  Inital work in progress.  
*/
public class TraxGameViewer extends commonCanvas 
	implements ViewerProtocol, TraxConstants, sgf_names
{
     /**
	 * 
	 */
	static final long serialVersionUID = 1L;
	// colors
    private Color reviewModeBackground = new Color(220,165,200);
    private Color HighlightColor = new Color(0.2f, 0.95f, 0.75f);
    private Color ZoomColor = new Color(0.0f,0.0f,1.0f);
    private Color rackBackGroundColor = new Color(140,175,146);
    private Color boardBackgroundColor = new Color(140,175,146);
    private Color highlightColor = new Color(150,195,166);
    private Color vcrButtonColor = new Color(0.7f, 0.7f, 0.75f);

    
    private static Image[] textures = null; // backgrounds
    // private state
    private TraxGameBoard b = null; //the board from which we are displaying
    private int CELLSIZE; 	//size of the layout cell

    // addRect is a service provided by commonCanvas, which supports a mode
    // to visualize the layout during development.  Look for "show rectangles"
    // in the options menu.
    //private Rectangle fullRect = addRect("fullRect"); //the whole viewer area
    //private Rectangle boardRect = addRect("boardRect"); //the actual board, normally at the left edge
    private Rectangle logRect = addRect("logRect"); //the game log, normally off the the right
    private Rectangle stateRect = addRect("stateRect"); // the state of the game
    private Rectangle firstPlayerTile = addRect("firstPlayerTile");
    private Rectangle secondPlayerTile = addRect("secondPlayerTile");
    private Rectangle doneRect = addRect("doneRect");
    private Rectangle editRect = addRect("editRect");
    private Rectangle goalRect = addRect("goalRect");
    private Rectangle progressRect = addRect("progressRect");
    private Rectangle chipPool = addRect("chipPoolRect");
    private Slider zoomRect = null;

	// private menu items
    // this is a debugging hack to print the robot's evaluation of the
    // current position.  Not important in real play.  Only avialable via secret options.
    private JCheckBoxMenuItem useClassicItem = null;
    private boolean useClassic=false; 
    private static final double INITIAL_TILE_SCALE = 3.0;
    private double board_center_x = 0.0;
    private double board_center_y = 0.0;
    private int XtoBC(int x,Rectangle brect)
    {	int CELL = boardCellSize();
		int center_x = b.left*CELL-boardCenterX(CELL,brect);
		return((((x-(G.Left(brect)+G.Width(brect)/2))-center_x)*10)/CELL);
    }
    private int YtoBC(int y,Rectangle brect)
    {	int CELL = boardCellSize();
    	int center_y = b.top*CELL-boardCenterY(CELL,brect);
    	int yinbox = (y-(G.Top(brect)+G.Height(brect)/2));
    	int ry = ((yinbox-center_y)*10)/CELL;
     	return( ry );
   }

    public BoardProtocol getBoard()   {    return (b);   }
    
    
    public void preloadImages()
    {
        if (textures == null)
        { // note that dfor this to work correctly, the images and masks must be the same size.  
          // Refer to http://www.andromeda.com/people/ddyer/java/imagedemo/transparent.html
        	TraxChip.preloadImages(this,ImageDir);
        	
            textures = load_images(ImageDir,TextureNames);
             
        }
     }
    Color TraxMouseColors[] = { Color.white,Color.red };
    Color TraxMouseDotColors[] = { Color.black,Color.white} ;
   /**
	 * 
	 * this is the real instance intialization, performed only once.
	 * info contains all the goodies from the environment.
	 * */
    public void init(exHashtable info)
    {
        super.init(info);
        MouseDotColors = TraxMouseDotColors;
        MouseColors = TraxMouseColors;
        zoomRect = addSlider("zoomRect",s.get("Tile Size"),TraxId.ZoomSlider);
        zoomRect.min=1.0;
        zoomRect.max=3.5;
        zoomRect.value=INITIAL_TILE_SCALE;
        zoomRect.barColor=ZoomColor;
        zoomRect.highlightColor = highlightColor;
        
        
        useClassicItem = myFrame.addOption("use Classic tiles",false,deferredEvents);
        
        b = new TraxGameBoard(info.getString(exHashtable.GAMETYPE, "Trax"));
        doInit(false);
   }

    /** 
     *  used when starting up or replaying and also when loading a new game 
     *  */
    public void doInit(boolean preserve_history)
    {
        //System.out.println(myplayer.trueName + " doinit");
        super.doInit(preserve_history);				// let commonViewer do it's things
        b.doInit(b.gametype);						// initialize the board
        if(!preserve_history)
    	{ PerformAndTransmit(reviewOnly?"Edit":"Start P0", false,replayMode.Live);
    	}
    }

    private int createPlayerGroup(commonPlayer pl0,int x,int y,boolean up)
    {	if(pl0!=null)
    	{
       Rectangle p0time = pl0.timeRect;
       Rectangle p0xtime = pl0.extraTimeRect;
       Rectangle p0anim = pl0.animRect;
       Rectangle firstPlayerRect = pl0.nameRect;
       Rectangle firstPlayerPicRect = pl0.picRect;
         
       G.SetRect(firstPlayerRect, x, y, CELLSIZE * 5, CELLSIZE);
        
        // first player portrait
       G.SetRect(firstPlayerPicRect,G.Left( firstPlayerRect), 
    		   up ? G.Top(firstPlayerRect)-G.Height(firstPlayerPicRect)-CELLSIZE/4 :  G.Bottom(firstPlayerRect)+CELLSIZE/4,
    				   CELLSIZE * 4, CELLSIZE * 4);
                               
        // time dispay for first player
       G.SetRect(p0time, G.Right(firstPlayerRect),G.Top(firstPlayerRect), CELLSIZE * 3,G.Height( firstPlayerRect));
        
       G.SetRect(p0xtime,G.Left( p0time),G.Bottom(p0time),G.Width( p0time),G.Height( p0time));
        
        // tfirst player "i'm alive" animation ball
       G.SetRect(p0anim, G.Right(p0time) ,G.Top( p0time), CELLSIZE, CELLSIZE);

    	}
    	return(y+CELLSIZE*6);
      }


	/**
	 * this is the main method to do layout of the board and other widgets.  I don't
	 * use swing or any other standard widget kit, or any of the standard layout managers.
	 * they just don't have the flexibility to produce the results I want.  Your milage
	 * may vary, and of course you're free to use whatever layout and drawing methods you
	 * want to.  However, I do strongly encourage making a UI that is resizable within
	 * reasonable limits, and which has the main "board" object at the left.
	 * 
	 *  The basic layout technique used here is to start with a cell which is about the size
	 *  of a board square, and lay out all the other object relative to the board or to one
	 *  another.  The rectangles don't all have to be on grid points, and don't have to
	 *  be nonoverlapping, just so long as the result generally looks good.
	 *  
	 *  When "extraactions" is available, a menu opion "show rectangles" works
	 *  with the "addRect" mechanism to help visualize the layout.
	 */ 
    public void setLocalBounds(int x, int y, int width, int height)
    {	boolean tallMode = (width*1.1<height);
    	boolean wideMode = (width>height*1.6);
        int ncols = tallMode ? 40 : 38; // more cells wide to allow for the aux displays
        int nrows = tallMode ? 38 : 25;   // likewise a little extra height
        int cellw = width / ncols;
        int chatHeight = selectChatHeight(height);
        int cellh = (height-(wideMode ? 0 : chatHeight)) / nrows;
        int logW = CELLSIZE * 10;
        int logH = CELLSIZE * 6;
        CELLSIZE = Math.min(cellw, cellh); //cell size appropriate for the aspect ration of the canvas
        int chatW1 = wideMode ? 20*CELLSIZE : width-logW-CELLSIZE;
        
        G.SetRect(fullRect,x,y, width,height);

        // game log.  This is generally off to the right, and it's ok if it's not
        // completely visible in all configurations.
        G.SetRect(stateRect,
        		CELLSIZE/2,
        		wideMode? y : y+chatHeight+CELLSIZE/2,
        		CELLSIZE*20,
        		CELLSIZE*2);
        int zoomW = CELLSIZE*4;
        int boardY = G.Bottom(stateRect);
        G.SetRect(boardRect, CELLSIZE/2, boardY, 
        		tallMode 
        			? (width - CELLSIZE)
        		    : wideMode ? width-chatW1-CELLSIZE
        			      : Math.max(CELLSIZE * 25,width-(CELLSIZE*12)),
        	    height-boardY-(tallMode?(11*CELLSIZE):(2*CELLSIZE)));
        
        G.SetRect(zoomRect,G.Right(boardRect)-zoomW,G.Top(stateRect)+CELLSIZE/2,zoomW, CELLSIZE);
        
        int chatX = wideMode ? G.Right(boardRect)+CELLSIZE/2:x+CELLSIZE/2;
        int chatW = wideMode ? chatW1 : G.Width(boardRect);
        
        int logX = tallMode ? G.Right(boardRect)-logW : 
        			wideMode ? chatX : chatX+chatW+CELLSIZE/2;
        int logY = tallMode ? G.Bottom(boardRect)+CELLSIZE/2 
        			: wideMode ? CELLSIZE/2 :  G.Top( chatRect);
        G.SetRect(logRect,
        			logX ,
        			logY,
        			logW,
        			tallMode ? height-logY-CELLSIZE/2
        				: wideMode ? logH : chatHeight);


		//this sets up the "vcr cluster" of forward and back controls.
        SetupVcrRects(G.Left(boardRect),G.Bottom(boardRect)-CELLSIZE*3,7 * CELLSIZE,CELLSIZE*3);
        int goalX = 7*CELLSIZE;
        G.SetRect(goalRect,goalX ,
        		G.Bottom( boardRect),
        		tallMode ? logX-goalX : 20 * CELLSIZE,
        		(int)(CELLSIZE * 1.5));
        
        G.SetRect(progressRect, G.Left(goalRect), G.Top(goalRect)+CELLSIZE/4,G.Width(goalRect)/2, CELLSIZE/2);

        //first player name
        G.SetRect(firstPlayerTile,
        		tallMode ? G.Left(boardRect) 
        				:  G.Right( boardRect)+CELLSIZE/4+(wideMode?CELLSIZE*8:0),
        		tallMode ? G.Bottom(goalRect)+CELLSIZE/2 : G.Bottom( logRect)+CELLSIZE/2,
        		(3 * CELLSIZE) / 2,
        		(3 * CELLSIZE) / 2);
         
        int tl = G.Right(firstPlayerTile)+CELLSIZE/4;
        int mid = createPlayerGroup(getPlayerOrTemp(0),tl,G.Top(firstPlayerTile),false);
        
        G.SetRect(secondPlayerTile,
        		tallMode ? G.Left(boardRect)+CELLSIZE*12 : G.Left(firstPlayerTile),
        		tallMode ? G.Top(firstPlayerTile) 
        				: wideMode ? G.Top(firstPlayerTile)+CELLSIZE*6 : G.Bottom(boardRect)-G.Height(firstPlayerTile),
        		G.Width(firstPlayerTile),
        		G.Height( firstPlayerTile));
      
        createPlayerGroup(getPlayerOrTemp(1),
        		G.Right(secondPlayerTile)+CELLSIZE/4,G.Top(secondPlayerTile),!(tallMode||wideMode));

        int buttonW = CELLSIZE*5;
        int buttonX = tallMode ? logX-buttonW-CELLSIZE*2 : G.Right(boardRect)+CELLSIZE/2;
        int buttonY = tallMode ? G.Top(firstPlayerTile) : 
        		wideMode ? G.Bottom(logRect)+CELLSIZE/2 : mid+CELLSIZE/4;
        int buttonH = 4*CELLSIZE/2;
        Rectangle topRect = tallMode ? doneRect : editRect;
        Rectangle bottomRect = tallMode ? editRect : doneRect;
        
        // "edit" rectangle, available in reviewers to switch to puzzle mode
        G.SetRect(topRect, buttonX, buttonY,buttonW,buttonH);
            
        // a pool of chips for the first player at the top
        G.SetRect(chipPool,buttonX,G.Bottom( topRect)+CELLSIZE,5*CELLSIZE, 5*CELLSIZE/2);
            
            // "done" rectangle, should always be visible, but only active when a move is complete.
        G.SetRect(bottomRect,buttonX,G.Bottom(chipPool)+CELLSIZE,buttonW,buttonH);

        int chatY = wideMode ? G.Top(secondPlayerTile)+CELLSIZE*6 : y+CELLSIZE/2;
        int chatH = wideMode ? height-chatY-CELLSIZE/2 : chatHeight;
        G.SetRect(chatRect,chatX,
        		chatY ,
        		chatW-CELLSIZE/2, 
        		chatH);

        
        positionTheChat(chatRect,Color.white,Color.white);

        generalRefresh();
    }
  
    TraxChip [] imageGroup(int alt_image)
    {	switch(alt_image)
    	{ 
    	default: return(useClassic ? TraxChip.classicChips : TraxChip.modernChips);
    	case FIRST_PLAYER_INDEX: return(useClassic ? TraxChip.classicWhiteChipLines : TraxChip.modernWhiteChipLines);
    	case SECOND_PLAYER_INDEX: return(useClassic ? TraxChip.classicBlackChipLines : TraxChip.modernRedChipLines);
    	}
    }
	// draw a graphic at x,y.  The images are loaded and composisted
    // at init time, so they're always completely ready to draw.
    private void drawChip(Graphics gc, int idx, int x, int y, int boxw, double scale,int alt_image)
    {	TraxChip chip = imageGroup(alt_image)[idx];
    	Image im = chip.image;
    	double []lscale = chip.scale ;
    	drawImage(gc,im,lscale,x,y,boxw*scale);
    }


	// draw a box of spare chips. For trax it's purely for effect.
    private void DrawChipPool(Graphics gc, Rectangle r,  HitPoint highlight)
    {
       int cw = G.Width(r)/3;
       int ch = G.Height(r)/2;
       boolean inRect = G.pointInRect(highlight, r);
       boolean canhit = inRect && b.LegalToHitChips(OurMove());

        if(gc!=null) { G.frameRect(gc, Color.black, r); }
    	for(int col=0; col<3;col++)
        {
        	for(int row=0;row<2;row++)
        	{	int rx0 = G.Left(r)+cw*col;
        		int rx = rx0+(cw-CELLSIZE)/2+CELLSIZE/2;
        		int ry0 = G.Top(r)+ch*row;
        		int ry = ry0+(ch-CELLSIZE)/2+CELLSIZE/2;
        		int ccode = row+col*2;
        		boolean ishit = canhit && G.pointInRect(G.Left(highlight),G.Top(highlight),rx0,ry0,cw,ch);
        		if(ishit)
        		{	highlight.hitCode = MATCHTILES[ccode];
        		}
        		if(gc!=null)
        		{
        		if(ishit)
        		{  
        			G.fillRect(gc,HighlightColor,rx0,ry0,cw,ch);
        		}
        		drawChip(gc,ccode,rx,ry,CELLSIZE,1.0,-1);
        		}
        		//gc.setColor(Color.red);
        		//gc.drawLine(r.x+cw*col,r.y,r.x+cw*col,r.y+r.height);
        	}
       		//gc.drawLine(r.x,r.y+ch,r.x+r.width,r.y+ch);
       	 }
    }

    /**
     * translate the mouse coordinate x,y into a size-independant representation
     * presumably based on the cell grid.  This is used to transmit our mouse
     * position to the other players and spectators, so it will be displayed
     * at approximately the same visual spot on their screen.  
     *  */
    public Point getTraxBoardCoords(int x, int y)
    {	// implement a dual coordinate system, for "in board" and "out of board"
    	if(G.pointInRect(x,y,boardRect))
    	{ 	return(new Point(1000+XtoBC(x,boardRect),1000+YtoBC(y,boardRect)));
    	}
    	return (new Point((x * 10) / CELLSIZE, (y * 10) / CELLSIZE));
    }
    private int BCtoX(int x,Rectangle brect)
    {	int CELL = boardCellSize();
		int center_x = b.left*CELL-boardCenterX(CELL,brect);
		return((x*CELL)/10+center_x+G.Left(brect)+G.Width(brect)/2);
    }
    private int BCtoY(int y,Rectangle brect)
    {	int CELL = boardCellSize();
		int center_y =  b.top*CELL-boardCenterY(CELL,brect);
		int ry = (y*CELL)/10+center_y+G.Top(brect)+G.Height(brect)/2;
		return(ry);
    }
    public String encodeScreenZone(int x, int y,Point p)
    {	Point pt = getTraxBoardCoords(x,y);
    	G.SetLeft(p, G.Left(pt));
    	G.SetTop(p, G.Top(pt));
    	return("on");
    }
	public Point decodeTraxCellPosition(int x,int y,double cellsize)
	{	
        int xp = (x>800) 
		? BCtoX(x-1000,boardRect)
		:(int) (((x + 0.5) * cellsize) / 10);	// invert the transform of getBoardCoords
		int yp = (y>800)
			? BCtoY(y-1000,boardRect)
					: (int) (((y + 0.5) * cellsize) / 10);
		return(new Point(xp,yp));
	}
	public Point decodeScreenZone(String zone,int x,int y)
	{
		return(decodeTraxCellPosition(x,y,CELLSIZE));
	}

    public void drawSprite(Graphics g,int obj,int xp,int yp)
    {
       	int scale = G.pointInRect(xp,yp,boardRect) ? boardTileSize() : CELLSIZE;
        drawChip(g, obj, xp+CELLSIZE/2, yp-CELLSIZE/2, scale, 1.0,-1);

    }

 
    /* draw the deep unchangable objects, including those that might be rather expensive
     * to draw.  This background layer is used as a backdrop to the rest of the activity.
     * in our cease, we draw the board and the chips on it. 
     * */
    public void drawFixedElements(Graphics gc)
    {boolean review = reviewMode() && !mutable_game_record;
      G.setColor(gc,review ? reviewModeBackground : boardBackgroundColor);
      G.tileImage(gc,textures[BACKGROUND_TILE_INDEX], fullRect, this);   
          G.tileImage(gc,textures[review ? BROWN_FELT_INDEX:GREEN_FELT_INDEX],
          		boardRect, this); 
      G.frameRect(gc,Color.black,boardRect);
       
     }
    int boardCellSize() { return((int)(CELLSIZE*zoomRect.value)); }
    int boardTileSize() { return((int)(boardCellSize()*0.9)); }
    int boardCenterX(int CELL,Rectangle brect) { return((b.ncols*CELL)/2-(int)(board_center_x*G.Width(brect))); }
    int boardCenterY(int CELL,Rectangle brect) { return((b.nrows*CELL)/2-(int)(board_center_y*G.Height(brect))); }
   
    /* draw the board and the chips on it. */
    private void drawBoardElements(Graphics gc, TraxGameBoard gb, Rectangle brect, HitPoint ourTurnSelect,HitPoint alwaysSelect)
    {	TraxState state = gb.getState();
    	boolean showdots = (state == TraxState.PUZZLE_STATE);
    	int winner = b.winner();
    	boolean showwins = (winner>=0);
 
    	Rectangle sh= G.combinedClip(gc,G.Left(brect),G.Top(brect),G.Width(brect),G.Height(brect));
        //
        // now draw the contents of the board and anything it is pointing at
        //
    HitPoint mo = dragPoint;
    boolean draggingBoard = (alwaysSelect!=null) && (mo!=null) 
		&& ((mo.hitCode==TraxId.InvisibleDragBoard)||(mo.hitCode==TraxId.DragBoard));
   	if(draggingBoard)
	{	double center_x = (board_center_x*G.Width(brect))+(G.Left(alwaysSelect)-G.Left(mo));
	    double center_y = (board_center_y*G.Height(brect))+(G.Top(alwaysSelect)-G.Top(mo));
	    board_center_x = center_x / G.Width(brect);
	    board_center_y = center_y / G.Height(brect);
	    G.SetTop(mo, G.Top(alwaysSelect));
	    G.SetLeft(mo,G.Left(alwaysSelect));
	    repaint(20);
	}
    if(gb.tilesOnBoard==0)
    	{	if(ourTurnSelect!=null)
    		{	if(G.pointInRect(ourTurnSelect,brect))
    				{ourTurnSelect.hitCode = TraxId.EmptyBoard;
    				ourTurnSelect.col = '@';
    				ourTurnSelect.row = 0;
    				}
    		}
    	}
    	else
    	{
    	int CELL = boardCellSize();
    	int center_x = boardCenterX(CELL,brect);
    	int center_y = boardCenterY(CELL,brect);
    	int firstcol = gb.left-1;
    	int firstrow = gb.top-1;
    	int CHIPSIZE = boardTileSize();
    	boolean somehit=false;
    	boolean anyhit = false;
       	if(ourTurnSelect!=null) { ourTurnSelect.awidth = CHIPSIZE;}

     	//
    	// note we draw from lower-right to upper-left so the shadows will
    	// not be cast over the next piece drawn.
    	//
   		for(int yindex=gb.bottom; yindex>=firstrow; yindex--)
   		{	int row = yindex-firstrow;
			int y = yindex*CELL-center_y + G.Top(brect)+G.Height(brect)/2;
			int c_y = y-CELL/2;
			for(int xindex=gb.right; xindex>=firstcol; xindex--)
    		{	char col = (char)(xindex-firstcol+'@');
     			int x = xindex*CELL-center_x + G.Left(brect)+G.Width(brect)/2;
    			int c_x = x-CELL/2;
    			char cell = gb.GetBoardPos(col,row);
    			boolean isEmpty = cell==Empty;
    			boolean canhit =  gb.LegalToHitBoard(col,row);
    			boolean hit = canhit && G.pointInRect(ourTurnSelect,c_x,c_y,CELL,CELL);
    			boolean bisdest = gb.isDest(col,row);
    			boolean isDest = !isEmpty && !hit && bisdest;
    			if(use_grid && (gc!=null))
    			{if((xindex==firstcol) && (row>0))
    			{	G.Text(gc,true,x-CELL/4,y-CELL/4,CELL/2,CELL/2,Color.black,null,""+row);
    			}
    			if((yindex==firstrow))
    			{	G.Text(gc,true,x-CELL/4,y-CELL/4,CELL/2,CELL/2,Color.black,null,""+col);
    			}}
    			anyhit |= hit;
    			if(isDest && (ourTurnSelect!=null) && canhit)
    			{	boolean desthit = false;
    				// if we're hitting a tile, see if we're hitting the corner which
					// means flip to the next state
					double dist = G.distance(x,y,G.Left(ourTurnSelect),G.Top(ourTurnSelect));
					if(dist<CELL/4)
					{ 
					ourTurnSelect.hitCode = TraxId.BoardLocation; 
					ourTurnSelect.arrow = StockArt.UpArrow;
					desthit=somehit=true; 
					}
					else if( (dist<(CELL*2)) && (gb.nColorMatch(col,row)>1))
					{
						ourTurnSelect.hitCode = TraxId.TileCorner;
						ourTurnSelect.arrow = StockArt.Rotate_CW;
						desthit=somehit=true;
					}
					if(desthit)
					{
					ourTurnSelect.col = col;
					ourTurnSelect.row = row;
					}
    			}
    			else if(!somehit)
    			{
    			//if(hit) {System.out.println("Hit "+col+","+row);}
 				if(hit)
				{
 				 if(isEmpty) 
 				 {	ourTurnSelect.hitCode = TraxId.EmptyBoard;
 				    ourTurnSelect.arrow = StockArt.DownArrow;
 				    somehit=true;}
				 else 
				 {	// if we're hitting a tile, see if we're hitting the corner which
					// means flip to the next state
					double dist = G.distance(x,y,G.Left(ourTurnSelect),G.Top(ourTurnSelect));
					if(dist>(CELL/4)) 
					{ if((gb.nColorMatch(col,row)>1))
						{ourTurnSelect.hitCode = TraxId.TileCorner;
						 ourTurnSelect.arrow = StockArt.Rotate_CW;
						somehit=true;
						}
					}
					else 
					{ ourTurnSelect.hitCode = TraxId.BoardLocation; somehit=true; 
					  ourTurnSelect.arrow = StockArt.UpArrow;
					}
				 }
				if(somehit)
					{
					ourTurnSelect.col = col;
					ourTurnSelect.row = row;
					}
				}
			     //System.out.println("Hit "+highlight.col+highlight.row+ " @ " + xindex+","+yindex);
				}
 				if(gc!=null)
 				{
				if(cell!=Empty)
    			{	int idx = cell-'0';
     				drawChip(gc, idx, x, y, CHIPSIZE, 1.0,-1);
     				if(bisdest) 
     					{ drawChip(gc,idx,x,y,CHIPSIZE,1.0,b.whoseTurn);
     					  StockArt.Dot.drawChip(gc,this,CHIPSIZE,x,y,null);
     					}
     				if(showwins && b.onWinningLine(col,row))
     				{//drawGif(gc,GIF_DESAT_INDEX,x,y,CHIPSIZE,1.0);
     				   drawChip(gc,idx,x,y,CHIPSIZE,1.0,winner);
     				}
       			}
				else if(showdots && !hit)
				{ if(gb.nColorMatch(col,row)==1)
					{ StockArt.Dot.drawChip(gc,this,CHIPSIZE,x,y,null);
					}
				}
 				}
    		}
   		}
   		if(!somehit && (G.pointInRect(alwaysSelect,brect)&&!G.pointInRect(alwaysSelect,vcrRect) && ((mo==null)||draggingBoard)))
    	{ //let him drag anywhere, just don't annoy with the hand icon.
    		if(anyhit)
        	{	// this picks up the diagonals near the edges of the board
        		// and the center of the board area
    			alwaysSelect.hitCode = TraxId.DragBoard;
    			alwaysSelect.arrow = StockArt.Hand;
        	}
    		else
    		{
    			alwaysSelect.hitCode=TraxId.InvisibleDragBoard;
    		}
    		alwaysSelect.dragging = alwaysSelect.down;
    	}
    	}
     G.setClip(gc,sh);
    }
    //
    // draw the board and things on it.  If gc!=null then actually 
    // draw, otherwise just notice if the highlight should be on
    //
    public void redrawBoard(Graphics gc, HitPoint selectPos)
    {  TraxGameBoard gb = (TraxGameBoard) disB(gc);
       boolean moving = (getMovingObject()>=0);
       HitPoint ourTurnSelect = OurMove() ? selectPos : null;
       HitPoint buttonSelect = moving?null:ourTurnSelect;
       HitPoint nonDraggingSelect = (moving && !reviewMode()) ? null : selectPos;

       TraxState state = b.getState();
        redrawGameLog(gc, nonDraggingSelect, logRect, highlightColor);
        drawBoardElements(gc, gb, boardRect, ourTurnSelect,nonDraggingSelect);
        zoomRect.draw(gc,nonDraggingSelect);
        DrawChipPool(gc, chipPool, ourTurnSelect);
        G.setFont(gc,standardBoldFont);
       drawPlayerStuff(gc,(state==TraxState.PUZZLE_STATE),moving?null:selectPos,
	   			HighlightColor, rackBackGroundColor);


		if (state != TraxState.PUZZLE_STATE)
        {
            if (G.handleRoundButton(gc, doneRect, 
            		(b.DoneState() ? buttonSelect : null), s.get(DoneAction),
                    HighlightColor, rackBackGroundColor))
            {	// always display the done button, but only make it active in
            	// the appropriate states
            	buttonSelect.hitCode = DefaultId.HitDoneButton;
            }
            if (allowed_to_edit)
            {
     
                    if (G.handleRoundButton(gc, editRect, buttonSelect, s.get(EditAction),
                                HighlightColor, rackBackGroundColor))
                    {
                    	buttonSelect.hitCode = DefaultId.HitEditButton;
                    }
     
            }
        }

        if(gc!=null)
        {
        int inc = CELLSIZE/5;
        Rectangle sh = G.setClip(gc,firstPlayerTile);
        drawChip(gc,WHITE_PLAYER_INDICATOR_INDEX,G.Left(firstPlayerTile)+inc,G.Top(firstPlayerTile)+inc,G.Height(firstPlayerTile)*2,0.8,-1);
        G.setClip(gc,secondPlayerTile);
        drawChip(gc,BLACK_PLAYER_INDICATOR_INDEX,G.Left(secondPlayerTile)+inc,G.Top(secondPlayerTile)+inc,G.Height(secondPlayerTile)*2,0.8,-1);
        G.setClip(gc,sh);
        G.frameRect(gc,Color.black,firstPlayerTile);
        G.frameRect(gc,Color.black,secondPlayerTile);
        }
        



        if (gc != null)
        {
            standardGameMessage(gc,
            		state==TraxState.GAMEOVER_STATE?gameOverMessage():s.get(state.getDescription()),
            				state!=TraxState.PUZZLE_STATE,
            				gb.whoseTurn,
            				stateRect);
            goalAndProgressMessage(gc,selectPos,
            		s.get("make any loop, or a line which spans 8 rows or columns, in your color"),progressRect, goalRect);

         }
    
        drawVcrGroup(nonDraggingSelect, gc, HighlightColor, vcrButtonColor);
     }

    /**
     * Execute a move by the other player, or as a result of local mouse activity,
     * or retrieved from the move history, or replayed form a stored game. 
     * @param m the parameter is a commonMove so the superclass commonCanvas can
     * request execution of moves in a generic way.
     * @return true if all went well.  Normally G.Error would be called if anything went
     * seriously wrong.
     */
     public boolean Execute(commonMove m,replayMode replay)
    {	if(b.getState()==TraxState.PUZZLE_STATE)
        	{ 	m.setLineBreak(true);
        		m.setSliderNumString("--");
        	}
        handleExecute(b,m,replay);						 // let the board do the dirty work
        if(replay!=replayMode.Replay) { playSounds((Traxmovespec)m); }
        return (true);
    }
     void playSounds(Traxmovespec mm)
     {
   	  switch(mm.op)
   	  {
   	  case MOVE_DROPB:
   	  case MOVE_PICKB:
   	  case MOVE_ROTATEB:
   	  case MOVE_PICK:
   	  case MOVE_DROP:
   		  playASoundClip(light_drop,100);
   		  break;
   	  default: break;
   	  }
     }    
/**
 * parse a move specifier on behalf of the current player.  This is called by the 
 * "game" object when it receives a move from the other player.  Note that it may
 * be called while we are in review mode, so the current state of the board should
 * not be considered.
 */
    public commonMove ParseNewMove(String st)
    {
        return (new Traxmovespec(st, -1));
    }
/**
 * prepare to add nmove to the history list, but also edit the history
 * to remove redundant elements, so that indecisiveness by the user doesn't
 * result in a messy replay.
 * This may require that move be merged with an existing history move
 * and discarded.  Return null if nothing should be added to the history
 * One should be very cautious about this, only to remove real pairs that
 * result in a null move.
 * 
 */
    public commonMove EditHistory(commonMove nmove)
    {
        Traxmovespec newmove = (Traxmovespec) nmove;
        Traxmovespec rval = newmove;			// default returned value
        int size = History.size() - 1;
        int idx = size;
        TraxState state = b.getState();
        while (idx >= 0)
            {	int start_idx = idx;
                Traxmovespec m = (Traxmovespec) History.elementAt(idx);
                if(m.next!=null) { idx = -1; }
                else {
                switch(newmove.op)
                {
            	case MOVE_DONE:
               	case MOVE_RESIGN:		// resign is your whole move
            	default:
            		idx = -1;
            		break;
            	case MOVE_PICK:		// picks are not significant
            		if((state!=TraxState.PUZZLE_STATE) && (m.op==MOVE_DROPB))
            		{ popHistoryElement(); 
            		}
            		rval = null;
            		idx = -1;
            		break;
            	case MOVE_RESET:
            		rval = null;		// reset is never recorded in the history
            		switch(m.op)
            		{
                     default:
                		if(state==TraxState.PUZZLE_STATE) { idx=-1; break; }
						//$FALL-THROUGH$
					case MOVE_PICK:
            		case MOVE_PICKB:
                        popHistoryElement();
                        break;
                    case MOVE_DONE: // these stop the scan 
                    case MOVE_EDIT:
                    case MOVE_START:
                        idx = -1;
                    }
            		break;
            	case MOVE_DROP:
            		if(m.op==MOVE_PICK)
            		{
            		popHistoryElement();
             		rval = null;
            		}
               		idx=-1;
            		break;
            	case MOVE_PICKB:
            		if((m.op==MOVE_DROPB)	// drop but not rotate
            			&& ((m.to_row_after()==newmove.to_row)
                        		&& (m.to_col_after()==newmove.to_col)))
            		{	// drop followed by pick at the same location
            			popHistoryElement();
            			rval = null;
            		}
        			idx = -1;
        			break;
            	case MOVE_ROTATEB:
            	case MOVE_DROPB:
            		if (((m.op==MOVE_DROPB)||(m.op==MOVE_ROTATEB))
                			&& ((m.to_row_after()==newmove.to_row)
                            		&& (m.to_col_after()==newmove.to_col)))
            		{
                   	// drop followed by another drop on the same location, convert the first drop to the second type
                	m.source = newmove.source;
                	rval = null;	// remove the new move
              		}
            		idx = -1;
            		break;
                }
            idx--;
            }
            G.Assert(idx!=start_idx,"progress on edit history");
         }
        
 
        return (rval);
    }

/**
 * the preferred mouse gesture style is to let the user "pick up" objects
 * by simply clicking on them, but we also allow him to click and drag. 
 * StartDragging is called when he has done this.
 */
    public void StartDragging(HitPoint hp)
    {
        int mo = getMovingObject();
        if ((mo < 0) && (hp.hitCode instanceof TraxId))// not dragging anything yet, so maybe start
        {

       	TraxId hitObject =(TraxId)hp.hitCode;
 	    switch(hitObject)
	    {
	    default: 
	    case TileCorner:
        case ZoomSlider:
        case DragBoard:
        case InvisibleDragBoard:
        	break;
        case hitTile0:
        case hitTile1:
        case hitTile2:
        case hitTile3:
        case hitTile4:
        case hitTile5:
        	PerformAndTransmit("Pick "+hitObject.shortName);
        	break;
	    case BoardLocation:
	    	PerformAndTransmit("Pickb "+hp.col+" "+hp.row);
	    	break;
        }

        if (getMovingObject() >= 0)
        {	// if we got something started, inform the mouse handler
            hp.dragging = true;
        } 
        }
    }
	private void doDropChip(String op,char col,int row,char chip)
	{	TraxState state = b.getState();
		switch(state)
		{
		default: throw G.Error("Not expecting state "+state);
		case CONFIRM_STATE:
		case PLAY_STATE:
		case ILLEGAL_MOVE_STATE:
		case PUZZLE_STATE:
		{
			char st = b.nextColorMatch(col,row,chip); 
			PerformAndTransmit(op+" "+st+" "+col+" "+row);
		}
		break;
					                 
		
		}
	}
	/** 
	 * this is called on "mouse up".  We may have been just clicking
	 * on something, or we may have just finished a click-drag-release.
	 * We're guaranteed just one mouse up, no bounces.
	 */
    public void StopDragging(HitPoint hp)
    {
        CellId id = hp.hitCode;
        if(!(id instanceof TraxId)) {   missedOneClick = performStandardActions(hp,missedOneClick); }
    	else {
    	missedOneClick = false;
    	TraxId hitCode= (TraxId)hp.hitCode;
		TraxState state = b.getState();
        switch (hitCode)
        {
        default:
        	throw G.Error("Hit Unknown object " + hitCode);
         case ZoomSlider:
        case InvisibleDragBoard:
        case DragBoard: break;
        case TileCorner:
			switch(state)
			{
			default: throw G.Error("Not expecting drop on filled board in state "+state);
	        case ILLEGAL_MOVE_STATE:
			case CONFIRM_STATE:
			case PLAY_STATE:
				if(!b.isDest(hp.col,hp.row))
					{
					// note that according to the general theory, this shouldn't
					// ever occur because inappropriate spaces won't be mouse sensitve.
					// this is just defense in depth.
					throw G.Error("shouldn't hit a chip in state "+state);
					}
				// fall through and pick up the previously dropped piece
				//$FALL-THROUGH$
			case PUZZLE_STATE:
				char ch = (char)(1+b.GetBoardPos(hp.col,hp.row));
				if(ch=='6') { ch='0'; }
		       	doDropChip("rotateb",hp.col,hp.row,ch);
			}
			break;
       case BoardLocation:	// we hit an occupied part of the board 
			switch(state)
			{
			default: throw G.Error("Not expecting drop on filled board in state "+state);
			case CONFIRM_STATE:
			case PLAY_STATE:
				if(!b.isDest(hp.col,hp.row))
					{
					// note that according to the general theory, this shouldn't
					// ever occur because inappropriate spaces won't be mouse sensitve.
					// this is just defense in depth.
					throw G.Error("shouldn't hit a chip in state "+state);
					}
				// fall through and pick up the previously dropped piece
				//$FALL-THROUGH$
			case PUZZLE_STATE:
				PerformAndTransmit("Pickb "+hp.col+" "+hp.row);
				break;
			}
			break;
			
        case EmptyBoard:
			switch(state)
			{
				default:
					throw G.Error("Not expecting hit in state "+state);
				case GAMEOVER_STATE:
				case RESIGN_STATE:
					break;
				case ILLEGAL_MOVE_STATE:
				case CONFIRM_STATE:
				case PLAY_STATE:
				case PUZZLE_STATE:
					{
					int mo = b.movingObjectIndex();
					if(mo<0) { mo = b.lastPicked(); }
					if(mo<0) { mo=0; }
					char moc = (char)('0'+mo);
					doDropChip("dropb",hp.col,hp.row,moc);
					}
					break;
			}
			break;
		
        case hitTile0:
        case hitTile1:
        case hitTile2:
        case hitTile3:
        case hitTile4:
        case hitTile5:
        	PerformAndTransmit("Drop "+hitCode.shortName);
            break;


        }
        }
        repaint(20);
    }

    /** this is the place where the canvas is actually repainted.  We get here
     * from the event loop, not from the normal canvas repaint request.
     */
    public void drawCanvas(Graphics offGC, boolean complete,HitPoint hp)
    {

    	drawFixedElements(offGC,complete);
   	
    	// draw the board contents and changing elements.
        redrawBoard(offGC,hp);
         //      draw clocks, sprites, and other ephemera
        drawClocksAndMice(offGC, boardBackgroundColor);
        DrawTileSprite(offGC,hp); //draw the floating tile, if present
        DrawArrow(offGC,hp);
        drawSprites(offGC);

    }

   public String gameType() { return(b.gametype); }
   public String sgfGameType() { return(Trax_SGF); }
   public void performHistoryInitialization(StringTokenizer his)
   {   //the initialization sequence
   	String token = his.nextToken();
    b.doInit(token);
   }


    /** handle action events
     * 
     */
    public boolean handleDeferredEvent(Object target)
    {
        boolean handled = super.handleDeferredEvent(target);
        if (target == useClassicItem)
        {	handled=true;
        	useClassic = useClassicItem.getState();
        }
 
        return (handled);
    }

    /** factory method to create a robot */
    public SimpleRobotProtocol newRobotPlayer() { return(new TraxPlay()); }
    
    public boolean parsePlayerExecute(commonPlayer p,String first,StringTokenizer tokens)
    {	// handle older games that don't have "done" after every move
    	boolean isDone = "done".equals(first);
    	if(!isDone && b.DoneState())
    	{	PerformAndTransmit("Done",false,replayMode.Live);
    	}
    	String msg = first + " "+ G.restof(tokens);
        return(PerformAndTransmit(msg, false,replayMode.Live));	
    }
    
    /** replay a move specified in SGF format.  
     * this is mostly standard stuff, but the key is to recognise
     * the elements that we generated in sgf_save
     */
    public void ReplayMove(sgf_node no)
    {
        String comments = "";
        sgf_property prop = no.properties;

        while (prop != null)
        {
            String name = prop.getName();
            String value = (String) prop.getValue();

            //System.out.println("prop " + name + " " + value);
            if (name.equals(comment_property))
            {
                comments += value;
            }
            else if (name.equals(game_property))
            {
                if (!(value.toLowerCase().equals("trax") || value.equals(Trax_SGF)))
                {
                	throw G.Error("game type " + value + " is not this game");
                }
            }
            else if (parseVersionCommand(name,value,2)) {}
            else if (parsePlayerCommand(name,value)) {}
            else
            {
            	replayStandardProps(name,value);
            }

            prop = prop.next;
        }

        if (!"".equals(comments))
        {
            setComment(comments);
        }
    }
}
