package online.game;
import java.awt.Color;
import java.awt.Component;
import java.awt.FileDialog;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Menu;
import java.awt.Point;
import java.awt.Rectangle;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JFileChooser;
import jzlib.ZipEntry;
import jzlib.ZipInputStream;
import java.io.File;
import java.net.URL;

import bridge.JMenu;
import bridge.JMenuItem;
import bridge.Config;
import bridge.MasterForm;
import bridge.Utf8OutputStream;
import bridge.Utf8Printer;
import bridge.XJMenu;

import java.io.PrintStream;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.Vector;

import lib.*;
import lib.Graphics;
import lib.Image;
import online.common.GameInfo;
import online.common.LaunchUser;
import online.common.LaunchUserStack;
import online.common.OnlineConstants;
import online.common.SeatingChart;
import online.common.SeatingChart.DefinedSeating;
import online.common.SimpleSprite;
import online.common.SimpleSprite.Movement;
import online.common.StockArt;
import online.common.commonDisplay;
import online.common.commonPanel;
import online.common.exCanvas;
import online.common.exHashtable;
import online.game.sgf.sgf_game;
import online.game.sgf.sgf_gamestack;
import online.game.sgf.sgf_names;
import online.game.sgf.sgf_node;
import online.game.sgf.sgf_property;
import online.game.sgf.sgf_reader;
import online.search.TreeViewer;
import online.search.UCTTreeViewer;
import vnc.VNCService;
import vnc.VncServiceProvider;
import vnc.VncRemote;
import online.search.AlphaTreeViewer;
import online.search.SimpleRobotProtocol;
/*
Change History

Oct 2004 Migrated some common stuff from zertz, to be used by all

Feb 2005 switched the PAINT and MOUSE functions to synchronize through
  the run thread.  This avoids all manner of random nastiness which could
  occur as complex data structures are manipulated by three independant
  processes.

July 2006 added repeatedPositions related functions

*/
/**
 * This class extends exCanvas and provides a bunch of services for the
 * individual game's Viewer class.   Many of the requirements of {@link ViewerProtocol}
 * are implemented here, and will not needs to be done by the game's subclass.
 * <br>
 * The main services are
 * <li>a history of moves in the game
 * <li>a "VCR cluster" of forward-back controls to view the game history.
 * <li>mouse handling
 * <li>repaint management
 * <li>some standard option menus
 * <li>debugging aids for screen layout and performance
 * <li>a run loop
 * @see exCanvas
 */
// TODO: add some visual distraction when the tick-tock sound plays and the sound is off
// TODO: add some additional cue when "living in the past"
// TODO: the concept of "peeking" and its interaction with "undo" needs more thought.  Need to be able to review without losing track of the fact that we peeked
//
public abstract class commonCanvas extends exCanvas 
	implements PlayConstants,ViewerProtocol,CanvasProtocol,sgf_names
{ // state shared with parent frame
    // aux sliders
    public Bot robot = null; 
    public boolean isPassAndPlay = false;	// this game was created as a pass and play game

    class DeferredMessage
    { int player; 
      String str;
      DeferredMessage(int pl,String s)
      {
    	  player = pl;
    	  str = s;
      }
    }
	class Hidden
	{
	    private Vector<DeferredMessage> deferredMessages = new Vector<DeferredMessage>();
		private boolean canSynchronize = false;
		private int chatSizeAdj = 0;
		private commonPlayer lastPlayer=null;
	    private long startTurn = 0;
	    private long doneAtTime=0;
		private long lastAnimTime = 0;
	    private Object lastLastDropped = null;
	    private Object lastLastDropped2 = null;
	    private int hurryState = 0;
	    private long hurryTime = (60 * 14 * 1000);	// time to tell the player to finish up
	    private boolean resign_needed = false;
	    private long timePerTurn = (2 * 60 * 1000);	// tick him after this much time
	    private long timePerDone = 15*1000;		
	    private CellId vcr6ButtonCodes[] = 
	    	{ VcrId.WayBackButton, VcrId.BackPlayerButton, VcrId.BackStepButton,
	    	VcrId.ForeStepButton, VcrId.ForePlayerButton, VcrId.ForeMostButton};
	    
	    private Rectangle vcrFrontRect = addRect(".vcrFrontRect");
	    private Rectangle vcrButtonRect = addRect(".vcrButtonRect");
	    private Rectangle vcrVarRect = addRect(".vcrVarRect");
	    private Rectangle vcrBackRect = addRect(".vcrBackRect");
	    private Rectangle normalVcrRect = null;	// copy of vcrZone until expanded
	    private Rectangle outsideVcrRect = null;
	    // common support for reviewer windows
	    private sgf_gamestack Games = null;
	    private sgf_game selectedGame = null;
	    private JMenu gamesMenu = null;
	    private PopupManager gamePopup =  new PopupManager();
	    private PopupManager threadPopup = new PopupManager();
	    private PopupManager robotPopup = new PopupManager();
	    private SimpleRobotProtocol threadPopupRobot = null;
	    private JMenuItem saveGame = null;
	    private JMenuItem loadGame = null;
	    private JMenuItem saveCollection = null;
	    private JMenuItem replayCollection = null;
	    private JMenuItem replayFolder = null;
	    private boolean loadGameNeeded = false;
	    private boolean saveGameNeeded = false;
	    private boolean saveCollectionNeeded = false;
	    private boolean replayCollectionNeeded = false;
	    private boolean replayFolderNeeded = false;
	    
	    private JMenuItem resignAction = null;
	    private JMenuItem passMove = null;
	    private JMenuItem saveAndCompare = null;
	    private JCheckBoxMenuItem noChatMenu = null;
	    private boolean separateChat = false;		// chat in a separate window
	    private boolean hiddenChat = false;			// chat in current window, but hidden
	    private JMenuItem showText = null;
	    private JMenuItem showSgf = null;
	    private JMenuItem emailSgf = null;
	    private PopupManager panzoomPopup = new PopupManager();

	    private JMenuItem treeViewerMenu = null; //for testing, 
	    private JMenuItem alphaViewerMenu = null; //for testing, 
	    private JCheckBoxMenuItem alternateBoard = null;
	    private JMenuItem truncateGame = null; // truncate the game here
	    private JMenuItem evalRobot = null; //start the robot static evaluator
	    private JMenuItem testRobot = null; //ask the robot for a test move
	    private JMenuItem startRobot = null; //start the robot level 0 as a running process
	    private JMenuItem robotLevel0 = null;
	    private JMenuItem stopRobot = null; //stop the robot from playing
	    private JMenuItem pauseRobot = null; //stop the robot from playing
	    private JMenuItem resumeRobot = null;	// resume the robots
	    private JMenuItem selectRobotThread = null;	// select which thread to view
	    private JMenuItem saveVariation = null;	// save the robot's variation (presumably at an error)
	    private JMenuItem runGameDumbot = null;	// run a test game
	    private JMenuItem runGameSelf = null;	// run a test game
	    private JMenuItem train = null;		// run training
	    private JMenuItem startShell = null; 	// start a bean shell
	    /**
	     * this is a {@link lib.Slider} this is a rectangle embedded in the VCR control cluster
	     */
	    private Slider animationSpeedRect = addSlider(".animationSpeed",AnimationSpeed,VcrId.sliderAnimSpeedButton,0.0,2.0,0.6);
	    
	    private PopupManager vcrVarPopup = new PopupManager();
	
	    private boolean controlToken=false;
	    private long controlTimeStamp = 0;
	    private Thread cnThread = null;
	
	    private boolean pendingControlExpired()
	    {	Thread myThread = Thread.currentThread();
	    	if(cnThread==null) { cnThread = myThread; }
	    	//G.Assert(myThread==cnThread,"thread mismatch, is %s should be %s",myThread,cnThread);
	    	// 
	    	// in the new regime with server mediated control, we never steal control
	    	//
	    	if(!canSynchronize && (controlTimeStamp>0))
	    	{	long now = System.currentTimeMillis();
	    		if((now-controlTimeStamp)>5000) // 5 seconds ago
	    		{ controlToken=true;
	    		  controlTimeStamp=0;
	    		  SendNote("Control stolen");
	    		}
	    	}
	    	return(controlToken);
	    }
		
	    private BoardProtocol savedBoard = null;
	    boolean handleDeferredEvent(Object target)
	    {	if(target==zoomButton)
	    	{
	    	setGlobalZoomButton();
	    	}
	    	else if(target==unzoomButton)
	    	{
	    	setGlobalUnZoomButton();
	    	}
	    	else if(target==noChatMenu)
	    	{	setSeeChat(!noChatMenu.getState());
	    	}
	    	else if(target==saveAndCompare)
	        {	
	        	if(savedBoard!=null) { savedBoard.sameboard(getBoard()); G.print("Ok"); savedBoard=null; }
	        	else { savedBoard = getBoard().cloneBoard(); G.print("Saved "+savedBoard); }
	        }
	        else if (target == showText)
	        {
	            doShowRawText();
	        }
	        else if (target == emailSgf)
	        {
	        	doEmailSgf();
	        }
	        else if (target == showSgf)
	        {
	            doShowSgf();
	        }
	        else if(target==resignAction)
	        {  resign_needed = true;
	        }
	        else if (target == passMove)
	        {   doPassMove();
	        }
	        else if (target == robotLevel0) 
	        	{   selectRobot(robotLevel0.getX(),robotLevel0.getY());
	        	}
	        else if (target == startShell) {  startShell(); }
	        else if (target == stopRobot)   {   stopRobots();  }
	        else if (target == pauseRobot)   {   pauseRobots();  }
	        else if (target == resumeRobot)   {   resumeRobots();  }
	        else if (target == selectRobotThread) { selectRobotThread(selectRobotThread.getX(),selectRobotThread.getY()); }
	        else if (target == saveVariation) { saveRobotVariation(); }
	        else if (target == runGameDumbot) { runRobotGameDumbot(); }
	        else if (target == runGameSelf) { runRobotGameSelf(); }
	        else if (target == train) { runRobotTraining(); }
	        else if (target == loadGame)
	        {
	            loadGameNeeded = true;
	        }
	        else if (target == saveGame)
	        {
	            saveGameNeeded = true;
	        }
	        else if (target == saveCollection)
	        {
	             saveCollectionNeeded = true;
	        }
	        else if (target== replayCollection)
	        {
	        	replayCollectionNeeded = true;
	        }
	        else if (target== replayFolder)
	        {
	        	replayFolderNeeded = true;
	        }
	        else if (target==treeViewerMenu)
	        {
	        	doTreeViewer(true);
	        }
	        else if (target==alphaViewerMenu)
	        {
	        	doTreeViewer(false);
	        }
	        else if(robotPopup.selectMenuTarget(target))
	        {
	        	robot = (Bot)robotPopup.rawValue;
	        }
	        else if(threadPopup.selectMenuTarget(target))
	        {	SimpleRobotProtocol r = threadPopupRobot;
	        	if(r!=null)
	        	{	Thread val = (Thread)threadPopup.rawValue;
	        		if(val!=null) { r.selectThread(val); }
	        	}
	        }
	        else if(gamePopup.selectMenuTarget(target))
	        {
	        	selectGame((sgf_game)gamePopup.rawValue);
	        }
	        else if (panzoomPopup.selectMenuTarget(target))
	        {
	        	doRestorePanZoom((String)panzoomPopup.rawValue);
	        }
	        else if (target==gamesMenu) 
	        	{ if(!gamePopup.isShowing())
	        		{ selectGameMenu(gamesMenu.getX(),gamesMenu.getY());
	        		}
	        	}
	        else if (target == startRobot)
	        {  	commonPlayer who = whoseTurn();
	        	commonPlayer ap = getActivePlayer();
	            commonPlayer started = startRobot(who,ap,robot);
	            if(started!=null) { started.runRobot(true); }
	        }   
	        else if (target == alternateBoard)
	        {
	            useAlternateBoard = alternateBoard.getState();
	        }
	        else if (target == truncateGame)
	        {
	            doTruncate();
	        }
	        else if (target == evalRobot)
	        {
	          // this is a debugging hack to print the robot's evaluation of the
	          // current position.  Not important in real play
	        	startRobot(getActivePlayer(),getActivePlayer(),robot);
	        	
	        }
	        else if (target == testRobot)
	        {   commonPlayer who = viewerWhoseTurn();
	        	commonPlayer started = startRobot(who,getActivePlayer(),robot);
	            if(started!=null) { startRobotTurn(started); }
	        }
	        else { return(false); }

	    	return(true); 
	    }
	    /** 
	     * draw the vcr control buttons
	     * @param p
	     * @param inG
	     * @param HighlightColor
	     * @param vcrButtonColor
	     * @return the hit code for the sub-button hit
	     */
	    private CellId drawVcrButtons(HitPoint p, Graphics inG)
	    {
	        CellId rval = null;
	        CellId codes[] = vcr6ButtonCodes;
	        int nButtons = StockArt.vcrButtons.length;
	        Rectangle r = vcrButtonRect;
	        int vcrWidth = G.Width(r) / nButtons;
	        boolean iny0 = (p != null) && (G.Top(p) >= G.Top(r)) && (G.Top(p) < G.Bottom(r));
	        boolean iny = iny0 && !p.dragging;

	        for (int i = 0; i < nButtons; i++)
	        {
	            int currentX = G.Left(r) + (i * vcrWidth);
	            boolean inbox = iny && (G.Left(p) >= currentX) &&
	                (G.Left(p) <= (currentX + vcrWidth));

	            if (inG != null)
	            {
	                G.setFont(inG,standardBoldFont());
	                StockArt.vcrButtons[i].drawChip(inG,getThis(),vcrWidth+(inbox?vcrWidth/3:0),currentX+vcrWidth/2,
	                		G.Top(r)+G.Height(r)/2,null);
	            }
	            if (inbox)
	            {
	                    p.hitCode = rval = codes[i];
	            }
	        }
	        if((rval==null) && G.pointInRect(p,vcrZone))
	        {	// hit the background not occupied by a button
	        	rval = VcrId.noVcrButton;
	        }
	        return (rval);
	    }
	    private boolean enterReviewMode()
	    { 	int size = History.size();
	        if ((History.viewStep == -1) && (size > 0))
	        {
	            // entering review mode. Remember whose turn it really is
	            // this is so the outside world can be kept in the dark and incoming
	            // moves can be handled properly.
	            History.viewTurn = whoseTurn();
	            History.viewStep = size;
	            commentedMove = hidden.currentHistoryMove();
	            commentedMoveSeen = null;
	           	generalRefresh(); 
	            return(true);
	        }
	        return(false);
	    }
	    
	    //
	    // this construction for doBack with N as an argument
	    // allows us to do UndoStep just once instead of once per step
	    //
	    private boolean doBack(int n)
	    {
	       
	        hidden.enterReviewMode();

	        int v0 = History.viewStep;

	        if (History.viewStep > 0)
	        {
	            UndoStep(v0-n);
	        }
	        showComments(); 
	        return ((History.viewStep!=-1) && (History.viewStep < v0));
	    }
	    private void RedoStep(replayMode mode,commonMove m)
	    {
	        Execute(m,mode);
	        if(m.digest==0) { m.digest = getBoard().Digest(); }
	        repeatedPositions.checkForRepetition(getBoard(),m);
	        if(History.viewStep==-1) {  generalRefresh(); }
	    }
	    private commonMove removeHistoryElementRecurse(int idx)
	    {	int siz = History.size();
			if(idx>=siz) { return(null); }
			if(idx+1==siz) { return(popHistoryElement()); }
	    	commonMove rem = popHistoryElement();
	  	  	commonMove val = removeHistoryElementRecurse(idx);
	  	  	if (History.size() > 0)
	  	  	{	
	            commonMove m = History.top();
	            rem = m.addVariation(rem);
	        }
	  	  rem.digest = 0;		// digest will be inaccurate when undoing out of order
	  	  rem.addToHistoryAndExtend(History);
	  	  return(val);
	    }
	    private void doTreeViewer(boolean uct)
	    {   RootAppletProtocol theRoot = G.getRoot();
	    	commonPanel panel = (commonPanel)G.MakeInstance("online.common.commonPanel");
	    	LFrameProtocol frame;
	    	if(uct)
	    		{
	    		treeViewer = (UCTTreeViewer)G.MakeInstance("online.search.UCTTreeViewer");
	    		frame = theRoot.NewLFrame("UCT search tree viewer",panel);
	    		}
	    	else {
		    	treeViewer = (AlphaTreeViewer)G.MakeInstance("online.search.AlphaTreeViewer");
		    	frame = theRoot.NewLFrame("AlphaBeta search tree viewer",panel);	    		
	    	}
	    	treeViewer.init(sharedInfo,frame);
	    	panel.setCanvas(treeViewer);
	    	treeViewer.setVisible(true);
	    	
	    	frame.setParentBounds(100,100,(int)(SCALE*800),(int)(SCALE*600));
	    	frame.setVisible(true);
	    	panel.start();
	    }
	    private void emitLine(Graphics gc,Rectangle r,int ypos,int x,
	    		int maxLineH,int mid,Color textColor,Text columns[],Color colors[],String moven)
	    {
			int yp = G.Top(r) + ypos;
			G.Text(gc, false, G.Left(r) + 2, yp, x - G.Left(r) - 2,maxLineH, textColor, null, moven);
			for(int col = 0; col<columns.length; col++)
			{
	    	int xp =  x + 2 + (col*mid);
	     	Text pt = columns[col];
	    	if(pt!=null)
	    		{ pt.draw(gc, false, xp,  yp, mid - 4, maxLineH, textColor, colors[col]);
	     		  columns[col] = null;
	    		}
			}
	    }	
	    private void gameSubMenu(MenuInterface sub,int start,int to)
	    {	
	    	if((to-start)<=40)	// terminal nodes
	    	{
	    		while(start<to) 
		    	{
		    		sgf_game game = hidden.Games.elementAt(start);
		    		String name = game.short_name();
		    		start++;
		    		if(name==null) { name = "Game #"+start; }
		    		gamePopup.addMenuItem(sub,name,game);
		    	}
	    	}
	    	else	// multiple levels
	    	{	int span = ((to-start)<(25*40)) ? 25 : ((to-start)/25);
	    		while(start<to)
	    		{int end = Math.min(to,(start+span));
	    		 MenuInterface m = gamePopup.newSubMenu(""+(start+1)+"..."+end);
				 gameSubMenu(m,start,end);
				 gamePopup.addMenuItem(sub,m);
				 start += span;
	    		}
	    	}

	    }
	  
	    private void selectGameMenu(int x,int y)
	    {	gamePopup.newPopupMenu(getThis(),deferredEvents);
	    	if(hidden.Games!=null)
	    	{
	    	 gameSubMenu(null,0,hidden.Games.size());
	    	}
	    	gamePopup.show(x,y);
	    }
	    
	    
	    // replay one incoming move
	    private boolean performMessage(String st0, int player)
	    {	boolean playing = !mutable_game_record;
	    	String st = st0;
	    	int time = -1;
	    	while(st.charAt(0)=='+')
	    	{	// accept a leading token of +T nnn
	    		// and for future compatibility, accept +xx xxx 
	    		int space1 = st.indexOf(' ');
	    		int space2 = st.indexOf(' ',space1+1);
	    		if(space1>=0 && space2>=0)
	    		{
	    			String op = st.substring(0,space1);
	    			String payload = st.substring(space1+1,space2);
	    			st = st.substring(space2+1);
	    			if("+T".equals(op)) { time = G.IntToken(payload); }
	    		}
	    	}
	        commonMove m = ParseNewMove(st, player);
	        lastParsed = "Replay "+m;
	        // note, capturing the value here is crucial.  If this is a game ending move
	        // the the value of "mutable" will be changed by perform and transmit.
	        // we depend on the caller seeing true here to correctly run the "finishUp" process.
	       
	        if (PerformAndTransmit(m, false,replayMode.Live))
	        {	if(time>=0) 
	        		{
	        		// this assures that the elapsed times agree for all players
	        		m.setElapsedTime(time); 
	        		}
	            repaint(20);
	            // note that when gameover occurs, playing would now be false if we re evaluated it.
	            return (playing); // return false for reviewers, so no other side effects ensue
	        }

	        return (false);
	    }
	    // handle stored messages, either immediately or when exiting review mode.
	    private boolean handleDeferredMessages()
	    {	boolean playing = !mutable_game_record;
	    	boolean some = false;
	    	if (playing && reviewMode()) { return(true); }
	     	while(hasDeferredMessages())
	    	{	DeferredMessage st = deferredMessages.elementAt(0);
	    		deferredMessages.removeElementAt(0);
	    		some |= performMessage(st.str, st.player);
	            if(GameOverNow()) { stopRobots(); }
	    	}
	    	return(some);	//  
	    }
	    private boolean hasConnection(commonPlayer pl)
	    {
	    	return((G.Date()-pl.lastInputTime)<3*60*1000);
	    }
	    
	    /**
	     * draw the player name, clock, and network activity spinner.  If hp
	     * is not null, draw the player name as a "start" button.
	     * 
	     * @param gc	  the gc
	     * @param pl	  a commonPlayer 
	     * @param hp	  the mouse location
	     * @param code	  the hitCode to use if the button is hit, or null to present as a label
	     * @param highlightColor
	     * @param backgroundColor
	     */
	    private void drawPlayerStuff(Graphics gc,commonPlayer pl,
	    		HitPoint hp,CellId code,
	    		Color highlightColor,Color backgroundColor)
	    {	pl.setRotation(gc, hp, false);
	        String p0Name1 = prettyName(pl.boardIndex);
	        int my = getBoard().whoseTurn();
	        G.setFont(gc,standardBoldFont());
	        if(code!=null)
	        {
	        String p0Name2 = s.get(StartPlayer,p0Name1);
	        if(G.handleSquareButton(gc, pl.nameRect, hp, p0Name2,	highlightColor,
	        		(simultaneous_turns_allowed()||(my==pl.boardIndex))
	        			?highlightColor
	        			:backgroundColor))
	        	{	hp.hitCode = code;
	        		hp.setHelpText(s.get(ResumePlayText,p0Name1));
	        	}
	        }
	        else
	        {
	        	G.handleRoundButton(gc, pl.nameRect, null, p0Name1,	highlightColor,
	            		(simultaneous_turns_allowed()||(my==pl.boardIndex))
	            			?highlightColor
	            			:backgroundColor);
	        }
	     	if(gc!=null) 
	     		{ pl.drawPlayerImage(gc, commonCanvas.this, pl.picRect); 
	     		  HitPoint.setHelpText(hp, pl.picRect,s.get(UploadHelp,bridge.Config.uploadPicture));
	     		  
	     		}

	     	boolean review = reviewMode();
	     	long mintime = review ? pl.reviewTime : pl.elapsedTime;
	    	for(commonPlayer p : players)
	    	{
	    		if(p!=null) { mintime = Math.min(mintime,review?p.reviewTime : p.elapsedTime); }
	    	}
	
	    	Rectangle ar = pl.animRect;
	    	long ptime = review ? pl.reviewTime : pl.elapsedTime;
	    	if(ar!=null && hasConnection(pl))
		    	{
	    		G.draw_anim(gc,ar,G.Width(ar)/2,pl.lastInputTime,pl.progress);
		    	}
    
	    	String timeString = G.timeString(ptime);
	    	G.printTimeC(gc, pl.timeRect,timeString, 
	    				   review?Color.blue:Color.black,null, standardBoldFont());
	    	   
    		if(G.Height(pl.extraTimeRect)>0 && ptime>mintime)
    		{  
    		G.printTimeC(gc, pl.extraTimeRect, "+ "+G.briefTimeString(ptime-mintime),
    				Color.blue,null, standardBoldFont());
    		}
    		pl.setRotation(gc, hp, true);
	    }

	    // this is overridable but do not call it directly, call doScrollTo(FORWARD_ONE);
	    private boolean doForward(replayMode mode)
	    {
	    	return doForwardStep(mode);
	    }

	    private commonMove currentHistoryMove()
	    {
	        if (History.viewStep > 0)
	        {
	            return (History.elementAt(History.viewStep - 1));
	        }
	        else if(History.size()>0) 
	        	{
	        	  return(History.top()); 
	        	}

	        return (null);
	    }

	
	}
	Hidden hidden = new Hidden();
	private commonCanvas getThis() { return(this); }
	/**
	 * 
	 */
	static final long serialVersionUID = 1L;
	/**
	 * animating is true while we are animating replay of a whole game, triggered by the |> button on the vcr panel.
	 */
	public boolean animating = false;
	/**
	 * this is the value associated with the slider that appears during "movie" replays.  When establishing
	 * individual animation steps, multiply time by masterAnimationSpeed 
	 */
	public double masterAnimationSpeed = 1.0;
	public boolean started = false;
	/**
	 * return a guesstimate of what move number constitutes "midgame"
	 * this is used as a marking point to save the digest for "repeated 
	 * game" fraud detection.
	 */
	public int midGamePoint() { return(20); }
    /**
     * this is a standard rectangle of all viewers - the rectangle that 
     * contains the board.  Your {@link #setLocalBounds} method still has
     * to position this rectangles.
     */
    public Rectangle boardRect = addRect(".boardRect"); //the actual board, normally at the left edge

    /**
     * override this method to do just the drawing of the board background and grid,
     * sepatated from whatever else the drawFixedElements method does.  Then call
     * drawFixedBoard(gc) to tap into the optional rotation of the board that may
     * or may not be in effect.
     * @param gc
     * @param r
     */
    public void drawFixedBoard(Graphics gc,Rectangle r)
    {
    	G.Error("override this method");
    }
    /**
     * provide the rotation context, if needed, for the board.  Define drawFixedBoard(gc,rect)
     * to do the work, after the optional board rotating transformation is applied.
     * @param gc
     */
    public void drawFixedBoard(Graphics gc)
    {
        setRotatedContext(gc,boardRect,null,contextRotation);
        drawFixedBoard(gc,boardRect);
        unsetRotatedContext();      
    }

     /**
     * this is the standard rectangle for the current game state/action to take
     * which is usually placed on top of the board rectangle
     */
    public Rectangle stateRect = addRect("stateRect");
    /**
     * this is the standard rectangle to display some sort of player
     * icon next to the player name
     */
    public Rectangle iconRect = addRect("iconRect");
    /**
     * this is a standard rectangle of all viewers - the rectangle that 
     * contains the hide chat icon.  Your {@link #setLocalBounds} method still has
     * to position this rectangles.
     */
    public Rectangle noChatRect = addRect("nochat");
   
    /**
     * common rectangle to hold the view selection rectangle
     */
    public Rectangle viewsetRect = addRect("viewset");
    
    /**
     * this is a standard rectangle of all viewers - the rectangle that 
     * contains the board.  Your {@link #setLocalBounds} method still has
     * to position this rectangles.
     */
    public Rectangle fullRect = addRect("fullRect"); //the whole viewer area
	
    public Slider globalZoomRect = null;
    /** for games with a scaleable board, this is the conventional name for
     * the slider that controls the scale
     */
    public Slider zoomRect = null;
    /** for games with a boardless board, center of the visible portion
     */
    public double board_center_x = 0.0;
    /** for games with a boardless board, center of the visible portion
     */
    public double board_center_y = 0.0;


    /**
     * this is a standard rectangle of all viewers - the rectangle that 
     * contains the board.  Your {@link #setLocalBounds} method still has
     * to position this rectangles.
     */
    public Rectangle chatRect = addZoneRect("chatRect"); // the chat window
    
    public boolean avoidChat(int x,int y)
    {
    	return((chatRect!=null) 
    			&& (theChat!=null)
    			&& theChat.isWindow()	// old style chat window 
    			&& G.pointInRect(x,y,chatRect));
    }
    /** default for main colors of mouse sprites, index by player boardIndex,
     * for up to 6 players.  These are the default colors of the opponent's mice.
     * */
    public Color SpectatorColor = new Color(0.5f,0.5f,0.5f);
    /**
     * the default center color for spectator's mouse sprites.
     */
    public Color SpectatorDotColor = new Color(0.9f,0.9f,0.9f);
    /**
     * MouseColors are the default array of 6 colors for the mouse tracking sprites that
     * appear in live games.  You can replace this array with your own array containing game-appropriate colors 
     */
    public Color[] MouseColors = 
    	{ Color.white, Color.black ,
    	  Color.green, Color.yellow,
    	  Color.blue,Color.red};
    /** default for center dots of mouse sprites */
    public Color[] MouseDotColors = 
    	{ Color.black, Color.white, 
    		Color.yellow, Color.green,
    		Color.red,Color.blue
    		};

    /**
     * draw a mouse sprite and possibly some other object associated
     * with the mouse.  The moving object is encoded by {@link #getMovingObject}
     * <p>
     * note that this is not a real-time process, the mouse position and
     * object being dragged may differ from the internal state of the board.
     * @param g
     * @param idx
     * @param x
     * @param y
     */
    public abstract void drawSprite(Graphics g,int idx, int x,int y);
    /**
     * draw a representation of someone else's mouse position.  The default is a circle with
     * a center dot in a contrasting color.   The colors are determined by {@link #MouseColors MouseColors[]} and
     * {@link #MouseDotColors MouseDotColors[]} which can be replaced. Player can be -1 to indicate a spectator.
     * 
     * @param g
     * @param player a player index or -1
     * @param xp
     * @param yp
     */
    public void drawMouseSprite(Graphics g,int player,int xp,int yp)
    {	Color main = SpectatorColor;
    	Color dot = SpectatorDotColor;
    	if(g!=null)
    	{
    	if(player>=0) 
    		{	player = player%MouseColors.length;
     			main =  getMouseColor(player);
    			dot = getMouseDotColor(player);
    		}
    	  G.drawLargeSpot(g, xp, yp,main, dot,(int)(16*SCALE));
        }
    }
    private int getPlayerColorIndex(int player)
    {
    	int map[] = getBoard().getColorMap();
		if(player>=0 && player<map.length)
			{
				return(map[player]);
			}
		return(0);
    }
	public int nPlayers() {
		return(getBoard().nPlayers());
	}
	public DefinedSeating seatingChart() 
	{
		return seatingChart.id;
	}
    /**
     * get the mouse color to use for a player, considering
     * the default colors for the game and the current color map
     * @param player
     * @return a color
     */
    public Color getMouseColor(int player)
    {
    	return(MouseColors[getPlayerColorIndex(player)]);
    }
    /**
     * get the contrast color to use for a player, considering
     * the default colors for the game and the current color map
     * @param player
     * @return
     */
    public Color getMouseDotColor(int player)
    {
    	return(MouseDotColors[getPlayerColorIndex(player)]);
    }

 
	/**
	 * 
	 * this is a debugging hack to give you an event based on clicking in the player name
	 * You can take whatever action you like, or no action.
	 */
    public boolean inPlayRect(int eventX, int eventY)
    {	
        boolean val = (players.length>0) && (players[0]!=null)
        		&& players[0].nameRect.contains(eventX, eventY);
        return (val);
    }
    /**
     * send a note to the server log file.   This is intended as an adjunct to
     * bug reporting or other useful information collection.
     * @param ev
     */
    public void SendNote(String ev)
    {  	ConnectionManager myNetConn = (ConnectionManager)sharedInfo.get(exHashtable.NETCONN);
        if(myNetConn!=null) 
        	{ myNetConn.na.getLock();
        	  String seq = "";
        	  if(myNetConn.hasSequence) { seq = "x"+myNetConn.na.seq++ + " "; }
        	  myNetConn.count(1);
        	  myNetConn.sendMessage(seq+NetConn.SEND_NOTE + ev); 
        	  myNetConn.na.Unlock();
        	}
    }
    /**
     * add a string to the sequential communications log.  This will appear in sequence
     * if the communications log is dumped as part of an error report.  The intention of
     * this is to note events of interest correlated to the sequence of communications.
     * @param ev
     */
    public void LogMessage(String ev)
    { ConnectionManager myNetConn = (ConnectionManager)sharedInfo.get(exHashtable.NETCONN);
      if(myNetConn!=null) { myNetConn.LogMessage(ev); }
    }
    /** draw a mouse sprite for a particular player, and if there is a moving
     * object, draw a representation of the object for the player in control.
     * @param g
     * @param p
     */
    public void drawMouseSprite(Graphics g,commonPlayer p)
    {	//
    	// our own mouse will have mouseX and mouseY = -1 so they won't be tracked here.
    	//
    	if ((p != null) && mouseCheckbox.getState())
    	{ int mx = p.mouseX;
    	  int my = p.mouseY;
    	  long now = G.Date();
    	Point mp = decodeScreenZone(p.mouseZone,p.mouseX,p.mouseY);
        int xp = G.Left(mp);
        int yp = G.Top(mp);
        
        if (fullRect.contains(xp, yp))
        {
            int col = p.boardIndex; //assign colors to players
            int obj = p.mouseObj;
               
            if ((obj >= 0) && !reviewMode())
                { // draw an object being dragged
                  drawSprite(g,obj,xp,yp);
                }
            
      	  // only draw the mouse sprite if it has moved or for 1 second after
          // this prevents one user accidentally (or deliberately) blocking
          // the view by hovering his mouse over something.
      	  if((mx>=0) 
      		&& (my>=0)
      		&& ((mx!=p.drawnMouseX)
      			||(my!=p.drawnMouseY)
      			|| ((now-p.drawnMouseTime)<1000)))
      	  {
              p.drawnMouseX = mx;		// remember when and where
              p.drawnMouseY = my;
              p.drawnMouseTime = now;

            drawMouseSprite(g,col,xp,yp);
        }
    	}}
	}
    
    /** return the position to display "moving" objects in review mode, when
     * they are not actively being moved.  The default is near the lower right
     * corner of the board.
     */
    public Point spriteDisplayPoint()
    {	BoardProtocol b = getBoard();
    	int celloff = b.cellSize();
    	return(new Point(G.Right(boardRect)-celloff,G.Bottom(boardRect)-celloff));
    }
    /**
     * select the actual chat window height, given the height of the window.  This
     * method can be overridden to alter the choices within reasonable bounds.
     * 
     * @param height
     * @return the height to assign to the chat window
     */
    public int selectChatHeight(int height)
    {	if(sharedInfo.getBoolean(exHashtable.LOBBYCHATFRAMED,false)) { return(0); }
    	if(hidden.separateChat || hidden.hiddenChat) { return(0); }
    	int nominal = hidden.chatSizeAdj+(height*chatPercent)/100;
    	int fs = G.getFontSize(standardPlainFont());
    	int fh = fs*14;		// minimum lines, about 7
    	int fm = fs*20;		// maximum lines, about 10
    	int maxh = height*2/3;
        return(Math.min(Math.min(fm, maxh), Math.max(Math.max(MINCHATHEIGHT,fh),nominal)));
    }
    private void drawRotatedSprite(Graphics gc,int chip,HitPoint hp,Point pt)
    {
    	setRotatedContext(gc,hp,contextRotation);
    	drawSprite(gc,chip,G.Left(pt),G.Top(pt));
    	unsetRotatedContext();
    }
    /**
     * draw any object being dragged by the mouse.  In review mode, where the mouse
     * is actually moving the arrow controls, display "moving" objects at "spriteDisplayPoint"
     * 
     * @param gc
     * @param hp
     */
    public boolean DrawTileSprite(Graphics gc,HitPoint hp)
    { //draw the ball being dragged
    	// draw a moving tile
     	if(mouseTrackingAvailable(hp)) { magnifier.DrawTileSprite(gc,hp); }
    	int chip = getMovingObject(hp);
        if(reviewMode()) // in review mode we normally display moving pieces beside the vcr controls
          {	
          	if(!animating && chip>=0)
          	{
          	Point pt = spriteDisplayPoint();
          	drawRotatedSprite(gc,chip,hp,pt);
          	return(true);
            }
          }
          else if( (hp!=null) && hasControlToken())
          { // using getMovingObject() gets the published value of the moving object,
        	// which is >0 only if we're the active player dragging the object.
            if (chip >= 0)
            {	
                drawRotatedSprite(gc,chip,hp,hp);
                return(true);
            }
        }
         return(false);	// didn't draw any
    }
    
    /**
     * return the current real move number.  This is used by the
     * game controller to tell when to ask for the mid game digest (at 20 moves)
     * and when to consider a game a game to be recorded (after 3 moves).
     */
    public int MoveStep()
    {
        return (History.viewMove);
    }
    
	/**
	 * this provides the number seen in the VCR slider.  
	 */ 
    public String CurrentMoveString()
    {	BoardProtocol b = getBoard();
        return ("" + (b==null ? 0 : b.moveNumber()));
    }
    /** this provides the game state, digested as a unique integer, for
     * the game controller for fraud detection (the fraud being to play the
     * same game over and over to inflate your score).  It's used at midgame
     * as well as endgame, to uniquely identify this game.
     */
    public long Digest()
    {	BoardProtocol b = getBoard();
        return (b==null ? 0 : b.Digest());
    }

    /** this is used by the game controller to supply entertainment/progress strings to the lobby.  The usual format is the move number, 
     * optionally followed by 1 non-spaced string per player representing the score.
     * A more general format is also available, where the first token is x64 and the remaining tokens are encoded with
     * lib.Base64.encode(str) to allow arbitrary spaced and formatting.
     * */
    public String gameProgressString()
    {
        return ((mutable_game_record ? Reviewing : ("" + History.viewMove)));
    }
    public LaunchUserStack localPlayers = new LaunchUserStack();
    public void addLocalPlayer(LaunchUser u)
    {
    	localPlayers.push(u);
    }
    /**
     * return true if the player to move now is one of the players
     * using this gui
     * @return true if this player is using the same gui
     */
    public boolean isALocalPlayer(commonPlayer lp)
    { 	if(lp!=null)
    	{
    	if(offline() || lp.isProxyPlayer) { return(true); } 
    	}
    	return(false);
    }
    public boolean offline() { return( (G.vncServer!=null) || (!reviewOnly && super.offline())); }
    /**
     * true if we're not in review mode and we're the active player
     * @return true if it is our move as a player, including simultaneous moves by players
     */
    public boolean ourActiveMove()
    {	commonPlayer ap = getActivePlayer();
    	commonPlayer who = whoseTurn();
    	return(!reviewMode()
    			&& !ap.spectator 
    			&& (simultaneous_turns_allowed()
    					|| isALocalPlayer(who)
    					|| (who == ap)));
    }
    
    /** return true of we are allowed to make move-type gestures
     * that may affect the state of the game. This includes consideration
     * if if a game is in progress, if we are a player, and if the game
     * is active, temporarily in review, or permanently in review.
     * @return true if we can make moves
     */
    public boolean OurMove()
    {	if(!reviewOnly && !started) { return(false); }
        return (allowed_to_edit
        		? hasControlToken()
        		: ourActiveMove());
    }
    /**
     * @return true of we are allowed to scroll the game record.
     */
    public boolean allowedToScroll()
    {	return(allowed_to_edit ? hasControlToken() : true);
    }

    /**
     * this is used by the game class, not locally in the UI,
     * to get a token to tack onto the mouse coordinates.  By
     * convention, positive integers indicate trackable objects
     */ 
    public int getMovingObject(HitPoint highlight)
    {
        if (OurMove())
        {
            return (getBoard().movingObjectIndex());
        }
        return (NothingMoving);
    }
    
    public boolean hasMovingObject(HitPoint hp)
    {
    	return(getMovingObject(hp)>=0);
    }
    /** get the board object associated with the game.
     * 
     * @return the main game board
     */
    public abstract BoardProtocol getBoard();
    /**
     * redraw the board now.  This is where repainting actually
     * happens, also where the mouse is tracked and we decide
     * what object it points to.
     * @param gc
     * @param p
     */
    public abstract void redrawBoard(Graphics gc,HitPoint p);
    
   
    /** return the player whose turn it really is.  This is used by the game controller
     * to key sounds and other per player turn actions.  This does not change if the 
     * player goes into review mode.
     */
    public commonPlayer whoseTurn()
    {	commonPlayer p = reviewMode() ? History.viewTurn : null;
    	if(p==null) { p = viewerWhoseTurn(); }
    	if(p==null) { p = getPlayerOrTemp(0); }	// during game setup and other rare circumstances
    	return(p);
    }
    public commonPlayer viewerWhoseTurn()
    {
    	return(commonPlayer.findPlayerByIndex(players, getBoard().whoseTurn()));
    }
    // award control anyway after 2 seconds

    /**
     * true if we have the control token.  This will claim the token
     * if it is expected but delayed by 2 seconds.
     * @return true of we are in control and can click on the board
     */
    public boolean hasControlToken()
    {	// say we have control if we're not allowed to edit.
    	return(allowed_to_edit?(offline()||hidden.controlToken||hidden.pendingControlExpired()||inLimbo):true);
    }
    /**
     * we have the control token or are expecting it. This is used by the game
     * controller to decide if it should request the token.
     */
    public boolean hasControlTokenOrPending()
    {	boolean has = hasControlToken() || (hidden.controlTimeStamp>0);
    	return(has);
    }
    /**
     * true if we have the control token.  This should be used during
     * normal play, when operations are strictly synchronous.
     */
    public boolean hasExplicitControlToken()
    {
    	return(hidden.controlToken);
    }
    /** set ownership of the control token, with the timestamp if it's pending
     * 
     * false,0 means we are relinquishing control
     * false,nnn means we have requested control
     * true,nnn means we have received acknowlegement of our claim of control
     * 
     * if nnn isn't the same as controlToken, then there is a control fight
     * going on and we shouldn't claim control even if the val is true
     * 
     * The original communications to support this used client level message, either
     * CONTROL or NOCONTROL to signal who was permitted to make moves.  This proved
     * to be unreliable because of real-time lags.
     * 
     * The new protocol uses a server level "lock" request, which depends on
     * the clients relinquishing the lock in a timely manner.
     */
    public void setControlToken(boolean val,long timeStamp)
    {	//G.print("Set "+val);
    	//G.print(G.getStackTrace());
     	if(val && (timeStamp>0))
    	{
    	if(hidden.canSynchronize || (timeStamp==hidden.controlTimeStamp)) 
    		{ hidden.controlToken=val; hidden.controlTimeStamp=timeStamp; 
    		}
    	else
    		{ hidden.controlToken = false; 
    		  hidden.controlTimeStamp = 0; }		// control fight in progress
    	}
    	else 
    	{
    	 hidden.controlTimeStamp = timeStamp;
    	 if(hidden.controlTimeStamp==0)
    	 	{ 
    	 	hidden.controlToken=val; 
     	 	}
    	}
    }
 /**
  * this is called by the game controller when the game is over
  * and scoring activity has completed.  It's now safe to let the
  * players edit and rehash the game.   
  */
    public void setEditable()
    {	if(!getActivePlayer().spectator) { allowed_to_edit = true; }
    	mutable_game_record = true;
    }
    /**
     * return true if the game has ended.
     */
    public boolean GameOver()
    { // if we are in gameover state, become a reviewer of the finished game
        return(gameOver);
    }
    /** 
      * @return true if the game is in a GameOverState state right now.
     */
    public boolean GameOverNow()
    {	BoardProtocol b = getBoard();
    	boolean now = (b==null) ? false : b.GameOver();
    	gameOver |= now;
    	return(now);	// game over right now?
    }
    /**
     * return true if the player is a winner of this game.  This is used in scoring,
     * there should be at most one winner in a 2 player game.
     */
    public boolean WinForPlayer(commonPlayer p)
    {	if(p==null) { return(false); }
    	BoardProtocol b = getBoard();
    	if(b==null) { return(false); }
    	if(p.boardIndex>=b.nPlayers()) { return(false); }
    	return(b.WinForPlayer(p.boardIndex));
    }
    /**
     * return a score for the player in a multiplayer game.  This ought to 
     * include any tiebreaker differentiation, so may not be the score
     * the user expects to see.  The extra info will be packed by some
     * kind of chinese remaindering. 
     */
    public int ScoreForPlayer(commonPlayer p)
    {	throw G.Error("Shouldn't call this for a 2 player game");
    }
   
    //
    // a less precise but suitable for viewing score. This
    // may not include tiebreak informaiton
    public int PrettyScoreForPlayer(commonPlayer p)
    {
    	return(ScoreForPlayer(p));
    }
    
    public boolean UsingAutoma() { return(false); }
    public int ScoreForAutoma() { return(-1); }
    /** 
     * override this method to create an appropriate class of robot that implements RobotProtocol
     * @return a class instance of a new robot player for this game.
     */
    public abstract SimpleRobotProtocol newRobotPlayer();
    /** start the robot.  This is used to invoke a robot player.  Mainly this needs 
     * to know the class for the robot and any initialization it requires.
     *  */
    public commonPlayer startRobot(commonPlayer p,commonPlayer runner,Bot robo)
    {
        gameOver = false;
        if(robo!=null)
        {
        SimpleRobotProtocol rr = newRobotPlayer();
        if(rr!=null)
        {
        rr.InitRobot(this, sharedInfo, getBoard(), null, robo.idx);

        p.startRobot(rr,runner);
        if(G.debug()) { p.setPlayerName(robo.name+p.boardIndex,true,this); }
        return(p);
        }}
        G.infoBox("No Robot","Robot not specified yet"); 
        return(null);
        
    }
    private JCheckBoxMenuItem tickTockOption = null;	// play ticktok and hurry sounds
    private boolean playTickTockSounds = true;
    /**
     * this is true when the "use aux sliders" menu item is in effect.
     */
    public boolean useAuxSliders = false;
    JCheckBoxMenuItem auxSliders = null;
    JCheckBoxMenuItem debugSwitch = null;
    JCheckBoxMenuItem debugOnceSwitch = null;
    private JCheckBoxMenuItem mouseCheckbox = null;
    private JMenuItem layoutAction = null;

    public DrawableImage<?> lastDropped=null;
    /**
     * this is a {@link lib.Slider} active when the "use aux sliders" option is selected.
     * Setting its min and max values may be useful adjusting the size of artwork. 
 	 * Used by {@link #adjustScales}
     */
    public Slider auxXRect = addSlider(".auxXRect","X=",VcrId.sliderXButton);
    /**
     * this is a {@link lib.Slider} active when the "use aux sliders" option is selected.
     * Setting its min and max values may be useful adjusting the size of artwork.
 	 * Used by {@link #adjustScales}
     */
    public Slider auxYRect = addSlider(".auxYRect","Y=",VcrId.sliderYButton);
    /**
     * this is a {@link lib.Slider} active when the "use aux sliders" option is selected.
     * Setting its min and max values may be useful adjusting the size of artwork.
 	 * Used by {@link #adjustScales}
     */
    public Slider auxSRect = addSlider(".auxSRect","S=",VcrId.sliderSButton);
    /**
     * this is a {@link lib.Slider} active when the "use aux sliders" option is selected.
     * Setting its min and max values may be useful adjusting the size of artwork.
	 * Used by {@link #adjustScales2}
     */
    public Slider auxX2Rect = addSlider(".auxXRect","X2=",VcrId.sliderX2Button);
   /**
    * this is a {@link lib.Slider} active when the "use aux sliders" option is selected.
    * Setting its min and max values may be useful adjusting the size of artwork.
	 * Used by {@link #adjustScales2}
    */
    public Slider auxY2Rect = addSlider(".auxYRect","Y2=",VcrId.sliderY2Button);
    /**
     * this is a {@link lib.Slider} active when the "use aux sliders" option is selected.
     * Setting its min and max values may be useful adjusting the size of artwork.
	 * Used by {@link #adjustScales2}
    */
    public Slider auxS2Rect = addSlider(".auxSRect","S2=",VcrId.sliderS2Button);
   

    /**
     * this is called to adjust the x,y and scale associated with 
     * an object, using the auxiliary sliders.
     */
    public void adjustScales(double pscale[],DrawableImage<?> last)
    {	
    	if(useAuxSliders && (lastDropped!=null) && (lastDropped.getAltChip(getAltChipset())==last) )
	    {	// use this to tune piece position
    		if(last!=hidden.lastLastDropped)
	    	{
	    		auxSRect.value=pscale[2];
	    		auxXRect.value=pscale[0];
	    		auxYRect.value=pscale[1];
	    		hidden.lastLastDropped = last;
	        	auxSRect.centerValue();
	        	auxXRect.centerValue();
	        	auxYRect.centerValue();		
	    	}
    		pscale[0] = auxXRect.value;
    		pscale[1] = auxYRect.value;
    		pscale[2] = auxSRect.value;
    		}
    }
    /**
     * this is available to adjust the scale parameters of a second object during developent.
     * an object, using the second auxiliary sliders.
     */
    public void adjustScales2(double pscale[],DrawableImage<?> last)
    {
    if(useAuxSliders && (lastDropped.getAltChip(getAltChipset())==last))
	    {	// use this to tune piece position
    		if(last!=hidden.lastLastDropped2)
    			{
	    		auxS2Rect.value=pscale[2];
	    		auxX2Rect.value=pscale[0];
	    		auxY2Rect.value=pscale[1];
	    		hidden.lastLastDropped2=last;
	    		}
    		pscale[0] =auxX2Rect.value;
    		pscale[1] =auxY2Rect.value;
    		pscale[2] =auxS2Rect.value;
    		}
    }
     
   
    public String lastParsed = "";
    /**
     * the vcr slider cluster uses these Ids.  Normally these should be ignored
     * by individual game UIs.
     * @author Ddyer
     *
     */
    public enum VcrId implements CellId {
        WayBackButton, // also -103 -102 -101
        BackPlayerButton,
        BackStepButton,
        ForeStepButton,
        ForePlayerButton,
        ForeMostButton,
        
        Slider, // the vcr slide bar
        BackButton, //the back variation button
        FrontButton, // the forward variation button
        VarButton, // select variation
        AnimateButton,	// animate button
        
    	sliderXButton,
    	sliderYButton,
    	sliderSButton,
    	sliderAnimSpeedButton,
    	sliderX2Button,
    	sliderY2Button,
    	sliderS2Button,

    	expandButton,
    	shrinkButton,
    	noVcrButton,
        ;
    	public String shortName() { return(name()); }
    
    }
    public static final Color robotBackgroundColor = new Color(1.0f, 0.5f, 0.5f);
    public boolean use_grid = false; //maintained by this class
    public JCheckBoxMenuItem gridOption = null;
    public boolean useAlternateBoard = false;
    
    
    /**
     * place a sound and delay milliseconds until the next
     * @param name
     * @param delay
     */
    public void playASoundClip(String name,int delay)
    {	if(myFrame.doSound())
    	{ SoundManager.playASoundClip(name,delay);
    	}
    }
    
    public commonPlayer spectators[] = {};		// a null array, not null
    /** add a new spectator to the game, replacing the specified spectator.
     * this list is important mainly in review rooms, where all the participants
     * are spectators.
     * 
     */
    public void changeSpectatorList(commonPlayer p,commonPlayer replace)
    {	//G.print(""+my+" add "+p+" "+replace);
    	spectators = commonPlayer.changePlayerList(spectators,p,replace,true);
    	if(p!=null) { p.addObserver(this); }
    	if(reviewOnly && (theChat!=null))
    		{
    		int nc = numberOfConnections();
    		boolean hide = nc<=1;
    		theChat.setHideInputField(hide);
    		} 
     }

    public int numberOfConnections() 
    { 	int ns = 0;
    	for(commonPlayer p : spectators) { if(p!=null) { ns++; }}
    	return(ns+(reviewOnly?0:players.length)+((getActivePlayer().channel>0)?1:0)); }
    
    // list of player objects, list of time clock rectangles  
    public commonPlayer[] players = {null}; //shared with player
    public commonPlayer[] tempPlayers = new commonPlayer[6]; 
     /**
     * add a new player to the list of players in the game, replacing the
     * specified player.
     */
    public void changePlayerList(commonPlayer p,commonPlayer replace)
    {	commonPlayer newpl[] = commonPlayer.changePlayerList(players,p,replace,false);
    	if(newpl==null) 
    		{ throw G.Error("No empty slot for player "+p); }
    	if(p!=null)
    	{	changeSpectatorList(null,p);	// remove from spectators list
    		p.addObserver(this);
    	}
    	commonPlayer.reorderPlayers(players);			// make sure the players are properly ordered before

    	resetBounds();
    }
/**
 * the player object which is "us", even if we are not a player but
 * a spectator.
 */
    private commonPlayer my = null;
	public commonPlayer getActivePlayer() {
		return my;
	}
	public void setActivePlayer(commonPlayer mypl) {
		my = mypl;
	}
    public String leftBarMessage = null; // message dictated by the overall frame
    public Color leftBarMessageColor = null;
    public boolean inLimbo = false;	   // true if we've been disconnected
    /**
     * normally, the game record is considered immutable during a game, but
     * becomes mutable by the players after the game is over.  What starts
     * as a regular game is never mutable by spectators.   What starts as
     * a game review is mutable by everyone.
    */
    public boolean reviewOnly = false; 		// if everyone is permanantly a reviewer
    /**
     * true if we're allowed to make changes in the game record
     */
    public boolean allowed_to_edit = false; 
    /**
     * gameover seen at some time
     */
    public boolean gameOver = false;
    /**
     * true if the game record is generally mutable by someone.  The distinction between
     * this and allowed_to_edit is that spectators after a game are not allowed to edit.
     */
    public boolean mutable_game_record = false;	
    /**
     * true if a game record has actually been branched
     */
    public boolean mutated_game_record = false;	
    /**
     * this is the official move history, as edited by editHistory.
     * This is used to display the game log, to replay the game,
     * and to produce .sgf game records.
     */
    public CommonMoveStack  History = new CommonMoveStack();	 
    /** this is the unedited, annotated history, which is kept to
     * help debug errors in the editing process.
     */
    public CommonMoveStack  rawHistory = new CommonMoveStack(); // unedited history
    /**
     * this is a collection of digests for the game
     * at various points, looking for 3 repetitions.
     */
    public RepeatedPositions repeatedPositions = new RepeatedPositions();
    
    /**
     * current index, always points to the piece that
     */
    public int jointReviewStep = -2; //the last transmitted review position
/*
     * a standard rectangle for the vcr control
     */
    public Rectangle vcrZone = addZoneRect("vcrZone");
    public Rectangle vcrRect = addRect(".vcrRect");
    public commonMove commentedMove = null;
    public commonMove commentedMoveSeen = null;
    /**
     * switch to the other player for the next move.
     */
    public void doPassMove()
    {	// not usually used in the game, but available in debugging situations to just toggle the player.
    	PerformAndTransmit(PASS);
    }
 
    // general strategy for mouse sensitivity.  Maintain the "HitPoint" object to indicate
    // what item is current under the mouse and clickable.  Most of the repainting operations
    // note when the paint over the hitpoint and display a highlighted version.  The
    // same functions, with a gc of null, don't paint anything but perform the logical 
    // operations so the hit point is noted.
    int gameLogScroll = 0;


    /**
     * locate a player which may be an active robot.  This is used in the user interface
     * to attach auxiliary display boards and also to find candidates to start, stop, or return moves.
     * THe default will always return the current player, but in games with simultaneous actions, 
     * this method can be overridden to return a non-current player which is a robot.
     * @return a player (which might or might not be a robot)
     */
    public commonPlayer currentRobotPlayer()
    {
    	commonPlayer who = whoseTurn();
    	if(who==null) { who=getActivePlayer(); }
    	return(who);
    }


/** this is called by the game controller when all players have connected
 * and the first player is about to be allowed to make his first move. This
 * may be a new game, or a game being restored, or a player rejoining a game.
 * You can override or encapsulate this method.
 */
    public void startPlaying()
    {	setUserMessage(Color.black,null);
    	started = true;
    	getBoard().checkClientRevision();
    	resetBounds();
    }

    /** returns true of x,y is in the first players's time clock.
     * this is intended as a hook for debugging hacks - it gives you
     * a place on the window to click to get a predicatable action.
     */
    public boolean inTimeRect(int eventX, int eventY)
    {	commonPlayer pl[] = players;	// called during setup, players may not be ready yet
    	boolean val = extraactions 
    					&& pl!=null
    					&& pl.length>0 ;
    					
    	if (val)
    	{
    	commonPlayer pl1 = pl[0];
    	Rectangle tr = pl1==null?null:pl[0].timeRect;
    	if((tr!=null) && tr.contains(eventX, eventY))
    	{
        System.out.println(formStoryString(false));
    	}}
        return (val);
    }
    public void doMouseTrackingInternal(commonPlayer player,commonPlayer[] plist,String zone,int inx,int iny,int ino)
    {   for(int pl = 0;pl<plist.length;pl++)
        {
        // make only one player the tracking player
        commonPlayer p = plist[pl];
        if(p==player) 
        { if(player!=getActivePlayer())
        	{ player.mouseTracking(zone,inx, iny, ino);
        	}
        }
        else if((p!=null)&&(ino!=NothingMoving)) 
        	{ p.mouseTrackingObject(NothingMoving); 
        	}
        }
    }
    
    public void doMouseTracking(commonPlayer player,String zone,int inx,int iny,int ino)
    {
    	doMouseTrackingInternal(player,players,zone,inx,iny,ino);
    	doMouseTrackingInternal(player,spectators,zone,inx,iny,ino);
     }
    /**
     * draw the players time clocks, using the standard black for the main clock
     * and blue for differential time.
     * @param gc
     */
    public void drawMice(Graphics gc)
    {
        for(commonPlayer p : players)
        {
            if(p!=null)
            {
            drawMouseSprite(gc, p);
            }
        }
       if(reviewOnly || mutable_game_record)
       {
    	 for(commonPlayer pl : spectators)
    	 {	
    	 	if(pl!=null)
    	 	{
   	 		drawMouseSprite(gc, pl);
    	 	}
    	 }
       }
    }

/** change or remove the user message
 * 
 */
    public void setUserMessage(Color color, String message)
    {
        if (((message != null) && !message.equals(leftBarMessage)) ||
                ((message == null) && (leftBarMessage != null)))
        {
            leftBarMessage = message;
            leftBarMessageColor = color;
            repaint(20);
        }
    }
/** set to true if the game controller is disconnected
 * 
 */
    public void setLimbo(boolean v)
    {
        inLimbo = v;
        if(v)
        	{ started = false; 
        	}
    }

    /** move the view of the game history back to a particular step.  The default inplementation
     * does this the simplest and dumbest way, by calling "doWayBack()" and then stepping
     * forward. For most circumstances this should be fine.  You can override this method
     * with a fancier or smarter UNDO if needed.
     */
    public void UndoStep(int target)
    {
        doWayBack(replayMode.Replay);
        while ((History.viewStep!=-1) 
        		&& (History.viewStep < target)
        		&& doForwardStep(replayMode.Replay))
        {
        }

        //showComments();
    }

    /** move the view of the game history all the way back to the beginning.
      * This could be implemented cleverly, but the simple and reliable method 
      * is to just reinialize the board.
     */
     public void doWayBack(replayMode mode)
    {	int sz = History.size();
        if (sz > 0)
        {   hidden.enterReviewMode();
        	if(mode!=replayMode.Replay)
        		{ showComments(); 	// save modified comments as a side effect
        		}
            doInit(true);	// reinitialize
            showComments();
            History.viewStep = 0;	// position 0
            commentedMove = commentedMoveSeen = null;
            if(reviewOnly) { theChat.clearMessages(true); }
            hidden.doForward(mode);	// the history is seeded with a start command
        }
    }
/**
 * set up the VCR cluster.  This rectangle should have a 2:1 aspect ratio.
 * the rectangle vcrZone will be set to this rectangle, and various internal
 * rectangles will be defined.
 * 
 * @param x
 * @param y
 * @param w
 * @param h
 */
    public void SetupVcrRects(int x,int y,int w,int h)
    {	int border = w/10;
    	int b2 = border/2;
        int h1 = (h - border) / 3;
        int btop = (h-3*h1-b2);
        // set up aux sliders too
        G.SetRect(vcrZone,x,y,w,h);
        hidden.normalVcrRect = null;
        G.SetRect(hidden.animationSpeedRect,G.Left(vcrZone)+border,G.Top(vcrZone)+border,w-border*2,h/2-border);
        G.SetRect(auxXRect,x+b2,y+btop,w-border,(int)(h1*0.8));
        G.SetRect(auxYRect,x+b2,y+btop+h1,w-border,(int)(h1*0.8));
        G.SetRect(auxSRect,x+b2,y+btop+h1*2,w-border,(int)(h1*0.8));

        G.SetRect(auxX2Rect,x+w+b2,y+btop,w-border,(int)(h1*0.8));
        G.SetRect(auxY2Rect,x+w+b2,y+btop+h1,w-border,(int)(h1*0.8));
        G.SetRect(auxS2Rect,x+w+b2,y+btop+h1*2,w-border,(int)(h1*0.8));
        int vtop =y+btop+2 + (h1 * 2);
        G.SetRect(vcrRect,x+b2, vtop,w-border,Math.min(h1,h-(y+h-vtop)));
        G.SetRect(hidden.vcrButtonRect,G.Left(vcrRect),G.Top(vcrRect) - G.Height(vcrRect),G.Width(vcrRect),G.Height(vcrRect));
        G.SetRect(hidden.vcrBackRect,G.Left(hidden.vcrButtonRect),
        			G.Top(hidden.vcrButtonRect) - G.Height(hidden.vcrButtonRect) - G.Height(hidden.vcrButtonRect)/6,
        			G.Width(hidden.vcrButtonRect) / 5,
        			G.Height(hidden.vcrButtonRect));
        G.SetRect(hidden.vcrVarRect,G.Right(hidden.vcrBackRect),G.Top(hidden.vcrBackRect),G.Width(vcrRect) - (2 * G.Width(hidden.vcrBackRect)),h1);
   
        G.SetRect(hidden.vcrFrontRect,G.Right(hidden.vcrVarRect),G.Top(hidden.vcrBackRect),
        		G.Width(hidden.vcrBackRect),G.Height(hidden.vcrBackRect));
        		
    }


/** draw the slider button in the standard VCR group, and/or notice if the
 * mouse is in the slider.
 * 
 * @param p					the mouse position or null
 * @param inG				the graphics or null
 * @return the hit object code
 * 
 */
  public CellId drawVcrSlider(HitPoint p, Graphics inG)
    {	//G.Assert(Thread.currentThread()==runThread,"running in the wrong thread");
        Rectangle r = vcrRect;
        int sliderWidth = G.Width(r)-G.Width(r)/6;
        CellId retval = null;
        HitPoint dp = getDragPoint();
        boolean inDrag = (dp!=null) && (dp.hitCode==VcrId.Slider);
        boolean inSlider = (p == null) 
        				? false 
        				: (p.dragging 
        						? (inDrag || (((p.hitCode==DefaultId.HitNoWhere) ||(p.hitCode==VcrId.Slider)) && G.pointInRect(p,G.Left(r),G.Top(r),sliderWidth,G.Height(r))))
        					    : ( ((p.hitCode==DefaultId.HitNoWhere) ||(p.hitCode==VcrId.Slider)) && 
        					   		G.pointInRect(p,G.Left(r),G.Top(r),sliderWidth,G.Height(r))));
        int barHeight = G.Height(r);
        int buttonWidth = barHeight+barHeight/3;
        int hsize = History.size();
        int size = Math.max(hsize + 10, 50);
        double step = (double)(sliderWidth-G.Width(r)/12)/ size;

        if (inG != null)
        {
            int sliderPos = (History.viewStep < 0) ? hsize : History.viewStep;

            //System.out.println("Size "+hsize+" Step "+step);
            if (inSlider && p.dragging && (p.hitCode==VcrId.Slider))
            {
                sliderPos = (int) Math.max(0,
                        Math.min(hsize-1, (G.Left(p) - G.Left(r)) / step));
            }
            commonMove m = (sliderPos >= hsize) ? null
                                                : (commonMove) History.elementAt(sliderPos);
            String str = (m == null) ? CurrentMoveString() : m.getSliderNumString();
            int sliderVal = (int) ( (step * sliderPos));
            {
            int w = sliderWidth;
            int h = G.Height(r);
            int xp = G.Left(r)+w/2;
            int yp = G.Top(r)+h/2;
            StockArt.VCRBar.drawChip(inG,this,w,xp,yp,null);
            }
            {
            int w = buttonWidth;
            int h = G.Height(r);
            int xp = G.Left(r) + sliderVal+w/2;
            int yp = G.Top(r) + h/2;
            StockArt.VCRTick.drawChip(inG,this,w+(inSlider?w/3:0),xp,yp,str);
            }
         }
        if (inSlider)
        {
            p.hitCode = retval = VcrId.Slider;
            p.dragging = p.down;
            if(p.down) { performVcrButton(retval, p) ; }
        }
        if(G.isCodename1()
        		&& (hidden.normalVcrRect==null)
        		&& (buttonWidth<G.minimumFeatureSize())
        		&& G.pointInRect(p,vcrZone))
        {
        	retval = VcrId.expandButton;
        }
        else if((hidden.normalVcrRect!=null)
        		&& !G.pointInRect(p,vcrZone)
        		&& G.pointInRect(p,hidden.outsideVcrRect))
        {
        	retval = VcrId.shrinkButton;
        }
        else {
        int w = G.Width(r)/6;
        int h = G.Height(r);
        int xp = G.Left(r)+sliderWidth+w/2;
        int yp = G.Top(r) + h/2;
        boolean inrect = G.pointInRect(p,xp-w/2,yp-h/2,w,h);
        if(inrect) { retval = VcrId.AnimateButton; }
        (animating?StockArt.VCRStop:StockArt.VCRPlay).drawChip(inG,this,w+(inrect?w/3:0),xp,yp,null);
        }

        return (retval);
    }
  
  public boolean missedOneClick = false;
  /**
   * call this to do the system standard actions that may be associated
   * with HitPoint.  These include scrolling actions generated by the
   * vcr controls, and "edit" and "done" buttons which use the default ids
   * and so on.  If "miss" is true, and the action is "HitNoWhere" then
   * performReset is called.
   * 
   * The "miss" functionality provides a "miss one click, do nothing, miss two clicks, reset" paradigm
   * @param hp
   * @return true if the reset action was not armed, but should be armed next time
   */
  public boolean performStandardActions
  	(HitPoint hp,	// @parm the HitPoint associated with the action
  	boolean miss)	// @parm if true, reset is enabled.
  {		CellId id = hp.hitCode;
  		boolean armed = false;
	  	if(performStandardButtons(id))  { }
	  	else if(performVcrButton(id, hp)) {  }
	  	else if(id ==GameId.HitNothing) { }
	  	else if(id == DefaultId.HitNoWhere) { if(miss) { performReset(); } else { armed = true;  }} 
	  	else 
	  	{	// this should only occur if there's a bug in the
	  		// standard widgets used in the UI
	  		throw G.Error("Hit unknown object ",hp);
	    }
	  	return(armed);
  }
  public boolean handleDoneButton(Graphics gc,Rectangle r,HitPoint p,Color highlightColor,Color backgroundColor)
  {		return handleDoneButton(gc,0,r,p,highlightColor,backgroundColor);
  }
  
  public boolean handleDoneButton(Graphics gc,double rotation,Rectangle r,HitPoint p,Color highlightColor,Color backgroundColor)
  {
	  //StockArt icon = p==null?StockArt.OffLight:StockArt.GreenLight;
	  //return(icon.drawChip(gc,this,r,p,GameId.HitDoneButton,s.get(ExplainDone)));
	  if(G.handleRoundButton(gc, rotation,r,p,s.get(DoneAction),highlightColor, backgroundColor))
	  {	  p.hitCode = GameId.HitDoneButton;
		  HitPoint.setHelpText(p,r,s.get(ExplainDone));
		  return(true);
	  }
	  return(false);
  }
  
  public boolean handleUndoButton(Graphics gc,Rectangle r,HitPoint p,Color highlightColor,Color backgroundColor)
  {		if(allowUndo())
	  	{return handleUndoButton(gc,0,r,p,highlightColor,backgroundColor);
	  	}
  		return(false);
  }
  
  public boolean handleUndoButton(Graphics gc,double rotation,Rectangle r,HitPoint p,Color highlightColor,Color backgroundColor)
  {
	  //StockArt icon = p==null?StockArt.OffLight:StockArt.GreenLight;
	  //return(icon.drawChip(gc,this,r,p,GameId.HitDoneButton,s.get(ExplainDone)));
	  if(G.handleRoundButton(gc, rotation,r,p,s.get(UndoAction),highlightColor, backgroundColor))
	  {	  p.hitCode = GameId.HitUndoButton;
		  HitPoint.setHelpText(p,r,s.get(ExplainUndo));
		  return(true);
	  }
	  return(false);
  }
  public boolean handlePleaseUndoButton(Graphics gc,double rotation,Rectangle r,HitPoint p,Color highlightColor,Color backgroundColor)
  {
	  //StockArt icon = p==null?StockArt.OffLight:StockArt.GreenLight;
	  //return(icon.drawChip(gc,this,r,p,GameId.HitDoneButton,s.get(ExplainDone)));
	  if(G.handleRoundButton(gc, rotation,r,p,s.get(UndoAction),highlightColor, backgroundColor))
	  {	  p.hitCode = GameId.HitPleaseUndoButton;
		  HitPoint.setHelpText(p,r,s.get(ExplainPleaseUndo));
		  return(true);
	  }
	  return(false);
  }

  public boolean handleEditButton(Graphics gc,Rectangle r,HitPoint p,HitPoint any,Color highlightColor,Color backgroundColor)
  {
	  return handleEditButton(gc,0,r,p,any,highlightColor,backgroundColor);
  }
  /**
   * @return true if it is ok to undo a current "pick" operation.
   */
  public boolean allowBackwardStep()
  {	BoardProtocol b = getBoard();
	return(b==null?false:b.movingObjectIndex()>=0);
  }
  /**
   * return true of it is ok to undo the most recent moves, and stop
   * at the most recent "done".
   * @return true if ok
   */
  public boolean allowPartialUndo()
  {		if(allowUndo())
  		{
	  	int op = getCurrentMoveOp();
	  	return((op!=MOVE_DONE) && (op!=MOVE_START) && (op!=MOVE_EDIT));
  		}
  		return(false);
  }
  public commonPlayer playerBeforeRobot()
  {
	  int idx = History.size()-1;
	  commonMove cm = getCurrentMove();
	  if(cm!=null)
	  {
	  commonPlayer robot = players[cm.player];
	  if(robot!=null && robot.isRobot)
	  {
	  while(--idx>0)
	  	{
		  commonMove m = History.elementAt(idx);
		  commonPlayer p = players[m.player];
		  if(p!=robot && !p.isRobot)
		  {
			  return(p);
		  }
	  	}
	  }}
	  return(null);
  }
  /**
   * This is normally determined by matching
   * the player at the top of the game record with the current player.  This
   * is only ok during normal play, not after endgame or while reviewing games. 
   * @return true if it is ok to undo the most recent moves back to where the turn changes to the another player
   */
  public boolean allowUndo() 
  {	if( !reviewMode()
		  && !simultaneous_turns_allowed())
  	{	commonMove m = getCurrentMove();
  		BoardProtocol b = getBoard();
  		return ((m!=null) 
  				&& (b!=null)
  				&& (m.op!=MOVE_START)
  				&& (offline() || (m.player==b.whoseTurn())));
  	}
  	return(false);
  }
  /**
   * decide if its' ok to undo a robot move.  By default it's
   * allowed in non-tournament unranked games.
   * @return
   */
  public boolean allowRobotUndo()
  {	if(unrankedMode && !tournamentMode) { return(true); }
	BoardProtocol b = getBoard();
  	int nplayers = b!=null ? b.nPlayers() : 0;
  	return(nplayers>2);
  }
  /**
   *  decide if we will actually give turn back to the opponent
   * @return true if it is ok
   */
  public boolean allowOpponentUndoNow() 
  { return( !(masterMode|tournamentMode));
  }
  
  /**
   * decide if to present the "undo" button when it's not
   * our turn. Normally this means we accidentally hit the 
   * final "done", and the other player hasn't started his
   * move yet.  By default, don't allow it in tournament
   * or master games, and if the robot is thinking about
   * a move, wait for it to finish.
   * @return
   */
   public boolean allowOpponentUndo()
  {
	  if( !reviewMode()
			  && allowOpponentUndoNow()
			  && !simultaneous_turns_allowed()
			  )
	  	{	commonMove m = getCurrentMove();
	  		// we will allow undo of the robot move if we're the player
	  		// before the robot, and various other conditions apply
	  		BoardProtocol b = getBoard();
	  		boolean canUndo = (m!=null) 
	  				&& !isRobotTurn() 
	  				&& (b!=null)
	  				&& ((allowRobotUndo() && (playerBeforeRobot()==my))	// previous move before robot was mine
	  					|| (m.player==my.boardIndex))	// previous move was mine
	  				&& (m.player!=b.whoseTurn())				// some other player's turn
	  				&& (m.op!=MOVE_START);
	  		return (canUndo);
	  	}
	  	return(false);
  }
  public boolean handleEditButton(Graphics gc,double rotation,Rectangle r,HitPoint p,HitPoint any,Color highlightColor,Color backgroundColor)
  {
	  //StockArt icon = p==null?StockArt.OffLight:StockArt.RedLight;
	  //return(allowed_to_edit && icon.drawChip(gc,this,r,p,GameId.HitEditButton,s.get(ExplainEdit)));
	  if((p!=null) && allowUndo())
	  {	  
	  	  commonPlayer pl = whoseTurn();
		  return handleUndoButton(gc,
				  	G.isApproximatelySquare(r)
				  		? pl.displayRotation
				  		:rotation,
				  	r,p,highlightColor,backgroundColor);
	  }
	  else if((any!=null) && allowOpponentUndo())
	  {
	  	  commonPlayer pl = my;
		  return handlePleaseUndoButton(gc,G.isApproximatelySquare(r) ? pl.displayRotation:rotation,r,any,highlightColor,backgroundColor);		  
	  }
	  else if(allowed_to_edit)
	  {if (G.handleRoundButton(gc, r, p,s.get(EditAction),highlightColor, backgroundColor))
		 	{
			 p.hitCode = GameId.HitEditButton;
			 HitPoint.setHelpText(p,r,s.get(ExplainEdit));
			 return(true);
		 	}
		 }
	  return(false);
  }
 /**
  * call this from your {@link #StopDragging} method to interpret
  * the standard buttons, such as "done" "edit" "start" "swap"
  * @param hitObject
  * @return true if the hitCode was handled
  */
    public boolean performStandardButtons(CellId hitObject)
    {  	String msg = null;
    	if(super.performStandardButtons(hitObject)) { return(true); }
    	if(hitObject instanceof GameId)
    	{
    	GameId ho = (GameId)hitObject;
    	switch(ho)
    	{
    	default: break;
    	case HitMagnifier:
    		{
    			if(getGlobalZoom()<MINIMUM_ZOOM)
    			{
    				setGlobalZoomButton();
    			}
    			else { setGlobalUnZoomButton(); }
    		}
    		return(true);
    	case HitZoomSlider: //global zoom
    		changeZoomAndRecenter(getGlobalZoom());
        	return(true);
    		
    	case ShowChat:
    		{
    			setSeeChat(true);
    		}
    		return(true);
    	case HideChat:
    		{
    			setSeeChat(false);
    		}
    		return(true);
    	case HitRulesButton:
    		{	String rules = sharedInfo.getString(exHashtable.RULES,null);
    			if(rules!=null)
    				{
    				URL u = G.getUrl(rules,true);
    				G.showDocument(u);
    				}
    		}
    		return(true);
    	case HitPleaseUndoButton:
       	case HitResignButton:
    	case HitEditButton:
     	case HitStartP1Button:
    	case HitStartP2Button:
    	case HitStartP3Button:
     	case HitStartP4Button:
    	case HitStartP5Button:
    	case HitStartP6Button:
     	case HitPassButton:
     	case HitSwapButton:
       	case HitDoneButton:
       	case HitUndoButton:
       	case HitOfferDrawButton:
       	case HitDeclineDrawButton:
       	case HitAcceptDrawButton:
    		msg = ho.shortName;
    		break;

    	}}
    	if(msg!=null) { PerformAndTransmit(msg); return(true); }
    	return(false);
    }
    
	  /**
     *  call this from your StopDragging method to handle the VCR control.
     * 
     * @param hitObject
     * @param hp
     * @return true if the hitObject was handled.
     */
    public boolean performVcrButton(CellId hitObject, HitPoint hp)
    {
        boolean rval = (hitObject instanceof VcrId);
        if(rval && hasControlToken())	// only actually do the scrolling if we have control
        {
        VcrId ho = (VcrId)hitObject;
        switch(ho)
        {
        case sliderAnimSpeedButton:
        	{	double newspeed = hidden.animationSpeedRect.value;
        		masterAnimationSpeed = Math.max(0,(2.0-newspeed));
        	}
			//$FALL-THROUGH$
		case sliderX2Button: { auxX2Rect.setValue(hp); } break;
        case sliderY2Button: { auxY2Rect.setValue(hp); } break;
        case sliderS2Button: { auxS2Rect.setValue(hp); } break;
        case sliderXButton:  { auxXRect.setValue(hp);  } break;
        case sliderSButton:  { auxSRect.setValue(hp);  } break;
        case sliderYButton:  { auxYRect.setValue(hp);  } break;
        case BackButton:
        	{
        	doScrollTo(BACKWARD_NEXT_BRANCH);
            jointReviewStep = GET_CURRENT_POSITION;
        	}
        	break;
        case VarButton:
        	{
            doVcrVar();
            jointReviewStep = GET_CURRENT_POSITION;
        	}
        	break;
        case FrontButton:
        	{
            doScrollTo(FORWARD_NEXT_BRANCH);
            jointReviewStep = GET_CURRENT_POSITION;
        	}
        	break;
        case WayBackButton:
        	{
            doScrollTo(BACKWARD_TO_START);
            jointReviewStep = GET_CURRENT_POSITION;
        	}
        	break;
       case BackStepButton:
        	{
            doScrollTo(BACKWARD_ONE);
            jointReviewStep = GET_CURRENT_POSITION;
        	}
        	break;
        case ForeStepButton:
        	{
             doScrollTo(FORWARD_ONE);
            jointReviewStep = GET_CURRENT_POSITION;
        	}
        	break;
        case ForeMostButton:
        	scrollFarForward();
        	break;
        case ForePlayerButton:
        	{
         	doScrollTo(FORWARD_PLAYER);
        	}
        	break;
        case BackPlayerButton:
        	{
        	doScrollTo(BACKWARD_PLAYER);
        	}
        	break;
        case Slider:
        	{
            doVcrSlider(hp);
            jointReviewStep = GET_CURRENT_POSITION;
        	}
        	break;
        case AnimateButton:
        	{
        	animating = !animating;
        	if(!reviewMode()) { doWayBack(replayMode.Single); }
        	generalRefresh();
        	}
        	break;
        case expandButton:
        	if(hidden.normalVcrRect==null) 
        		{ hidden.normalVcrRect = (Rectangle)G.clone(vcrZone); 
        		}
        	Rectangle old = hidden.normalVcrRect;
        	int fr = G.Right(fullRect);
        	int fb = G.Bottom(fullRect);
        	int oldH = G.Height(old);
        	int oldW = G.Width(old);  		  	
  		  	int rw = oldW*2;
  		  	int rh = oldH*2;
 		  	int rl = Math.min(fr-rw,Math.max(0, G.Left(old)-oldH/2));
  		  	int rt = Math.min(fb-rh,Math.max(0, G.Top(old)-oldW/2));     	
        	SetupVcrRects(rl,rt,rw,rh);   		  	
        	hidden.normalVcrRect = old;
  		  	hidden.outsideVcrRect = new Rectangle(rl-oldW/2,rt-oldH/2, rw+oldW, rh+oldH);
        	break;
        case shrinkButton:
        	SetupVcrRects(G.Left(hidden.normalVcrRect),G.Top(hidden.normalVcrRect),
        			G.Width(hidden.normalVcrRect),G.Height(hidden.normalVcrRect));
        	break;
        case noVcrButton:
        	break;
        default:
        	throw G.Error("Hit unknown vcr token "+hitObject);
        	}
        }
        return (rval);
    }
    public void scrollFarForward()
    {
    	LogMessage("scroll far forward");
        doScrollTo(FORWARD_TO_END);
        jointReviewStep = -2;	
    }
    public void leaveLockedReviewMode()
    { if( reviewMode()			// and may not even realize it.
    	  && !mutable_game_record
    	  && !getActivePlayer().spectator) 
    		{ scrollFarForward(); }
    }
    
  /**
 * call this from your {@link #redrawBoard} method to draw the
 * vcr control.
 * @param p
 * @param inG
 * @return the hit code for the subbutton hit
 */
    public CellId drawVcrGroup(HitPoint p, Graphics inG)
    {  	
    	if(G.Height(noChatRect)>0) { drawNoChat(inG,noChatRect,p); }	// magically draw the chat/nochat button
    	int artHeight = G.Height(vcrZone);
    	int artX = G.Left(vcrZone);
    	int artWidth = G.Width(vcrZone);
    	int artY = G.Top(vcrZone);
    	StockArt artObj = StockArt.VCRFrame;
    	if(!mutable_game_record && !animating)
    	{   if(reviewMode()) 
    		{
    		G.setFont(inG,largeBoldFont());
    		G.Text(inG, true, artX,artY,artWidth,artHeight/3,Color.blue,null,Reviewing);
    		}
    		else 
    		{artY = artY+artHeight/3;
    		artHeight = artHeight - artHeight/3;
    		artObj = StockArt.VCRFrameShort;
    		}
     	}
    		artObj.drawChip(inG,this,G.Width(vcrZone),
    			G.centerX(vcrZone),
    			artY+artHeight/2,
    			null);

    	if(/*!hasControlToken() ||*/	// if this is on, the vcr goes blank when you can't drive.
    									// it's informative, but I decided it's annoying
    			(mutable_game_record && !allowed_to_edit)) 
    		{	// after a game, spectators are allowed to see the players talk over
    			// the game, but are not allowed to "drive".  It's important that they
    			// don't also change the view
    			//p=null; 
    			//
    			// keep the mesa, but don't draw any controls
    			//
    			return(DefaultId.HitNoWhere);
    		}
    	CellId rval = DefaultId.HitNoWhere;
    	
        if(useAuxSliders)
    	{	auxXRect.draw(inG,p);
    	    auxYRect.draw(inG,p);
    	    auxSRect.draw(inG,p);
    	    auxS2Rect.draw(inG,p);
    	    auxX2Rect.draw(inG,p);
    	    auxY2Rect.draw(inG,p);
    	}
    	else {

        if(animating)
        { rval =  DefaultId.HitNoWhere;
          hidden.animationSpeedRect.draw(inG,p,s);
          if(p!=null) { rval = p.hitCode; }
          
         }
        else if(p==null || p.hitCode!=VcrId.Slider)
        	{ rval = hidden.drawVcrButtons(p, inG); // button bar
        	}
        CellId tval = drawVcrSlider(p,  inG);
        if (tval != null)
        {
            rval = tval;
        }
        if(!animating)
        {
        if (mutable_game_record ) 
        {	boolean isin = G.pointInRect(p, hidden.vcrBackRect);
        	int w = G.Width(hidden.vcrBackRect);
        	int h = G.Height(hidden.vcrBackRect);
        	int xp = G.Left(hidden.vcrBackRect) + w/2;
        	int yp = G.Top(hidden.vcrBackRect) + h/2;
        	StockArt.VCRBackBranch.drawChip(inG,this,w+(isin?w/3:0),xp,yp,null);
        	if(isin)
        		{
        		rval = VcrId.BackButton;
        		}
        }
 
        if (reviewMode() && mutable_game_record)
        {
            int vv = History.viewStep;
            commonMove m = ((vv<History.size())&&(vv > 0)) 
            						? (commonMove) History.elementAt(vv - 1)
                                    : null;
            int n = (m == null) ? 1 : m.nVariations();
            String txt = s.get(ChoiceString,n);
            {
            boolean isin = G.pointInRect(p, hidden.vcrVarRect);
            int w = G.Width(hidden.vcrVarRect);
            int h = G.Height(hidden.vcrVarRect);
            int xp = G.Left(hidden.vcrVarRect) + w/2;
            int yp = G.Top(hidden.vcrVarRect) + h/2;
            G.setColor(inG,isin?Color.white:Color.black);
            StockArt.VCRButton.drawChip(inG,this,w,xp,yp,txt);
            if(isin)
            {
                rval = VcrId.VarButton;
            }}
            {
            boolean isin = G.pointInRect(p,hidden.vcrFrontRect);
            int w = G.Width(hidden.vcrFrontRect);
            int h = G.Height(hidden.vcrFrontRect);
            int xp = G.Left(hidden.vcrFrontRect) + w/2;
            int yp = G.Top(hidden.vcrFrontRect) + h/2;
            StockArt.VCRForwardBranch.drawChip(inG,this,w+(isin?w/3:0),xp,yp,null);
            if (isin)
            {
                rval = VcrId.FrontButton;
            }}}

        }

        if ((p!=null) && (rval != null))
        {   p.hitCode = rval;
            if(p.down && (rval==VcrId.Slider)) { p.dragging=true; }
        }
    	}
        if(!allowedToScroll()) 
        	{ rval = DefaultId.HitNoWhere; 
        	}
        return (rval);
    }

   /**
     * This is called to present a menu of alternatives when the "n choices" button is pressed.
     */
    public void doVcrVar()
    {
        int sliderPos = (History.viewStep < 0) ? (-1) : (History.viewStep - 1);

        if ((sliderPos<History.size()) && (sliderPos >= 0))
        {	LogMessage("select variation");
            commonMove m1 =History.elementAt(sliderPos);
            m1.variationsMenu(hidden.vcrVarPopup,this,deferredEvents);
            //this.add(vcrVarMenu);
            //vcrVarMenu.addActionListener(deferredEvents);
            hidden.vcrVarPopup.show( G.Left(hidden.vcrFrontRect), G.Top(hidden.vcrFrontRect));
        }
    }
    public GameLayoutManager selectedLayout = new GameLayoutManager();
    /**
     * this is called to display the rectangle grid while debugging layouts.
     */
    public void showRectangles(Graphics gc, int cellsize)
    {	if(show_rectangles)
    	{
	    	for(int i=0;i<players.length;i++) 
	    	{ commonPlayer pl = players[i];
	    	  if(pl!=null) { pl.addRectangles(this,i); }
	    	}
    	if(selectedLayout!=null)
    	{
    	//	G.fillRect(gc,Color.darkGray,fullRect);
    		Rectangle main = selectedLayout.getFullMainRectangle();
    		if(main!=null) { G.fillRect(gc, Color.lightGray,main); }
    		RectangleStack rects = selectedLayout.rects.spareRects;
    		for(int i=0;i<rects.size();i++) 
    			{ Rectangle r = rects.elementAt(i);
    			  G.fillRect(gc, new Color(0xff&(i*10),0xff&(i*20),0xff), r);
    			  G.frameRect(gc, Color.green,G.Left(r),G.Top(r),G.Width(r),G.Height(r));
    			}
       	}}
       	super.showRectangles(gc,cellsize);
    }
    /**
     * This is called to display the current move's associated comments, in the chat window.
     */
    public void showComments()
    {
        //System.out.println("Save for "+commentedMove+" show for "+m);
    	//
    	// this behavior is intended for generating commented files, but in multi-player
    	// contexts it creates a lot of confusion testing the number of connections tweaks
    	// the behavior to be the "right thing" 7/2015
    	//
        if (reviewOnly && (numberOfConnections()<=1))	
        {
            commonMove m = hidden.currentHistoryMove();
            if(m!=null)
            {
            String newMessage = m.getComment();	
            String currentMessage = theChat.getMessages();
            
            if(commentedMove!=null)
            {	String currentComment = commentedMove.getComment();
            	boolean same = currentMessage.equals(currentComment);
            	if(!same && (commentedMoveSeen!=null))
            		{
            		commentedMove = commentedMoveSeen;
            		}
            	if(!same)
            		{ commentedMove.setComment(currentMessage); 
            		}
            }
            else if ((commentedMoveSeen!=null) && (currentMessage!=null) && !"".equals(currentMessage))
            {
            	commentedMoveSeen.setComment(currentMessage);
            	commentedMove = commentedMoveSeen;
            }
            if(!"".equals(newMessage) && (newMessage!=null))
            {
            commentedMove = m;
            theChat.clearMessages(true);
            commentedMoveSeen = m;
            theChat.setMessage(newMessage);
            }
            else 
            { if(commentedMoveSeen==null) { theChat.clearMessages(true); }
              commentedMoveSeen = m;
            }
            }
        }
    }


    public void chooseVcrVar(commonMove command) // select a succesor for the current move
    { // command will be a selection from a menu, which are the descriptions of the successor moves
        int sliderPos = (History.viewStep < 0) ? (-1) : (History.viewStep - 1);

        if ((sliderPos<History.size()) && (sliderPos >= 0)) // only if we're still in review mode
        {
            commonMove m1 = History.elementAt(sliderPos);
            commonMove m = m1.findVariation(command);
            LogMessage("selected variation is "+command);
            if (m != null)
            {	if(m1.next == m) 
            		{ hidden.doForward(replayMode.Replay); }
            		else {  PerformAndTransmit(m.moveString(), true,replayMode.Replay); }
            }
        }
    }
    public void doVcrSlider(Point hitPoint)
    {
        if (hitPoint != null)
        {
            int width = G.Width(vcrRect)-G.Width(vcrRect)/6-G.Width(vcrRect)/12-6;
            int x = G.Left(hitPoint) - 3 - G.Left(vcrRect);
            int size = Math.max(History.size() + 10, 50);
            double step = (double) width / size;
            int newpos = (int) (x / step);
        	LogMessage("scroll to "+newpos);
            doScrollTo(newpos);
        }
    }
    
  
    public boolean isRobotTurn()
    {
    	commonPlayer p = whoseTurn();
    	return( p!=null && p.isRobot); 
    }

    /**
     * Undo all of the current player's actions.
     * don't call this directly from game code - your game history will get out of sync.
     * instead use PerformAndTransmit("Undo");  You may superceed or wrap it to change
     * the behavior
     */
   public void doUndo()
    {  	
    	do {
    		doScrollTo(BACKWARD_ONE) ;
    		truncateHistory(); 
    	} while(allowPartialUndo());
    }
    /**
     * Undo 1 game step.
     * don't call this directly from game code - your game history will get out of sync.
     * instead use PerformAndTransmit("AllowUndo");  You may superceed or wrap it to 
     * change behavior.
     */
    public void doUndoStep()
    {	do {
    	doScrollTo(BACKWARD_ONE);
    	truncateHistory();
    	} while (allowBackwardStep());
    }
    public boolean doBackwardPlayer()
    {
		BoardProtocol bd =  getBoard();
    	if(bd!=null)
    	{
    	int who =bd.whoseTurn();
		while((bd.whoseTurn()==who) && doScrollTo(BACKWARD_ONE)) {};
		while((bd.whoseTurn()!=who) && doScrollTo(BACKWARD_ONE)) {};
		return(hidden.doForward(replayMode.Replay));
    	}
    	return(false);
    }
    public void doForwardPlayer()
    {
    	BoardProtocol bd =  getBoard();
    	if(bd!=null)
    	{
		int who =bd.whoseTurn();
		while((bd.whoseTurn()==who) && hidden.doForward(replayMode.Single)) {};
    	}
    }
    public boolean doForward(replayMode replay)
    {
    	return(hidden.doForward(replay));
    }
    
    /**
     * scroll to a particular move number, or to one of the
     * special positions indicated by negative codes.
     */
    public boolean doScrollTo(int val)
    {	boolean rval = false;
        int vs = History.viewStep;
        rawHistory.addElement(new dummyMove("vcr:@"+vs+" doScrollTo "+val));
        switch (val)
        {
        case BACKWARD_ONE:
           	LogMessage("scroll back 1");
            rval = hidden.doBack(1);
            break;

        case FORWARD_ONE:
           	LogMessage("scroll forward 1");
            rval = hidden.doForward(replayMode.Single);
            break;
        case BACKWARD_DONE:
        	LogMessage("scroll backward player");
    		{
    		BoardProtocol bd =  getBoard();
    		commonMove m = hidden.currentHistoryMove();
    		if((m!=null) && (m.op==MOVE_DONE)) { doScrollTo(BACKWARD_ONE); }
    		if(bd!=null)
    		{
        	int who =bd.whoseTurn();
        	while( ((m=hidden.currentHistoryMove())!=null)
        			&& (m.op!=MOVE_DONE) 
        			&& (bd.whoseTurn()==who) && doScrollTo(BACKWARD_ONE))
        		{  }
    		}}
    		break;
        case BACKWARD_PLAYER:
        	LogMessage("scroll backward player");
        	rval = doBackwardPlayer();
        	break;
        case FORWARD_PLAYER:
           	LogMessage("scroll froward player");
        	doForwardPlayer();
        	break;
        case FORWARD_NEXT_BRANCH:

        	LogMessage("scroll 	forward-branch");
         // scroll forward to the next branch
            while (hidden.doForward(replayMode.Replay))
            {
                int pos = getReviewPosition();

                if (pos <= 0)
                {
                    break;
                }

                commonMove m = History.elementAt(pos - 1);

                if (m.nVariations() > 1)
                {
                    break;
                }
            }

            break;

        case BACKWARD_NEXT_BRANCH:
           	LogMessage("scroll backward-branch");

            // scroll backward to the next branch
           	while (hidden.doBack(1))
            {
                int pos = getReviewPosition();

                if (pos <= 0)
                {
                    break;
                }

                commonMove m = History.elementAt(pos - 1);

                if (m.nVariations() > 1)
                {
                    break;
                }
            }

            break;

        case BACKWARD_TO_START:
        	LogMessage("scroll wayback");

            // all the way back
            doWayBack(replayMode.Single);
            break;

        default:

        	showComments();	// save modified comments as a side effect
        	int initialPosition = getReviewPosition();
            int hsize = History.size();
            if (initialPosition == -1)
            {	initialPosition = hsize;
                if(val<initialPosition) { hidden.enterReviewMode(); }
            } 
            if (val == -1)
            {	val = hsize;
            } //prepare to leave review mode
            val = Math.min(val, hsize);

            
			// scroll to a position (if back)
            {
            if(initialPosition!=val)
            {
            int pos;
			while (( (pos=getReviewPosition()) > val) && hidden.doBack(pos-val))
            { // doBack does it all
            }
			//	scroll to a position (if forward)
            while ((getReviewPosition() < val) && hidden.doForward(replayMode.Replay))
            { // doforward does it all
            	commentedMoveSeen = commentedMove = null;
            	showComments();
            }}}

            break;
        }
        
        if(val==History.size()) { History.viewStep = -1; val=-1; }
               
        if( ((vs==-1) && (History.viewStep!=-1))
        		|| ((History.viewStep==-1) && (vs!=-1)))
        	{ generalRefresh(); 
        	}
        	else if(rval) { repaint(20); }
        
      
       return (rval);
    }

    /**
     *  reviewMode is true only if we are NOT at the end
       of the current variation.
    */
    public boolean reviewMode()
    {
        return (History.viewStep >= 0);
    }
    /**
     * get the current review position.  This is used to synchronize multiple clients.
     */
    public int getReviewPosition()
    {
        return (History.viewStep);
    }

    /** set the desired common review position
     * 
     */
    public void setJointReviewStep(int v)
    {
        jointReviewStep = v;
    }
/**
 * get the desired joint review position
 */
    public int getJointReviewStep()
    {
        return (jointReviewStep);
    }
       

    public void RedoStep(replayMode mode)
    {
        int vs = History.viewStep;
        commonMove m = History.elementAt(vs++);
        if (vs >= History.size())
        {
            vs = -1;
        }
        History.viewStep = vs;
        hidden.RedoStep(mode,m);
    }
    
    
    public boolean doForwardStep(replayMode mode)
    {
        int size = History.size();

        if ((History.viewStep >= 0) && (History.viewStep < size))
        {
            RedoStep(mode);
            boolean notAtEnd = (History.viewStep >= 0);
            if(!notAtEnd || (mode!=replayMode.Replay)) { showComments(); }
            if(notAtEnd) { return notAtEnd; }
        }

        History.viewStep = -1;
        generalRefresh();
        return (false);
    }
    // do a forward step but skip "pick" moves so animations run
    // more smoothly.
    public boolean doForwardAnimationStep(replayMode replay)
    {
    	boolean v = doForwardStep(replay);
    	if(!v && getBoard().movingObjectIndex()>=0) { v = doForwardStep(replay); }
    	return(v);
    }
    /**
     * movement style for an animation.
     * <li>{@link #Chained} chained movement of a piece or stack from one dest to the next</li>
     * <li>{@link #Simultaneous} everything moves at the same time</li>
     * <li>{@link #Stack} everything moves at the same time, as a stack</li>
     * <li>{@link #StackFromStart} sequential stacks start one at a time, but launch sequentially</li>
     * <li>{@link #Sequential} pieces move separately, one at a time.</li>
     * <li>{@link #SequentialFromStart} pieces start at the same time but launch sequentially
     * @author Ddyer
     *
     */
    public enum MovementStyle 
    	{ 
    	  Chained,		/** chained movement of a single piece or a stack of pieces */
    	  Simultaneous, /** everything moves at the same time */
    	  Stack,		/** everything moves at the same time, as a stack */
    	  StackFromStart, /** sequential stacks start one at a time, but launch sequentially */
    	  Sequential,	/** pieces move separately, one at a time. */
    	  SequentialFromStart,	/** pieces start at the beginning but launch sequentially.  This is useful for standing targets. */
    	}
    /**
     * start animations from animationStack.  In this version, if there
     * are multiple animations, depending on the value of "serially", they
     * are all started at once, or they are chained from first to last.
     * If serially, the last cell is the final hop where the chip lives
     * and the animation hops from the first to last. 
     * @param replay
     * @param animationStack
     * @param size
     * @param groupMovement
     */
    public void startBoardAnimations(replayMode replay,OStack<?>animationStack,int size,MovementStyle groupMovement)
    {	try {
    	boolean chained = (groupMovement==MovementStyle.Chained);
    	boolean stack = (groupMovement==MovementStyle.Stack)||(groupMovement==MovementStyle.StackFromStart);
    	boolean sequential = (groupMovement==MovementStyle.Sequential)||(groupMovement==MovementStyle.SequentialFromStart);
    	boolean fromStart = (groupMovement==MovementStyle.SequentialFromStart)||(groupMovement==MovementStyle.StackFromStart);
    	if(replay!=replayMode.Replay)
    	{	double start = 0.0;
    		cell <?> lastDest = null;
    		int depth = 0;
    		double lastTime = 0;
    		for(int idx = 0,lim=animationStack.size()&~1; idx<lim;idx+=2)
    		{
			cell<?> from = (cell<?>)animationStack.elementAt(idx);		// source and destination for the move
 			cell<?> to = (cell<?>)animationStack.elementAt(idx+1);
 			G.Assert(from!=null || !G.debug(),"animation stack item shouldn't be null");
 			G.Assert(to!=null || !G.debug(),"animation stack item shouldn't be null");
 			if(sequential || ((chained||fromStart) && ((to!=lastDest) || ((lastDest!=null) && lastDest.forceSerialAnimation()))))
 					{
 					// step to the next starting time if we change dests
 					start += lastTime;
 					}
 			depth = (to==lastDest) ? depth+1 : 0; 
 			// if serially, the moving object is the chip on top of the last
 			// destination, and it moves from the first source to last in 
 			// multiple steps.
 			cell<?>from0 = (chained ? (cell<?>)animationStack.top() : to);
 			G.Assert(from0!=null || !G.debug(),"animation stack item shouldn't be null");
    		Drawable moving = from0==null ? null : from0.animationChip(depth);
    		if(moving!=null)
				{
        		int animationSize = from0.animationSize(size);
    			int d = (chained|stack)?depth:-1;
    			if(fromStart && (start>0.0))
    			{
    			// the subsequent steps start by standing on the origin until their
    			// turn.  This works for zertz captures for example, where the jumping
    			// ball jumps, then the captured ball moves off.
    			SimpleSprite anim = startAnimation(from,from,moving,animationSize,0,start,d);
    			if(chained) { anim.isAlwaysActive=true; }
    			}
    			SimpleSprite anim = startAnimation(from,to,moving,animationSize,start,0,d);	// start it
    			if(anim!=null)	// be defensive
    			{
    			if(chained) { anim.isAlwaysActive = true; }
				lastTime = anim.getDuration();
				}}
    		lastDest = to;
   
    		}
    	}
    	}
    	finally {
       	animationStack.clear();
    	}
    }    
/**
 * start an animation step in the simplest way.  
 * @param from	the source cell
 * @param to	the destination cell
 * @param top	the chip to draw
 * @param size	the size of the chip (ie; squaresize)
 * @param start the start time in seconds relative to the start of this animated sequence (0=start of this animation sequence)
 * @param duration in seconds of this animation.  If 0, scale to the distance moved
 * @return the sprite returned
 */
    public SimpleSprite startAnimation(cell<?> from,cell<?> to,Drawable top,int size,double start,double duration)
    {
    	return startAnimation(from,to,top,size,start,duration,-1);
    }
    /**
     * adjust the size of this particular drawable for animation ending at some cell
     * @param dest
     * @param chip
     * @param sz
     * @return
     */
    public int adjustAnimationSize(cell<?>dest,Drawable chip,int sz)
    {
    	return(sz);
    }
    /**
     * 
 * start an animation step in the simplest way.  
 * @param from	the source cell
 * @param to	the destination cell
 * @param top	the chip to draw
 * @param size	the size of the chip (ie; squaresize)
 * @param start the start time in seconds relative to the start of this animated sequence (0=start of this animation sequence)
 * @param duration in seconds of this animation.  If 0, scale to the distance moved
 * @return the sprite returned
     */
    public SimpleSprite startAnimation(cell<?> from,cell<?> to,Drawable top,int size0,double start,double duration,int depthm1)
    {	if((from!=null) && (to!=null) && (top!=null))
    	{	int depth = Math.max(0, depthm1);
    		int size = adjustAnimationSize(to,top,size0);
    		boolean randomize = depthm1<0;
    		int tox = to.animationChipXPosition(depth);
    		int fromx = from.animationChipXPosition(depth);
    		int toy = to.animationChipYPosition(depth);
    		int fromy = from.animationChipYPosition(depth); 
    		double rot =to.activeAnimationRotation();
     		if(G.debug())
    		{
    			G.Assert((fromx|fromy)!=0,"From Cell %s center is not set",from);
       			G.Assert((tox|toy)!=0,"To %s center is not set",to);
    		}
    		double end = duration;
    		// make time vary as a function of distance to partially equalize the runtime of
    		// animations for long verses short moves.
     		if(end==0)
     		{	double speed = masterAnimationSpeed*(G.debug()?10:1);
     	   		double dist = G.distance(fromx, fromy, tox,  toy);
        		double full = G.distance(0,0,G.Width(boardRect),G.Height(boardRect));
        		end = Math.sqrt(2*speed*dist/full);
     		}
    		SimpleSprite newSprite = new SimpleSprite(randomize,top,
    				size,		// use the same cell size as drawSprite would
    				start,end,
            		fromx,fromy,
            		tox,toy,rot);
    		newSprite.movement = Movement.SlowIn;
            to.addActiveAnimation(newSprite);
  			addSprite(newSprite);
  			return(newSprite);
  			}
    	return(null);
    }
    
    // set comments on moves as they are being replayed from
    // a sgf file.
    public void setComment(String str)
    {	int siz = History.size();
    	commonMove m =   siz>0 ?       History.elementAt(siz - 1) : null;
    	if (m != null)
    	{
    		m.setComment(str);
        }
    }
    /**
     * get the current move at the end of the move history.
     * this may return NULL under rare circumstances
     * @return
     */
    public commonMove getCurrentMove()
    {
    	return(hidden.currentHistoryMove());
    }
    /**
     * get the opcode of the current move.  This will return MOVE_START if
     * the move history is empty
     * 
     * @return
     */
    public int getCurrentMoveOp()
    {
    	commonMove m = getCurrentMove();
    	if(m!=null) { return(m.op); }
    	return(MOVE_START);		// nothing there yet, claim the start
    }
    /**
     * This is how events such as
     * mouse clicks are transmitted to the local board.
     * If "playsounds" is true (and other sound-related flags
     * permit) then game sounds are also played.
     * 
     * @param m
     * @param replay true if we are from a single step forward
     * @return true if successful
     */
     public abstract boolean Execute(commonMove m,replayMode replay);
    
     /**
      * parse a string toto a move spec.  As a debugging aid, the parsed
      * string is printed and reparsed.
      * @param str	a move string
      * @param player the player to parse for (ie, the current player)
      * @return a parsed move
      */
    public commonMove ParseMove(String str, int player)
    {	commonMove m = ParseNewMove(str, player);
    	if(G.debug())
    		{ String ms = m.moveString();
    		  commonMove m1 = ParseNewMove(ms, player);
    		  // attempt to print/reparse the result, so we have some assurance
    		  // that live use will match offline use.
    		  String m1s = m1.moveString();
    		  if(!m1s.equals(ms))
    		  {	System.out.println("Probable parse/print error in moveString(); "+str+" becomes "+m1s); 
    		  }
    		}
    	return(m);
    }

    /**
     * parse and execute the string.  This seemingly inefficient
     * process assures that what we send over the web will be interpreted
     * identically to what we do locally.  Also, if ParseMessage trips
     * any illegal-move type errors, which shouldn't occur by "shit happens"
     * we will never get to adding to the even queue
      * @param str
     * @param transmit
     * @param mode  replay mode, which advises auxiliary behavior such as sound and animation
     * @return true if successful
     */
 public boolean PerformAndTransmit(String str, boolean transmit,replayMode mode)
 {
     // used in different contexts; parsing live moves from the GUI
     // also parsing replayed moves when resuming a game
     int player = ((mode!=replayMode.Replay) && simultaneous_turns_allowed())
   		  		? getActivePlayer().boardIndex
   		  		: getBoard().whoseTurn();
   	return(PerformAndTransmit(str,player,transmit,mode));

 }
/*
 * 
 */
 public boolean PerformAndTransmit(String str, int player,boolean transmit,replayMode mode)
 { 
      lastParsed = str;
      commonMove m = ParseMove(str,player);
      if(m!=null)
        {
	        if (!PerformAndTransmit(m, transmit,mode))
	        {
	        	throw G.Error("can't perform " + str);
	        }
        }
        else
        { throw G.Error("Can't parse "+str);
        }
        lastParsed=null;
        //G.startLog("Move "+str);
        repaint();
        return (true);
    }
    
    public String errorContext()
    {	String sup = super.errorContext();
    	if(lastParsed!=null) { sup += "{LastParsed: "+lastParsed+"}"; }
    	return(sup);
    }
    public void undoToMove(commonMove m)
    {
    	if(m.index()>0)
    		{ rewindHistory(m.index());
    		  truncateHistory();
    		}
    }
    /**
     * perform and optionally transmit a move, return true if ok.  Note, it's tempting
     * to do any "auto move" that is needed in the continuation of this method, but don't.
     * Doing so may separate the "perform" from the "transmit" which will lead to other
     * players seeing the events out of order.  Instead, use the continuation of ViewerRun
     * @param m
     * @param transmit
	 * @param mode replay mode
     * @return true if successful
     */

    public boolean PerformAndTransmit(commonMove m, boolean transmit,replayMode mode)
    {	//G.print("e "+my+" "+m);
    	if(transmit && (m.op!=MOVE_PLEASEUNDO) && G.debug())
    	{ G.Assert(reviewOnly || mutable_game_record || !reviewMode(),
    			"can't send moves during in-game review"); 
    	}
       if ((m.index()>=0)||(History.viewStep>0))  // maybe backed up
       {   // something delicate here.  m.index=-1 for newly input moves
    	   // moves being replayed may have an index, in which case their position 
    	   // in the history is fixed. The replayers can add optional "done" moves
    	   // which are immediately followed by real done moves which superceed them.
            rewindHistory((m.index()>0)? m.index() : History.viewStep);
       } 
       	String str = m.moveString(); 
       		// collect the spec before executing or adding to history, so that
       		// edits made to m by execute or editHistory will not be transmitted
       
      	if(m.op==MOVE_PLEASEUNDO)
       	{	// this when we hit the undo button, and we need to 
       		// pass the request to the opponent.
       		commonPlayer p = whoseTurn();
       		if(p!=my)
       			{ if(transmit) { addEvent(str); }}	// out of turn undo
       		else if(allowOpponentUndoNow()) 
       			{ PerformAndTransmit(UNDO_ALLOW); 
       			}
       		return(true);	// we did it
       	}
       	else if (Execute(m,mode))
        {
        	repaint(20);					 // states will have changed.
            
            boolean added = AddToHistory(m);
            
            // this is the active part of the "Start Evaluator" feature
            if (extraactions && (getActivePlayer().robotPlayer != null))
            {	// get the robot to static eval this position
                //getActivePlayer().robotPlayer.StaticEval();
            }
 
            if(added)
            	{ // this is later than originally placed, so the repetition check
            	  // takes place only after the current move is sure to be added.
            		BoardProtocol bd = getBoard();
                 	m.setDigest(bd.Digest());
                 	m.setGameover(false);
                 	repeatedPositions.checkForRepetition(bd,m);
            		long newdig = bd.Digest();
            		if(newdig!=m.digest())
            			{ m.setGameover(true); 
            			  // use the new digest (hive, game over by repetition)
            			  m.setDigest(newdig);
            			} 
            	}
            if(mode==replayMode.Live) { verifyGameRecord(); }
            if (transmit && (allowed_to_edit || !getActivePlayer().spectator))
            {	if(added) { str = "+T "+m.elapsedTime()+" "+str; }	// add the move time stamp
                addEvent(str);
            }
            if((mode==replayMode.Live) && playerChanging()) { playTurnChangeSounds(); }
            return (true);
        }
        return (false);
    }

    /**
    * handle Execute in the standard way, which includes 
    * recording potential repetitions and checking for
    * draws by repetition and checking for game over.
    *
     * @param b
     * @param m
     */
    public void handleExecute(BoardProtocol b,commonMove m,replayMode mode)
    {	boolean review = reviewMode();
        int step = b.moveNumber();
        if(!review) { History.viewMove = Math.max(step, History.viewMove);} // maintain the max move for the parents
        
        // note this is a deliberate EQ comparison of a string.
        if(commonMove.isDefaultNumString(m.getSliderNumString()))
        	{ m.setSliderNumString("" + step); 
        	}
        if (m.player < 0)
        {
            m.player = b.whoseTurn();
        }
        if(m.op==MOVE_DONTUNDO) {}	// ignore this
        else if(m.op==MOVE_ALLOWUNDO) 
        {	// unconditional undo, after approval of a request
        	do { doUndoStep(); } while(isRobotTurn()); 
        }
        else if((m.op==MOVE_RESET)||(m.op==MOVE_UNDO))
        {	
        	if(allowBackwardStep()) { doUndoStep(); }
        	else if(allowUndo()) { doUndo(); }
        }
        else
        { 	commonPlayer pl = getPlayerOrTemp(m.player);
        	switch(mode)
        	{	default: G.Error("Not expecting mode %s", mode);
        		case Live: 
        			{ 	// in live play, load the move from the player time
        				m.setElapsedTime((int)pl.elapsedTime); 
        			}
        			break;
        		case Replay:
        		case Single:
        			{	// in review, load the player from the move time
        			pl.setReviewTime(m.elapsedTime());
        			}
        	}
        	b.Execute(m,mode);						 // let the board do the dirty work
        }
        if(m.op==MOVE_EDIT) 
        	{ stopRobots(); 
        	}
        // this is where checkForRepetition used to be.  It's now slightly later, after the history
        // has been updated.  The problem with checjing in this position is that the move beng added
        // may alter the history, for example causing itself to be eliminated, so a third repetition
        // will not occur.
        // checkForRepetition(b,m);
        if(!review) 
        	{ //let the supervisor know if we're just waiting for a "done"
         	setDoneState(b.DoneState()); 
        	}
        GameOverNow();	// notice if the game is over now

    }

/**
 * the contract of editHistory is to remove unnecessary elements
 * from the game history, resulting in a tidy record that when 
 * replayed, results in a duplicate of the current state.  This default
 * method works by taking a game digest after every move, and assuming 
 * that if the game digest reverts to a previous value, it must be an undo
 * back to that move.   Scanning back stops with a MOVE_DONE 
 * @param m
 * @return a move to be added to the history, or null
 */
    public commonMove EditHistory(commonMove m)
    {	return(EditHistory(m,false));
    }
    public commonMove EditHistory(commonMove m,boolean okSame)
    {
    	long dig = getBoard().Digest();
    	m.digest = dig;
    	int size = History.size() - 1;
    	int fullsize = size;
    	switch(m.op) {
    	case MOVE_RESET:
    	case MOVE_UNDO:
    	case MOVE_PEEK:
    	case MOVE_PLEASEUNDO:
    	case MOVE_DONTUNDO:
    	case MOVE_ALLOWUNDO:
    		// these always get filtered out
    		m = null;
    		size = -1;
    		break;
    	default: break;
    	}
    	while(size>=0)
    	{
    		commonMove hmove = History.elementAt(size);
    		
   			if(hmove.digest() == dig)
    			{	if(size!=fullsize)
    				{
    				// this is the normal "undo" case, where we undo some number of moves
    				// to get back to the same state
    				while(fullsize>size)  
    					{ popHistoryElement();
    					  fullsize--;
    					}
    				m = null;
    				size = -1;
    				}
    				else if(m.op==MOVE_PEEK)
    				{
    					size = -1;
    					if((hmove.op==MOVE_PEEK) && (hmove.player==m.player))
    					{	// remove duplicate peeks
    						m = null;
    					}
    				}
    				else if(m.op==MOVE_PASS) 
    				{	// special treatment for pass moves. passes may or may not change the state
    					// and if they don't, then two passed in a row are ok, just remove one.
    					// this accommodates games like hive and exxit where you can't pass voluntarily, but
    					// you can be forced to pass.
    					if(hmove.op==MOVE_PASS) { popHistoryElement(); size=-1;  }
    					else if(okSame) {/* pro forma pass for effect in the log */ size=-1; }
    					else { throw G.Error("Single pass did not change the Digest"); }
    				}
    				else if((m.op==MOVE_EDIT) || (m.op==MOVE_START)) 
    				{ 	size = -1;
     				}
    				else if(okSame) { m=null; size=-1; }
 				    else
    				{
				    	throw G.Error( "Move "+m+" didn't change digest");
    				}
    			} 
    			else { size--; }		// keep scanning
    		if(hmove.op==MOVE_DONE) 
    			{ size=-1; }
    		}
    	return(m);
     }

    /**
     * this is the usual point where gestures made with the mouse
     * are transformed into public actions.
     */
    public boolean PerformAndTransmit(String str)
    {	return(PerformAndTransmit(str,true,replayMode.Live));
    }

    void setHistorySize(int sz)
    {	int vstep = sz;
    	int hsize = History.size();
    	// coordinate with the repeatedPositions cache
    	if(History.viewStep<hsize) 
    	{	while(--hsize>vstep)
			{	repeatedPositions.removeFromRepeatedPositions(History.elementAt(hsize));
			}
    	}
    	History.setSize(sz);
    }
    /**
     * called to set the current move as the end of the move history.  This can be used
     * in conjunction with {@link #rewindHistory} to rewind a game to a given position.
     * and permanently undo the intervening moves.
     */
    public void truncateHistory()
    {	hidden.enterReviewMode();
    	setHistorySize(History.viewStep);
       	if(History.viewStep>0)
        	{
        	commonMove m = History.elementAt(History.viewStep-1);
        	m.next = null; 
        	m.setVariations(null);
        	}
       	doScrollTo(FORWARD_TO_END);
       	changeMove = getCurrentMove();	// inhibit turn change sound
    }
/**
 * rewind the game to a given position, usually preliminary to calling {@link #truncateHistory}
 * @param size
 */
    public void rewindHistory(int size)
    {
        if ((size >= 0) && (size < History.size()))
        {
            //System.out.println("Truncating history at step "+size);
            doScrollTo(size);
            mutated_game_record = true;
            setHistorySize(size);
            doScrollTo(FORWARD_TO_END);
         }
    }
/**
 * call this from your {@link #EditHistory} method to remove
 * a superfluous element at idx.  Note that this maintains both
 * the move tree in the commonMove elements, and the History list
 * which contains the current linear path to the current move in the tree.
 * 
 * Usually idx is the current last move in the history, and usually it has no successors.
 * This method works to remove elements that are not leaves of the tree, but that is
 * not usually something you want to do.  Routine use by EditHistory should always
 * remove leaves. 
 */
    public commonMove popHistoryElement()
    {
        //int size = History.size()-1;
        //commonMove msize = (commonMove)History.elementAt(size);
        //boolean review = msize.nVariations()>0;
    	int idx = History.size()-1;
    	commonMove midx = History.top();
    	
    	
        { String msg = "Pop "+midx;
          LogMessage(msg);
          rawHistory.addElement(new dummyMove(msg));
          if(G.debug() && (midx.op!=MOVE_EDIT)) { G.print(msg); }
        }
        
        {
        // if next is not null, this is a move in the middle of a chain and we can't really remove
        // it without destroying the semantics of the continuation.  If it was at the end of a chain
        // then make it really disappear.
        if((idx>0) && (midx.next==null))
        {	commonMove pmidx = History.elementAt(idx-1);
        	pmidx.removeVariation(midx);
         }}
        repeatedPositions.removeFromRepeatedPositions(midx);
        // note that this remove will leave the history with the last
        // element having a non-null "next" if we just removed the end of
        // a variation.  We get here from "edithistory" which should exit
        // and then the caller of edithistory will extend the history and set viewStep
        return(History.remove(idx,false));
    
     }
    /**
     * remove a history element without attempting to remove the effects
     * from the digest.  This is used by some games (ie; zertz) to remove
     * moves out of order which are actually independent and can be done
     * in either order.
     * @param idx
     * @return a commonMove
     */
    public commonMove popHistoryElement(int idx)
    {	int siz = History.size();
    	if(idx>=siz) { return(null); }
    	if(idx+1==siz) { return(popHistoryElement()); }
        else 
        	{ commonMove rem = popHistoryElement();
        	  commonMove val = popHistoryElement(idx);
        	  rem.digest = 0;		// when this is put back, the digest won't be correct.
        	  if (History.size() > 0)
              {	
                  commonMove m = History.top();
                  rem = m.addVariation(rem);
              }
        	  rem.addToHistoryAndExtend(History);
        	  return(val);
        	}
    }

    /**
     * remove a history element at an arbitrary index.  Unlike popHistoryElement(),
     * this also removes the effect from the board by unwinding and rewinding the board.
     * @param idx
     * @return the removed element
     */
    public commonMove removeHistoryElement(int idx)
    {	int step = History.viewStep;
     	commonMove val = hidden.removeHistoryElementRecurse(idx);
     	if(idx>0)
     	{	// we removed the element from somewhere back on the path, 
     		// but doing so left the digests incorrect
     		doScrollTo(idx-1);
     		if(step>idx) { step--; }
     		doScrollTo(step);
     	}
     	return(val);
    }
 
    /** draw the standard repeated positions warning message 
     * 
     * @param gc
     * @param digest
     * @param r
     */
    public void DrawRepRect(Graphics gc,long digest,Rectangle r)
    {
    	 	DrawRepRect(gc,0,Color.black,digest,r);
    }
   public void DrawRepRect(Graphics gc,double rotation,Color textColor,long digest,Rectangle r)
   {
    	if(gc!=null)
    	{	
    		int nreps = repeatedPositions.numberOfRepeatedPositions(digest);
    		G.setFont(gc,largeBoldFont());
    		if(nreps>1) 
    		{ G.Text(gc,rotation,false,r,textColor,null,s.get(RepetitionsMessage,nreps)); 
    		}
    	}
    }  

    /** handle the boilerplate editing options involving punting on a resign,
     * multiple starts or edits.
     * @param newmove
     * @return a move to add to the history, or null
     */
    public commonMove commonEditHistory(commonMove newmove)
    {	int idx = History.size() - 1;
    	commonMove rval = newmove;
    	if(idx>=0) 
    	{
    	commonMove m = History.elementAt(idx);
    	switch(newmove.op)
    	{
    	case MOVE_EDIT:
    	case MOVE_START:
    		switch(m.op)
    		{
    		default: break;
    		case MOVE_START:
    		case MOVE_EDIT:
    		case MOVE_RESIGN:
    			// multiple starts or edits, remove previous
    			popHistoryElement(); 
    			break;
    		}
    		break;
    	case MOVE_DONE:
    		break;
    	case MOVE_RESIGN:
    		// multiple resigns, remove both
    		if(m.op==MOVE_RESIGN) { rval = null; }
    		// fall through
			//$FALL-THROUGH$
		default:
     		// anything other than "done" after a resign, remove the resign
    		if(m.op==MOVE_RESIGN) { popHistoryElement(); }
    		break;
    	}}
    	return(rval);
    }
    /** add to the history, but also edit the current move in progress
    so we don't clutter the history with extra steps.  This doesn't
    hurt anything, but it looks bad and makes the move slider slide.
    At the point we get there, the move has already been fully
    performed, so only the history vector itself is affected.
    @return true if the current move was added to history
    */
    public boolean AddToHistory(commonMove originalnewmove)
    { // add to history, but also edit history so redundant moves are eliminated
    	commonMove newmove = originalnewmove;
    	rawHistory.addElement(newmove);
        if(History.viewStep==-1) 
        	{ newmove = commonEditHistory(newmove);
        	  if(newmove!=null) { newmove = EditHistory(newmove); } 
         	}
        if(newmove==null) 
        { // in some games (ie: plateau) will have a "done" state that is optional, in which case
          // we can pass through a done state and then undo back to it.  In this case the done move
          // may have already been recorded as a repetition
          	{ String str = "edit: "+originalnewmove+" deleted";
          	  LogMessage(str);
          	  //if(G.debug()) { System.out.println(str); } 
          	  rawHistory.addElement(new dummyMove(str));
          	}
          repeatedPositions.removeFromRepeatedPositions(originalnewmove); 
       	  int sz = History.size();
    	  if(sz>0)
    	  {	  // removing elements from the history can result in backing out of a variation,
    		  // which extends the sequence instead of reducing it.  Consequently we can
    		  // go from non-review/end-of-variation to review/middle-of-variation by
    		  // deleting some moves in EditHistory
    		  commonMove oldm = History.elementAt(sz-1);
    		  if(oldm.next!=null)
    		  {	History.viewStep = sz;		// viewstep should point to the next item to be executed, which will be 
    		  						// the first item added.
    		  	mutated_game_record=true;
    		    oldm.extendHistory(History);
    		    // if we have removed a branch and re-extended the history,
    		    // the state of the real board may be different from what we
    		    // expect, especially if the move that caused the merge was a 
    		    // reset.  The symplest way to be sure it's all ok is to replay
    		    // the game to this point.
    		    { int step = History.viewStep;
    		      rawHistory.addElement(new dummyMove("vcr:@"+sz+" edit rescroll"));
    		      doWayBack(replayMode.Replay);
    		      doScrollTo(step);
    		    }
    		    generalRefresh();
    		  }
    	  }     
         if (History.viewStep >= History.size())
          {
        	 History.viewStep = -1;
        	 
          }
        }
        else //no editing needed, annotate the move with its position in the history and add it.
        {
            rewindHistory(newmove.index());

            int hsize = History.size();
            newmove.setIndex(hsize);

            if (hsize > 0)
            {	
                commonMove m = History.top();
                newmove = m.addVariation(newmove);

                //System.out.println("V "+m+" -> "+newmove+" -> " +m.next);
            }
            {
             int hs = newmove.addToHistoryAndExtend(History);
             if (hs > 0)
             	{
                History.viewStep = hs;
             	}}
            if(newmove!=originalnewmove) { newmove.setElapsedTime(originalnewmove.elapsedTime()); }
        }
        return(newmove!=null);
    }
    public boolean singlePlayer() 
    {	int nPlayers = sharedInfo.getInt(OnlineConstants.PLAYERS_IN_GAME,0);
    	return ( (nPlayers<2) || 
    				( sharedInfo.get(exHashtable.ROBOTGAME)!=null)
    					&& nPlayers==2);	
    }
    JMenuItem zoomButton = null;
    JMenuItem unzoomButton = null;
    private IconMenu zoomMenu = null;
    private IconMenu paperclipMenu = null;
    private IconMenu paperclipRestoreMenu = null;
    private SliderMenu sliderMenu = null;
    private IconMenu rotateMenu = null;
    public Image gameIcon = StockArt.GameIcon.image;
    public VncServiceProvider regService = null;
    public SeatingChart seatingChart = null;
    /**
     * @return true if the seating chart provides seats on at least 3 sides
     */
    public boolean seatingAround() { return(seatingChart.seatingAround()); }
    /**
     * @return true of the selected seating has players across from one another
     */
    public boolean seatingFaceToFace() { return(seatingChart.seatingFaceToFace()&&!seatingChart.seatingAround()); };
    
    public boolean seatingFaceToFaceRotated() { 
    	if(seatingFaceToFace())
    	{	commonPlayer pl = getPlayerOrTemp(0);
    		int qt = G.rotationQuarterTurns(pl.displayRotation);
    		return((qt&1)!=0);
    	}
    	return(false);
    }
    /**
     * @return true if the seating chart specifies player positions
     */
    public boolean plannedSeating() { return((seatingChart.getNSeats()>=2) && (seatingFaceToFace()||seatingAround())); }
    /**
     * get the color map specified at launch, before possible player color swaps.
     * the default map is [0,1,2 ...]
     * @return an array of integers, which remap the colors 
     */
    public int[]getStartingColorMap() 
    { 	Object map = sharedInfo.get(exHashtable.COLORMAP);
    	if(map instanceof String) { map = G.parseColorMap((String)map); }
    	return((int[])map);
    }
    public GameInfo gameInfo = null;
    
    public void startFirstPlayer()
    {
    	int first = -1;
    	if(gameInfo!=null)
    	{
    	if(gameInfo.variableColorMap)
    		{ first = sharedInfo.getInt(exHashtable.FIRSTPLAYER,0); }
       	if(first<0 && (gameInfo.colorMap!=null)) 
		{ // if the first player is not specified explicitly, find the player playing color 0
       	  BoardProtocol b = getBoard();
		  int map[] = b.getColorMap();
		  if(map!=null) 
		  	{ for(int lim=b.nPlayers(),i=0;i<lim;i++)
		  		{ if(map[i]==0) { first = i; }
		  			}
		  		}
		  	}
    	}
    	if(first<0) { first=0; }
    	PerformAndTransmit(reviewOnly?EDIT:"Start P"+first, false,replayMode.Replay);
    }
    
    private boolean unrankedMode = false;
    private boolean masterMode = false;
    private boolean tournamentMode = false;
    
    private long lastMouseTime = 0;
    
    private boolean canTrackMouse()
    {	return( reviewOnly 
    			|| ( started
    				&& ( my.spectator 
    					? mutable_game_record
    					: true
    					)));
    }
    private String mouseMessage = null;
    private int mouseObject = -1;
    public String mouseMessage() { String mm = mouseMessage; mouseMessage = null; return(mm); }
    
    public void trackMouse(int x, int y)
    {	
        long now = G.Date();
        int mouseObj = getMovingObject(null);
        boolean newState = mouseObj!=mouseObject;
        mouseObject = mouseObj;
        
        if (started
        		&& (newState||((now - lastMouseTime) > 250)) // rate limit to 1 per 1/4 second
                 && canTrackMouse())
        {	Point pt = new Point(0,0);
            String zone = encodeScreenZone(x, y,pt); // not raw coordinates but normalized
            if (zone != null)
            {   int closestX = G.Left(pt);
                int closestY = G.Top(pt);                

                if ((closestX != my.mouseX) || (closestY != my.mouseY))
                {
                    lastMouseTime = now;
                    mouseMessage = NetConn.SEND_GROUP+KEYWORD_TRACKMOUSE+" "+zone+" " +
                    		+ closestX + " " + closestY + " " + mouseObj;
                }
            }
        }
    }


    // general initialization
    public void init(ExtendedHashtable info,LFrameProtocol frame)
    {
        super.init(info,frame);
        unrankedMode = info.getBoolean(exHashtable.UNRANKEDMODE,false);
        masterMode = info.getBoolean(exHashtable.MASTERMODE,false);
        tournamentMode = info.getBoolean(exHashtable.TOURNAMENTMODE,false);

        G.setNextIntCompatibility(false);
        gameInfo = (GameInfo)info.get(exHashtable.GAMEINFO);
        if(gameInfo==null)
        {
        	gameInfo = GameInfo.findByName(info.getString(GAMETYPE ,null));
        	if(gameInfo==null)
        	{	gameInfo = GameInfo.findByNumber(info.getInt(GAMEINDEX,-1));
        	}
         }
        isPassAndPlay = isPassAndPlay();
        if(G.isSimulator() || !G.isTouchInterface()) 
    	{ 
    	  zoomButton = myFrame.addAction("Zoom Up",deferredEvents);
    	  unzoomButton = myFrame.addAction("Un Zoom",deferredEvents);
    	}
        myFrame.setIconAsImage(gameIcon);
        
        hidden.controlToken = use_grid = mutable_game_record = allowed_to_edit = reviewOnly = sharedInfo.getBoolean(Config.REVIEWONLY);
        mutated_game_record = false;
        gridOption = myFrame.addOption(s.get(ShowGridAction), use_grid,deferredEvents);
        tickTockOption = myFrame.addOption(s.get(TickTockAction),Config.Default.getBoolean(Config.Default.ticktock),deferredEvents);
        tickTockOption.setForeground(Color.blue);
        mouseCheckbox = myFrame.addOption(s.get(TrackMice),true,null);

        boolean viewer = reviewOnly;


        
        globalZoomRect = addSlider(".globalZoom",s.get(ZoomMessage),GameId.HitZoomSlider);
        globalZoomRect.min=1.0;
        globalZoomRect.max=MAXIMUM_ZOOM;
        globalZoomRect.value=1.0;

        if(viewer || singlePlayer() || offline()) { setSeeChat(false); }
        if (viewer)
        {
        	hidden.showText = myFrame.addAction(s.get("Show Raw Text"),deferredEvents);
        	if(G.isCodename1())
        		{ myFrame.setCanSavePanZoom(deferredEvents); 
        	}
        }

        if (viewer && extraactions)
        {	
        	hidden.saveGame = myFrame.addAction("Save Single Game",deferredEvents);
        	hidden.saveCollection = myFrame.addAction("Save Game Collection",deferredEvents);
        	hidden.loadGame = myFrame.addAction("Load Game File",deferredEvents);
        	hidden.gamesMenu = new XJMenu(SelectAGameMessage,true);
            myFrame.addToMenuBar(hidden.gamesMenu);
            hidden.gamesMenu.addItemListener(deferredEvents);
        }

        if (extraactions)
        {	debugSwitch = myFrame.addOption("debug",G.debug(),deferredEvents);
        	debugOnceSwitch = myFrame.addOption("debug once", false,deferredEvents);
        	layoutAction = myFrame.addAction("check layouts",deferredEvents);
        	if(viewer) 
        	{ hidden.replayCollection = myFrame.addAction("Replay Game Collection",deferredEvents); 
        	  hidden.replayFolder = myFrame.addAction("Replay games in folder",deferredEvents);
        	}
        	{
        	JMenu robotMenu = new XJMenu("Robot Actions",true);
        	myFrame.addToMenuBar(robotMenu);
        	
        	hidden.treeViewerMenu = myFrame.addAction(robotMenu,"view UCT search tree",deferredEvents);
        	hidden.alphaViewerMenu = myFrame.addAction(robotMenu,"view Alpha-Beta search tree",deferredEvents);
        	hidden.truncateGame = myFrame.addAction(robotMenu,"truncate game",deferredEvents);
        	hidden.evalRobot = myFrame.addAction(robotMenu,"start evaluator",deferredEvents);
        	hidden.testRobot = myFrame.addAction(robotMenu,"test one robot move",deferredEvents);
        	hidden.startRobot = myFrame.addAction(robotMenu,"start a robot",deferredEvents);
        	hidden.robotLevel0 = myFrame.addAction(robotMenu,"select robot",deferredEvents);
        	hidden.selectRobotThread = myFrame.addAction(robotMenu,"select thread...",deferredEvents);
        	hidden.stopRobot = myFrame.addAction(robotMenu,"stop all robots",deferredEvents);
        	hidden.pauseRobot = myFrame.addAction(robotMenu,"pause all robots",deferredEvents);
        	hidden.resumeRobot = myFrame.addAction(robotMenu,"resume all robots",deferredEvents);
        	hidden.saveVariation = myFrame.addAction(robotMenu,"save current variation",deferredEvents);
        	hidden.runGameDumbot = myFrame.addAction(robotMenu,"play against dumbot",deferredEvents);
        	hidden.runGameSelf = myFrame.addAction(robotMenu,"play against self",deferredEvents);
        	hidden.train = myFrame.addAction(robotMenu, "run training",deferredEvents);
        	}
        	hidden.startShell = myFrame.addAction("start shell",deferredEvents);
            hidden.passMove = myFrame.addAction("pass this move",deferredEvents);
           	auxSliders = myFrame.addOption("Use aux sliders",false,deferredEvents);
           	hidden.alternateBoard = myFrame.addOption("Show Alternate Board", false,deferredEvents);
            hidden.saveAndCompare = myFrame.addAction("Save/Compare Position",deferredEvents);
            regService = new VncRemote("Spectate for "+gameName(),painter,this);
            VNCService.registerService(regService);
        }
        
        hidden.noChatMenu = myFrame.addOption("No chat window",!seeChat(),deferredEvents);
        hidden.showSgf = myFrame.addAction(ShowSGFMessage,deferredEvents);
        hidden.emailSgf = myFrame.addAction(EmailSGFMessage,deferredEvents);
        setActivePlayer((commonPlayer)info.get(exHashtable.MYPLAYER));
        G.Assert(getActivePlayer()!=null,"my player not supplied");

        if (!getActivePlayer().spectator)
        {
            hidden.resignAction = myFrame.addAction(s.get(RESIGN),deferredEvents);
        }

        if(!G.isCodename1())
        {

        paperclipMenu = new IconMenu(StockArt.PaperClip.image);
        myFrame.addToMenuBar(paperclipMenu,deferredEvents);
        paperclipMenu.setVisible(true);
        
        paperclipRestoreMenu = new IconMenu(StockArt.PaperClipSide.image);
        myFrame.addToMenuBar(paperclipRestoreMenu,deferredEvents);
        paperclipRestoreMenu.setVisible(false);

        zoomMenu = new IconMenu(StockArt.Magnifier.image);
        myFrame.addToMenuBar(zoomMenu,deferredEvents);
        zoomMenu.setVisible(true);
        
        sliderMenu = new SliderMenu(globalZoomRect);
        myFrame.addToMenuBar(sliderMenu,deferredEvents);
        sliderMenu.setVisible(false);
        
        if(offline() && G.debug()) 
        	{ rotateMenu = new IconMenu(StockArt.Rotate.image); 
        	  myFrame.addToMenuBar(rotateMenu,deferredEvents);
        	  rotateMenu.setVisible(true);
        	}
        
        }
        seatingChart = (SeatingChart)info.get(exHashtable.SEATINGCHART);
        if(seatingChart==null) 
        	{ seatingChart = SeatingChart.defaultSeatingChart(info.getInt(OnlineConstants.PLAYERS_IN_GAME,2)); 
        	}

        if(G.debug())
        {
        InternationalStrings.put(PlayConstants.commonGameStrings);
        InternationalStrings.put(PlayConstants.commonGameStringPairs);
        }
        SoundManager.loadASoundClip(turnChangeSoundName);
        SoundManager.loadASoundClip(beepBeepSoundName);

     }

    /* used when loading a new game */
    public void doInit(boolean preserve_history)
    {   if(!preserve_history)
    	{
    	History.viewStep = -1;
    	History.viewTurn = null;
        History.clear();
        rawHistory.clear();
        BoardProtocol b = getBoard();
        if(b!=null) { adjustPlayers(b.nPlayers()); }
        commonPlayer.initPlayers(players,reviewOnly);
    	}
    for(int i=0;i<players.length;i++)
    {
    	commonPlayer pl = players[i];
    	if(pl!=null) { pl.setReviewTime(-1); }
    }
    repeatedPositions.clear();
    }
 //
 // this console, based on "beanshell" 
 //
    public void startShell()
    {	
    	ShellProtocol shell = (ShellProtocol)G.MakeInstance("lib.ShellBridge");
    	shell.startShell("viewer",this,"board",getBoard(),"out",System.out);
    	G.setPrinter(shell);
    }
    public void stopRobots()
    {
        for (int n = 0; n < players.length; n++)
        {
           commonPlayer player = players[n];
            if (player != null) 
            {
                player.stopRobot();
            }
        }
        getActivePlayer().stopRobot();
        if(extraBot!=null) { extraBot.StopRobot(); }
    }
    public void pauseRobots()
    {
        for (commonPlayer player : players)
        {
            if (player != null) 
            {
                player.pauseRobot();
            }
        }
        getActivePlayer().pauseRobot();
        if(extraBot!=null) { extraBot.Pause(); }
    }    
    
    public void resumeRobots()
    {
        for (commonPlayer player : players)
        {
           if (player != null) 
            {
                player.resumeRobot();
            }
        }
        getActivePlayer().resumeRobot();
        if(extraBot!=null) { extraBot.Resume(); }
    }
    public void selectRobot(int x,int y)
    {	hidden.robotPopup.newPopupMenu(this,deferredEvents);
    	for(Bot b : Bot.values())
    	{	if(b.idx>=0) { hidden.robotPopup.addMenuItem(b.name,b); }   		
    	}
    	hidden.robotPopup.show(x,y);
    }
    public void selectRobotThread(int x,int y)
    {	
    	for (int n = 0; n < players.length; n++)
        {
           commonPlayer player = players[n];
            if (player != null) 
            {
            	SimpleRobotProtocol r = player.robotBeingMonitored();
            	if(r!=null)
            	{	Thread threads[] = r.getThreads();
            		if(threads!=null)
            		{	
            			hidden.threadPopup.newPopupMenu(this,deferredEvents);
            			hidden.threadPopupRobot = r;
            			for(Thread t : threads) { hidden.threadPopup.addMenuItem(t.toString(),t); }
            			hidden.threadPopup.show(x,y);
            		}
            	}
            }
        }
    }
    SimpleRobotProtocol extraBot = null;
    public void runRobotGameDumbot()
    {	SimpleRobotProtocol rr = extraBot = newRobotPlayer();
    	rr.runRobotGameDumbot(this,getBoard(),newRobotPlayer());
    }
    public void runRobotGameSelf()
    {	SimpleRobotProtocol rr = extraBot = newRobotPlayer();
    	rr.runRobotGameSelf(this,getBoard(),newRobotPlayer());
    }
    public void runRobotTraining()
    {
    	SimpleRobotProtocol rr = extraBot = newRobotPlayer();
    	rr.runRobotTraining(this,getBoard(),newRobotPlayer());
    }
    public void saveRobotVariation()
    {
        for (int n = 0; n < players.length; n++)
        {
           commonPlayer player = players[n];
            if (player != null) 
            {
            	SimpleRobotProtocol r = player.robotRunning();
            	if(r!=null)
            	{	commonMove var = r.getCurrentVariation();
            		commonMove lastMove = null;
            		if(var!=null)
            		{
            			//var.showPV("Solution "+number_of_solutions+" ");
            			CommonMoveStack hist = new CommonMoveStack();
				
						{
							CommonMoveStack vhist = History;
							for(int i=0,lim=vhist.size();i<lim;i++)
							{	// copy the game before starting
								commonMove elem = vhist.elementAt(i).Copy(null);
								if(lastMove!=null) { lastMove.next = elem; }
								hist.push(elem);
								lastMove = elem;
							}
						}
						while(var!=null)
						{	// add the moves in this solution
							var.setIndex(lastMove.index()+1);
							lastMove.next = var;
							lastMove = var;
							hist.push(var);
							var = var.best_move();
						}
						doSaveGame(save_game(hist));

            		}

            	}
            }
        }
        getActivePlayer().stopRobot();
    }
    public TreeViewer treeViewer = null; 
    public TreeViewer getTreeViewer() { return(treeViewer); }
    
  
    /** this is called from the run loop to actually
     * perform actions that were deferred by a deferredEventHandler
     * <p>
     * this method handles the standard events added in the standard
     * action and options menu.  It should be wrapped as necessary to
     * handle things added by your viewer subclass.
     * @param target will be a menu item 
     * @return true if the target event was handled.
     */
     public boolean handleDeferredEvent(Object target, String command)
    {
        boolean handled = super.handleDeferredEvent(target, command);
        if(!handled)
        {
        handled = hidden.handleDeferredEvent(target);
        if(hidden.vcrVarPopup.selectMenuTarget(target))
    	{	chooseVcrVar((commonMove)(hidden.vcrVarPopup.rawValue));
    		handled = true;
        }
        else if (target == tickTockOption)
        {
        	playTickTockSounds = tickTockOption.getState();
        	Config.Default.setBoolean(Config.Default.ticktock,playTickTockSounds);
        }
        else if(target == layoutAction)
        {
        	checkLayouts();
        	handled = true;
        }
        else if(target == debugSwitch)
        {
        	G.putGlobal(G.DEBUG,""+!G.debug());
        	handled = true;
        }
        else if(target == debugOnceSwitch)
        {
        	G.setDebugOnce();
        	handled = true;
        }
        else if(target == sliderMenu)
        {
        	changeZoomAndRecenter(getGlobalZoom());
        	generalRefresh();
        	handled = true;
        }
        else if("savepanzoom".equals(command) || (target == paperclipMenu))
        {	
        	doSavePanZoom("");
        	if(paperclipRestoreMenu!=null) { paperclipRestoreMenu.setVisible(true); }
        	myFrame.setHasSavePanZoom(true);
         	handled = true;
        }
        else if("restorepanzoom".equals(command) || (target == paperclipRestoreMenu))
        {	// use the component x,y because we lost the event xy
        	doRestorePanZoom(G.getAbsoluteX((Component)target),G.getAbsoluteY((Component)target));
        	handled = true;
        }
        else if(target==rotateMenu)
        {
        	MasterForm.setGlobalRotation(MasterForm.getGlobalRotation()+2); 
        	handled=true;
        }
        else if(target == zoomMenu)
        {	   
        	if(getGlobalZoom()<MINIMUM_ZOOM)
        	{
			setGlobalZoomButton();
        	}
        	else 
        	{ setGlobalUnZoomButton(); 
        	}
        	resetBounds();
        	generalRefresh();
    	
   			handled = true;
        }
        else if (target == gridOption)
        {	use_grid = gridOption.getState();
           generalRefresh();
           handled = true;
        }

        else if (target == auxSliders)
        {	
        	useAuxSliders = auxSliders.getState();
        	handled = true;
        }
        }
        return (handled);
    }

/** 
 * show the unedited game history
 */
    public void doShowRawText()
    {
        commonDisplay w = new commonDisplay("Text of Game");        
        w.setText(gameRecordString());
     }
    public String gameRecordString()
    {
    	Utf8OutputStream lbs = new Utf8OutputStream();
        PrintStream os = Utf8Printer.getPrinter(lbs);
        printGameRecord(os, "","");
        os.flush();
        return(lbs.toString());
    }
    
    public StringStack panAndZoom  = new StringStack();
    
    public void doSavePanZoom(String specs)
    {	int sx = getSX();
    	int sy = getSY();
    	double z = getGlobalZoom();
    	double r = getRotation();
    	String pz = "globalzoomrot "+z+" "+r+" globalx "+sx+" globaly "+sy;
    	if(zoomRect!=null)
    	{
    		pz += " tilesize "+zoomRect.value
        			+" boardx "+board_center_x
        			+" boardy "+board_center_y;
    	}
    	panAndZoom.pushNew(pz + specs);
    	if(paperclipRestoreMenu!=null) { paperclipRestoreMenu.setText(""+panAndZoom.size()); }
    	myFrame.setHasSavePanZoom(true);
    	playASoundClip(clickSound,50); 
    }
    @SuppressWarnings("unused")
	public boolean setGlobalZoom(double z, double r)
    {
    	if(z!=getGlobalZoom() || (PINCHROTATION && (r!=getRotation())))
    	{
    		changeZoom(z,r);
    		return(true);
    	}
    	return(false);
    }
    
    private double previousZoomValue = 1.0;
	private synchronized boolean changeZoom(double z,double rot)
	{ 	
		if(z<MINIMUM_ZOOM)
		 {	// if we're reverting to no zoom, set pan to zero first
			 if(z!=previousZoomValue)
			 { 
			 resetBounds(); 
			 previousZoomValue = 1.0; 
			 setSX(0);
			 setSY(0);
			 mouse.drag_is_pinch = false;
			 globalRotation = 0;
			 globalZoomRect.setValue(1.0);
			 if(zoomMenu!=null)
			 {
			 zoomMenu.changeIcon(StockArt.Magnifier.image,false);
			 sliderMenu.setVisible(false);
			 }}
			 return(true);		// indicate we're still on zero
		 }
		 else
		 {
		 if(z!=previousZoomValue)
		 {
		 resetBounds();
		 previousZoomValue = z;
		 mouse.drag_is_pinch = true; 	// also pan
		 globalZoomRect.setValue(z);
		 globalRotation = rot;
		 if(zoomMenu!=null)
		 {
		 zoomMenu.changeIcon(StockArt.UnMagnifier.image,true);
		 sliderMenu.setVisible(true);
		 }}
		 
		 return(false);
		 }
	}

	public double getGlobalZoom() { return((globalZoomRect==null) ? 1.0 : globalZoomRect.value); }
	public double getRotation() { return(PINCHROTATION ? globalRotation : 0.0); }

    public void doRestorePanZoom(String specs)
    {	StringTokenizer tok = new StringTokenizer(specs);
    	while(tok.hasMoreTokens())
    	{
    		String key = tok.nextToken();
    		String val = tok.nextToken();
    		if("globalx".equals(key)) { setSX(G.IntToken(val)); }
    		else if("globaly".equals(key)) { setSY(G.IntToken(val)); }
    		else if("globalzoomrot".equals(key)) { changeZoom(G.DoubleToken(val),G.DoubleToken(tok.nextToken())); }
    		else if("boardx".equals(key)) { board_center_x = G.DoubleToken(val); }
    		else if("boardy".equals(key)) { board_center_y = G.DoubleToken(val); }
    		else if("tilesize".equals(key)) { zoomRect.setValue(G.DoubleToken(val)); }

    	}
    	if(zoomMenu!=null)
    	{
    	if(getGlobalZoom()>=MINIMUM_ZOOM)
    	{
		zoomMenu.changeIcon(StockArt.UnMagnifier.image,true);
		sliderMenu.setVisible(true);
    	}
    	else 
    	{ 
    	zoomMenu.changeIcon(StockArt.Magnifier.image,false);
    	sliderMenu.setVisible(false);
    	}}
  	  	resetBounds();
  	  	resetLocalBoundsNow();
    	generalRefresh();
    }
    private String summarize(String e)
    {	String res = "";
    	StringTokenizer tok = new StringTokenizer(e," ");
    	while(tok.hasMoreTokens())
    	{
    		String m = tok.nextToken();
    		int ind = m.indexOf('.');
    		if(ind>=0)
    		{
    			if(ind+3<m.length())
    			{
    				m = m.substring(0,ind+3);
    			}
    		}
    		res += m+" ";
    	}
    	return(res);
    }
    public void doRestorePanZoom(int x,int y)
    {	PopupManager pop = hidden.panzoomPopup;
    	pop.newPopupMenu(getThis(),deferredEvents);
    	for(int i=0;i<panAndZoom.size();i++)
    	{	String e = panAndZoom.elementAt(i);
    		pop.addMenuItem((i+1)+": "+summarize(e),e);
    	}
    	pop.show(x,y);
    }
    /** 
     * this becomes sequence of tokens that is used to identify
     * and initialize the game when being restarted or spectated on.
     * It will be parsed by your {@link #performHistoryInitialization}
     * method.
     * @return a string representing the game type
     */
    public abstract String gameType();
    
    public abstract String sgfGameType();
    
    public String sgfGameVersion() { return("1"); }

    /**
     * form the canonical version of the game record for use during the game.  This is used to
     * bring spectators up to date, to restart interrupted games, and to resynchronize players
     * who are rejoining a game in progress.
     */
    public void formHistoryString(PrintStream os,boolean includeTimes)
    {
        os.print(gameType() + " " + 0 );

        if (History.size() > 0)
        {
            commonMove mv = History.elementAt(0);
            mv.formHistoryTree(os,includeTimes);
        }
    } 
    /**
     * form the canonical version of the game record for use during the game.  This is used to
     * bring spectators up to date, to restart interrupted games, and to resynchronize players
     * who are rejoining a game in progress.
     * 
     * includeTimes is a compatibility bridge to old versions of the server
     * which do not have special logic to filter out per-move times. If the
     * server doesn't know about +T nn times, don't send them.
     */
    public String formStoryString(boolean includeTimes)
    {
    	Utf8OutputStream b = new Utf8OutputStream();
        PrintStream os = Utf8Printer.getPrinter(b);
        formHistoryString(os,includeTimes);
        os.flush();
        String str = b.toString();
        return (str);
    }
    /** describe the ephemeral (ie; rapidly changing) state of the game.  This method
     * usually returns player time information, but can include other things if they
     * are needed to reconstruct a game.  The consumer of this string is the  {@link #useEphemeraBuffer}
     * method
     */
    public String formEphemeralHistoryString()
    {	String time = "";
    	String space = "";
    	for(int i=0;i<players.length;i++)
    	{	commonPlayer pl = players[i];
    		time += space + ((pl==null) ? 0 : pl.elapsedTime);
    		space = " ";
    	}
    	// 3/2013 add the current scroll position to the sting, so spectators joining
    	// in review mode are auto scrolled to the current view position.  This prevents
    	// them becoming confused of the next transmitted action is a real move rather
    	// than another repositioning.  Don't make this optional, the number of tokens
    	// we produce/consume should always be a constant
    	
     	time += " " + KEYWORD_SCROLL + " " + getReviewPosition();
    	return(time);
    }
    /**
     * 
     * accept a message, presumably incoming from the other player.
     * return true if it's one we recognized and handled.  Moves
     * may arrive while we are reviewing and not prepared to act
     * on them immediately.
     *
     * @param st
     * @return a parsed move
     */
    public abstract commonMove ParseNewMove(String st, int player);

       
    /** true if there are unprocessed messages, usually as a result 
     *  of messages arriving while in temporary review mode
     * @return true of there are deferred Messages waiting to be processed
     */
    public boolean hasDeferredMessages()
    {	return(hidden.deferredMessages.size()>0);
    }
    private boolean deferWarningSent = false;
    /**
     * parse an incoming "viewer" message from another player.
     */
    public boolean ParseMessage(String str, int player)
    {	// this is a little convoluted because we want to defer execution
    	// if the user has scrolled back during a game.  The old logic parsed
    	// the message then added it to the history, so the replay at the
    	// end of reviewmode would execute it.  The flaw with this is that
    	// the history replay doesn't do editing, so actions like a reset
    	// did their actions but didn't edit the history.  This left the
    	// history harmlessly confused, except for incremental recording
    	// got a little confused.
    	//
    	// the new logic defers ALL incoming moves, then replays all deferred
    	// moves, including the current one.  If in review mode, it stays deferred
    	// but is replayed at the end of review mode.
    	//
    	// can be called with st==null to only parse existing deferred
    	// messages.
    	//
    	if(str!=null)
    		{hidden.deferredMessages.addElement(new DeferredMessage(player,str));		// add to the list
    		}
    	boolean some = hidden.handleDeferredMessages(); // do the list if we're live, or do nothing if we're in review
    	boolean has = hasDeferredMessages();
    	if((str!=null) && has)	
        {	if(!deferWarningSent)
        	{
        	theChat.postMessage(ChatInterface.LOBBYCHANNEL, KEYWORD_LOBBY_CHAT,
                s.get(MovesComingIn));
        	deferWarningSent = true;
        	}
         }
    	else { deferWarningSent = false; }
    	
        return(some);
    }
    public boolean ParseEcho(String str)
    {
    	return(true);
    }
    /**
     * draw the standard game log
     * 
     * @param gc
     * @param highlight
     * @param r
     * @param highlightColor
     */
    public void redrawGameLog(Graphics gc, HitPoint highlight, Rectangle r, Color highlightColor)
    {	redrawGameLog(gc,highlight,r,Color.black,highlightColor,standardBoldFont(),standardPlainFont());
    }

    /**
     * return a censored version of shortMoveText.
     * This is a method of the viewer, so the viewer can apply knowledge from the
     * current state of the game in progress.
     * The default version of this method calls {@link online.game.commonMove#shortMoveText}
    *  @param sp the move to be stringified
     * @param index the current index into the move history
     * @return a Text object
     */
    public Text censoredMoveText(commonMove sp,int index)
    {
    	return(sp.shortMoveText(this));
    }
     /**
     * combine two text lines. By default this consists of just
     * catenating the lines with a comma between.  The default
     * method notices if there is alread punctuation of some kind
     * at the join, and skips adding the comma.
     * @param p1
     * @param sms
     * @return the combined string
     */
    public Text combineLines(Text p1,Text sms)
    {
    	if(p1.equals("")) { return(sms); }
    	if(sms.equals("")) { return(p1); }
    	int len = p1.length();
        if ((len > 0)
        		&& (p1.charAt(len-1)>='0')
        		&& (sms.charAt(0) >= 'A')
        		&& (p1.charAt(len-1)!=':'))
        { //insert a comma between move parts unless there
          //is already some punctuation or spacing
            p1.append(",");
        }
        p1.append(sms);
        return(p1);
    }
    // combine two string arrays
    private String[] combineEvents(String first[],String second[])
    {
    	if(first==null) { return(second); }
    	if(second==null) { return(first); }
    	int lfirst = first.length;
    	int lsecond = second.length;
    	String res[] = new String[lfirst+lsecond];
    	for(int i=0;i<lfirst;i++) { res[i]=first[i]; }
    	for(int j=0;j<lsecond; j++) { res[lfirst+j] = second[j]; }
    	return(res);
    }
    /**
     * colorize a string and return a Text with the result.  This is used
     * to substitute icons for words, or translate the words, in the string;
     * or to otherwise change the presentation of the string to something other than a plain 
     * fonted string.  See {@link lib.Text#colorize}
     * @param str
     * @return the new Text object
     */
    public Text colorize(String str)
    {	return(TextChunk.create(str));
    }
    /**
     * draw the standard game log.  This method uses {@link #censoredMoveText}, which uses
     * {@link commonMove#shortMoveText}
     * @param gc
     * @param highlight
     * @param r
     * @param textColor
     * @param highlightColor
     * @param playerFont the font to use to draw player names
     * @param lineFont the font to use for log lines
     */
    public void redrawGameLog(Graphics gc, HitPoint highlight, Rectangle r, 
    		Color textColor, Color highlightColor,
    		Font playerFont,Font lineFont)
    {	BoardProtocol b = getBoard();
        int numPlayers = (b==null) ? 0 : b.nPlayers();
        if ((gc != null) && (numPlayers>0))
        {	//G.Assert(Thread.currentThread()==runThread,"running in the wrong thread");
            int sz = History.size();
            int scroll = gameLogScroll;
            int highlightIndex = -1;
            int row = 1;
            int maxLineH = 0;
            boolean lastLineSeen = true;
            // basic layout, 1 cell for the row number, then two columns for the moves
            G.setColor(gc,textColor);
            G.setFont(gc,playerFont);

            FontMetrics myFM = G.getFontMetrics(gc);
            int rownumWidth = myFM.stringWidth("XXX");
            int rowheight = myFM.getAscent() + myFM.getDescent(); // not height, too much for some fonts
            int x = G.Left(r) + rownumWidth;
            int y = G.Top(r);
            int mid = (G.Width(r) - rownumWidth) / numPlayers;
            if (players != null)
            {
            // name the players
            for(int i=0;i<Math.min(players.length,numPlayers);i++)
            {
                if (players[i] != null)
                {
                    G.Text(gc, false, x+i*mid, y, mid, rowheight, textColor, null,
                        prettyName(i));
                }
            }}

            G.setFont(gc,lineFont);

            String moven = null;
            Text p1 = TextChunk.create("");
            int column = 0;
            int boxPos = rowheight;
            int ypos = 0;
            int boxH = G.Height(r);
            boolean linebreak = false;
            boolean needLineNumber = false;
            Text columns[] = new Text[numPlayers];
            Color bgColors[] = new Color[numPlayers];
            String rowMoveNumber = "";
            int maxEverLineHeight = rowheight;
            for (int first = 0, idx = 0; (idx <= sz) ; idx++)
            {
                commonMove sp = (idx == sz) ? null
                                            : (commonMove) History.elementAt(idx);
                Text sms = (sp==null) ? TextChunk.create("") : censoredMoveText(sp,idx); 
                String smsString = sms.getString();
                
                // this is a hack to make the log look just right.  Ignore the first element if it is "start"
                if((idx==0)&&"start".equalsIgnoreCase(smsString))
                	{ sms = TextChunk.create(""); smsString=""; 
                	  column = sp.player;
                	}
                String newnum = (sp == null) ? "" : ("".equals(smsString) ? moven : sp.getSliderNumString());
                int newplayer = (sp==null)? (column+1) : sp.player;
                if (moven == null)
                {
                    moven = newnum;
                }
                else if (linebreak || !moven.equals(newnum))
                { // changing moves

                    Color bgcolor = null;
                    if ((first <= History.viewStep) && (History.viewStep < idx))
                    {
                        bgcolor = highlightColor;
                        highlightIndex = row;
                    }
                    int lineh = p1.lineHeight(myFM);
                    maxLineH = Math.max(lineh,maxLineH);
                    if (row > scroll)
                    {	// collect all the columns so we can use a common baseline for the whole row
                        columns[column] = p1;
                        bgColors[column] = bgcolor;
                        if(!needLineNumber) 
                        	{ rowMoveNumber = moven;
                        	  needLineNumber = true; 
                        	}
                    }
                    
                    if ( (newplayer<(column+1)) || ((column+1)>=numPlayers))
                    {   // emit a complete line
                    	maxEverLineHeight = Math.max(maxLineH,maxEverLineHeight);
                    	if(needLineNumber && ((boxPos+maxLineH)<=boxH))
                    	{	
                    		hidden.emitLine(gc,r,boxPos,x,maxLineH,mid,textColor,columns,bgColors,rowMoveNumber);
                    		boxPos+= maxLineH;
                    		lastLineSeen = true;
                    	}
                    	else { lastLineSeen=false; }
                    	ypos += maxLineH;
                    	row++;
                    	needLineNumber = false;
                    	maxLineH = 0;
                        column = newplayer;
                    }
                    else
                    {
                        column=newplayer;

                        if (moven.length() == 1)
                        {
                            moven = " " + moven;
                        }
                     }
                    linebreak=false;
                    moven = newnum;
                    p1 = TextChunk.create("");
                    first = idx;
                }

                if (sp != null)
                {
                    if(sms.length() > 0) {	p1 = combineLines(p1,sms); }
                    if(p1.length()>0) { linebreak |= sp.getLineBreak();	}
                }
            }
            maxEverLineHeight = Math.max(maxLineH,maxEverLineHeight);
            // take care of the trailing line if we didn't fill the last line
            if(needLineNumber && ((boxPos+maxLineH)<=boxH))
        	{	
        		hidden.emitLine(gc,r,boxPos,x,maxLineH,mid,textColor,columns,bgColors,rowMoveNumber);
        		boxPos += maxLineH;
        		lastLineSeen=true;

        	} else { lastLineSeen=false; }
            if(needLineNumber) { row++; }
            row--;
            ypos += maxLineH;
            maxLineH = 0;
            {
                // finally, frame the whole thing
                G.frameRect(gc, Color.blue, G.Left(r),G.Top(r), G.Width(r), Math.min(ypos+rowheight,boxH));
                int nlines = (boxH-rowheight) / maxEverLineHeight;
            	int nextscroll = Math.max(0,row-nlines+(lastLineSeen?0:1));
                if ((highlightIndex >= 0))
                { // if we're scrolled back to a position, try to center the marker

                    int midlines = (boxH-rowheight) / (maxEverLineHeight * 2);
                    nextscroll = Math.min(nextscroll, Math.max(0, highlightIndex - midlines-1));
                }

                if (gameLogScroll != nextscroll)
                {	//G.print("From "+gameLogScroll +" to "+nextscroll);
                    gameLogScroll = nextscroll;
                    startingIdx = -1;	// force recalculation
                    repaint(200);
                }
            }        

        G.setFont(gc,standardPlainFont());
        }
    }

  private int startingIdx = -1;
  private int startingYpos = -1;
  private int startingRow = -1;
  private int startingMaxheight = -1;
  
 /**
  * draw a game log in 2 column format, where the left column is the player/move number
  * and the right column is the move activity.  This is more suitable for multiplayer games
  * or games where the turn order is variable.  This method uses several helper functions
  * that can be defined in the viewer class to customize the behavior see {@link #censoredMoveText}
  * {@link #colorize} {@link online.common.commonMove#gameEvents } {@link #combineLines }
  * 
  * @param gc
  * @param highlight
  * @param r
  * @param textColor	color for the main text
  * @param highlightColor color for highlighted text (at the current move point)
  * @param bold bold font
  * @param normal non-bold font
  */
    public void redrawGameLog2(Graphics gc, HitPoint highlight, Rectangle r,
        Color textColor,Color highlightColor,Font bold,Font normal)
    {	//
    	// note on the consolidation of redrawGameLogs.  There were originally
    	// 4 slightly different versions.  This is based on the "Tammany hall" version,
    	// which was the newest.  
    	//
    	G.startLog("start log "+gameLogScroll);
        if (gc != null)
        {	boolean centerSeen = false;
            int sz = History.size();
            int scroll = gameLogScroll;
            int highlightIndex = -1;
            int row = 1;
            int hr = G.Height(r);
            // basic layout, 1 cell for the row number, then two columns for the moves
            G.setColor(gc,textColor);
            G.setFont(gc,bold);

            FontMetrics myFM = G.getFontMetrics(gc);
            int width = G.Width(r);
            int rownumWidth = Math.min(myFM.stringWidth("XXXXXXXXXXXX"),width/2);
            int rowHeight = myFM.getAscent() + myFM.getDescent(); // not height, too much for some fonts
            int x = G.Left(r) + rownumWidth;
            int y = G.Top(r);
            int mid = (width - rownumWidth);

            G.setFont(gc,normal);

            String moven = null;
            String prevMoven = null;
            int player = -100;
            Text currentLine = TextChunk.create("");
            String gameEvents[] = null;
            boolean linebreak = false;
            int idx = 0;
            int first = 0;
            int ypos = 0;
            int maxLineHeight = rowHeight;
            int lastSeenLine = -1;
            int lastSeenIdx = -1;
            if(sz>0 && (History.elementAt(0).op == MOVE_START)) { idx++;  }
            boolean recalculating = startingIdx<0; 
            if(!recalculating)
            {	// saving these numbers allows the log to be 
            	// restarted at the current position, so you don't
            	// have to troll thought all the parts that precede the piece
            	// that is actually displayed.
            	// it turns out this is a noticeable problem for long games
            	// such as viticulture
            	idx = startingIdx;
            	ypos = startingYpos;
            	row = startingRow;
            	maxLineHeight = startingMaxheight;
            }

            int smsidx = idx;
            int smsypos = ypos;
            int smsrow = row;
            int smsheight = maxLineHeight;
            
            while (idx < sz)
            {	

            	commonMove sp = History.elementAt(idx);
                Text sms = censoredMoveText(sp,idx);
                
                String newnum = sp.getSliderNumString();
                
                // look for reasons to break rather than add this line to the current display line
                if((moven!=null) 
                		&& (newnum!=null) 
                		&& !"".equals(newnum) 
                		&& !newnum.equals(moven))
                {	// changing move number
                	linebreak = true;
                }
                if((player!=-100) && (player!=sp.player)) 
            	{ linebreak = true; 
            	}
               if(!linebreak) 
                { 	// process this line
                	if(!"".equals(newnum)) { moven = newnum; }
                    gameEvents = combineEvents(gameEvents,sp.gameEvents());
                    currentLine = combineLines(currentLine,sms);
                    player = sp.player;
                    linebreak = sp.getLineBreak();
                    if(linebreak) { idx++; }	// skip ahead too
                }
            if(!linebreak) { idx++; }			// advance if we are not outputting
            if(idx>=sz) { linebreak = true; }	// make sure we do the last line
               	
           	if(linebreak)
           	{
             Color bgcolor = null;
             if ((first <= History.viewStep) && (History.viewStep < idx))
                     {
                      bgcolor = highlightColor;
                      highlightIndex = row;
                     }
             
                	// output related to the accumulated line
           	if(idx>=sz || currentLine.length()>0 || (gameEvents!=null))
           	{	// output the line we have built
           		int h = currentLine.lineHeight(myFM);
                maxLineHeight = Math.max(h,maxLineHeight);
                if(row>scroll)
                {
				if((ypos + h)<hr)
                	{
	                if(startingIdx<0)
	                {	// remember where we started
	                	startingRow = smsrow;
	                	startingIdx = smsidx;
	                	startingYpos = smsypos;
	                	startingMaxheight = smsheight;
	                }
					String mn = moven +" "+prettyName(player);
                    if(!mn.equals(prevMoven))
                       	{int l = G.Left(r);
                       	 G.Text(gc, false, l + 2, y + ypos, x-l ,	h, textColor, bgcolor, mn);
                       	}
                    prevMoven = mn;
                	currentLine.draw(gc, false , x + 2, y + ypos, mid - 4, h, textColor, bgcolor );
                	lastSeenLine = row;
                	lastSeenIdx = idx;
                	if(currentLine.length()>0) { ypos += h; }
                	}
               }
               	first = idx;                           
              	row++;
           	}
            if(gameEvents!=null)
              {
              	for(int gameEventsIndex = 0;gameEventsIndex<gameEvents.length;gameEventsIndex++)
            	{  
             		String msg = gameEvents[gameEventsIndex];
             		Text chunk = colorize(msg);
             		int h = currentLine.lineHeight(myFM);
               		if(row>scroll)
             		{
               		maxLineHeight = Math.max(h,maxLineHeight);
            		if ((ypos + h) <= hr)
            		{
            		chunk.draw(gc, false , x + 2, y + ypos, mid - 4, h, Color.darkGray, bgcolor);
            		lastSeenLine = row;
            		lastSeenIdx = idx;
            		}
            		else if(!recalculating) { idx = sz; }	// shut off the rendering
            		ypos += h;
             		}
               		row++;

              	}
              }
    		linebreak = false;
            gameEvents = null;
            player = -100;
            // starting a new line
    		currentLine = TextChunk.create("");
    		smsidx = idx;
    		smsypos = ypos;
    		smsrow = row;
    		smsheight = maxLineHeight;
    		moven = null;
            }	// end of linebreak
           	
           } // end of while
          boolean sawEnd = (lastSeenIdx+1 >= sz);
          if(sawEnd && (History.viewStep==-1))
          	{ centerSeen = true; 
          	}
          if(!centerSeen)
          	{ startingIdx = -1; 
          	}
          G.addLog("ssawEnd "+sawEnd+" center "+centerSeen);
         // G.addLog("finish "+idx+" "+sz);
          // adjust the scroll position
          {
            int nextscroll = gameLogScroll;
            // finally, frame the whole thing
            G.frameRect(gc, Color.blue, G.Left(r), G.Top(r), G.Width(r), Math.min(y+ypos,hr));
            int spare = hr-ypos;
            if (spare>=0)
                {	int dec =   (spare/2)/maxLineHeight;
                	//more room for stuff.  2/3 adds a little hysteresis
                    nextscroll = Math.max(0,scroll-dec);
                    G.addLog(" next spare>=0 "+nextscroll);
                }
                else 
                {	// more stuff is available to see.  2/3 adds a little hysteresis
                	int inc = 1+(-(spare-maxLineHeight+1) / maxLineHeight)*2/3;
                    nextscroll = scroll + inc;
                    G.addLog(" next spare<0 "+nextscroll);
                }
            	int nlines = hr/maxLineHeight;
            	int target = highlightIndex<0 ? row : highlightIndex;
                if ((target >= 0) 
                		&& (!sawEnd &&  (lastSeenLine<target)) || ((target<scroll+(hr/(maxLineHeight*2))) || spare<0))
                { 	// if we're scrolled back to a position, try to center the marker
                    nextscroll = Math.max(0, target - (nlines+1)/2);
                    G.addLog(" next target>=0 "+nextscroll);
                }

                if (gameLogScroll != nextscroll)
                {	//G.finishLog();
                    gameLogScroll = nextscroll;
                    startingIdx = -1;
                    repaint(200);
                }
            }
        G.setFont(gc,standardPlainFont());
        }
    }
    
    public void shutDown()
    {	super.shutDown();
    	History.setSize(0);
        rawHistory.setSize(0);
        disposeHiddenWindows();
        VNCService.unregisterService(regService);       
   }

    public boolean canStartRobotTurn(commonPlayer p)
    {	return((p != null)
    	&& (p.robotPlayer!=null)
    	&& (p.robotRunner == getActivePlayer())
    	&& !reviewMode() 
    	&& !GameOverNow() 
    	&& (p.robotRunning()==null)
    	&& !hasDeferredMessages());
    }
    public void startRobotTurn(commonPlayer p)
    {
        if (canStartRobotTurn(p))
        {	//G.print("Start turn for "+p+" by "+my);
            p.startRobotTurn();
        }
    }
    
    public boolean allRobotsIdle()
    {
        for (commonPlayer p : players)
        {
            if ((p != null) 
            		&& (p.robotPlayer != null) 
            		&& (p.robotRunning()!=null)) //waiting or waiting for color
            {
                return (false);
            }
        }

        return (true);
    }
    public void updatePlayerTime(long increment,commonPlayer p)
    {	if(p!=null)
    	{
    	long newtime = (p.elapsedTime + increment);
        p.setElapsedTime(newtime);
        if(!p.spectator) { doTime(p,myFrame.doSound()); }
    	}
    }
    public void doTruncate()
    {
        if (reviewMode())
        {
            truncateHistory();
        }
    }

    /** 
     * get the alternate display board from a robot that is currently running.
     * Note that the robot's board may not be happy if used for display when
     * the robot is not stopped at a breakpoint.
     * @return an alternate board
     */
    public BoardProtocol disB()
    {
        if (useAlternateBoard)
        {	if(dupBoard!=null) { return(dupBoard); }	// duplicate for editHistory
            commonPlayer p = currentRobotPlayer();

            if (p != null)
            {
                SimpleRobotProtocol rob = p.robotBeingMonitored();

                if (rob != null)
                {
                    return (rob.disB());
                }
            }
        }

        return (null);
    }
        
    /** get a display board, and indicate a duplicate is in used with
     * a black border.  This will not generate a copy board if gc is null
     * @param gc
     * @return a BoardProtocol (ie a board)
     */
    public BoardProtocol disB(Graphics gc)
    {	
    	if(gc!=null)
    	{  //possibly select an alternate board
	   	  BoardProtocol disb = disB();
	      if(disb!=null) 
	      { 
	    	if(boardRect!=null) { G.frameRect(gc,Color.black,boardRect); }; // give a visual indicator
	    	return(disb);
	      }
    	}
    	return(getBoard());
	}
    

    public sgf_game[] parse_sgf_file(String ss, PrintStream p)
    {
        return (sgf_reader.parse_sgf_file(ss, p));
    }

    public sgf_game[] parse_sgf_file(File file, PrintStream errors)
    {
        return (sgf_reader.parse_sgf_file(file, errors));
    }

    public sgf_game[] parse_sgf_file(String zipname, String filename,
        PrintStream errors)
    {
        return (sgf_reader.parse_sgf_file(zipname, filename, errors));
    }

    public sgf_game[] parse_sgf_file(URL url, PrintStream errors)
    {
        return (sgf_reader.parse_sgf_file(url, errors));
    }

    public sgf_game[] parse_sgf_file(URL zipurl, String filename,
        PrintStream errors)
    {
        return (sgf_reader.parse_sgf_file(zipurl, filename, errors));
    }

    public boolean sgf_save(PrintStream out, sgf_game... games)
    {
        return (sgf_reader.sgf_save(out, games));
    }

    public boolean sgf_save(String file, sgf_game... games)
    {
        return (sgf_reader.sgf_save(file, games));
    }

    public String gameName()
    {
    	return sharedInfo.getString(OnlineConstants.GAMENAME,"gamename");
    }
    public void doSaveCollection()
    {
        doSaveCollection(sgf_reader.do_sgf_dialog(FileDialog.SAVE, gameName(),"*.sgf"));
    }

    // play rapidly through the entire collection as a test
    public void doReplayCollection()
    {	if(hidden.Games!=null)
    	{for(int i=0;i<hidden.Games.size(); i++)
    	{
    	sgf_game game = hidden.Games.elementAt(i);
    	String sn = game.short_name();
    	if(sn==null || "".equals(sn)) { game.set_short_name("Game #"+i); }
    	ReplayGame(game);   	
    	repaint();
    	G.doDelay(10);
    	}}
    }
    public void stop(boolean s) {};
    // play rapidly through the entire collection as a test
    int fileVisits = 0;
    int fileProblems = 0;
    public void doReplayFolder()
    {	String from = "file:///g/share/projects/boardspace-html/htdocs/"+G.getString(REVIEWERDIR+sharedInfo.getInt(exHashtable.SAVE_GAME_INDEX,-1),null);
    	if(from!=null) { from = G.getUrl(from).getPath(); }
    	JFileChooser fd = new JFileChooser(from);
    	fd.setDialogTitle("Select a sgf directory or zip");
    	fd.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
    	fd.showOpenDialog(null);
    	File f = fd.getSelectedFile();
    	fileVisits = 0;
    	fileProblems = 0;
    	if(f!=null)
    	{
        G.print("Selected "+f);
    	FileMapper map = new FileMapper();
    	map.visit(f, new FileVisitor() {
    	String phase = "";
    	    private void doReReplay()
    	    {	BoardProtocol b = getBoard();
    	    	long startingDigest = b.Digest(); 
    	    	//boolean gameOver = b.GameOver();
				phase = "replay";
				doWayBack(replayMode.Replay);
				doScrollTo(FORWARD_TO_END);
				long endingDigest = b.Digest();
				G.Assert(startingDigest==endingDigest,"digest after replay is different");
				//G.Assert(gameOver,"not game over after initial play");
				G.Assert(hidden.Games.size()==1,"file contains %s games",hidden.Games.size());
    	    }
			public void visit(File u) {
				//G.print(u);
				phase = "";
				try {
				fileVisits++;
				phase = "play";
				doLoadGameFile(u.getPath());
				doReReplay();
				// replayed successfully
				//String name = u.getAbsolutePath();
				//String newname = name.replaceFirst("testgames","testgames-tofix-4");
				//u.renameTo(new File(newname));
				}
				catch(Throwable err)
				{	repaint();
					fileProblems++;
					G.print(""+fileVisits+": "+phase+" Problem in file:"+u+" "+err);
				}
			}

			public void visitZip(File zip,ZipEntry e,ZipInputStream s)
			{	//G.print(e);
				phase="";
				try {
				fileVisits++;
				phase = "read";
				sgf_game[] gg = sgf_reader.parse_sgf_file(zip.toString(),e.getName(),s,System.out);
				if(gg!=null)
				{hidden.Games = new sgf_gamestack();
           	     hidden.Games.pushArray(gg);
           	     phase = "play";
                 if((gg.length>0)) 
                 { selectGame(gg[0]);
                   doReReplay();
                 /* repaintCanvas();*/}
				}}
				catch(Throwable err)
				{	repaint();
					fileProblems++;
					G.print(""+fileVisits+": "+phase+" Problem in zip file:"+zip+" "+e+" "+err);
				}
			}
			public boolean filter(String name, boolean isDirectory, File parent) {
				return(isDirectory || name.endsWith(".sgf"));
				} 
			} );
    	G.print(""+fileVisits+" files visited "+fileProblems+ " problems");

    	}

    }
    
    public void doSaveGame()
    {	doSaveGame(save_game());
    }

    public void doSaveGame(sgf_game game)
    {
        String ss = sgf_reader.do_sgf_dialog(FileDialog.SAVE,gameName(), "*.sgf");
        if (ss != null)
        {
            int lastDot = ss.lastIndexOf('.');
            int lastSlash = ss.lastIndexOf('/');
            if((lastDot<0) || (lastSlash>lastDot)) 
            	{ ss += ".sgf"; 
            	}
            
            sgf_save(ss, game);
        }
    }
    public void doSaveUrl(String file)
    {	if(zipArchive!=null)
    	{
    	String f = unfile(file);
    	int ind = zipArchive.lastIndexOf('/');
    	if(ind>=0) { file = zipArchive.substring(0,ind+1)+f; }
    	}
    	int dot = file.lastIndexOf('.');
    	int slash = file.lastIndexOf('/');
    	if(dot<0 || slash>dot) 
    		{ file += ".sgf"; 
    		}
    	sgf_reader.sgf_save(G.getUrl(file),save_game());
    }
    
    public void doSaveCollection(String ss)
    {
        if (ss != null)
        {
            if (hidden.selectedGame!=null)
            {
            	hidden.Games.replace(hidden.selectedGame,save_game());
            }
            int lastDot = ss.lastIndexOf('.');
            int lastSlash = ss.lastIndexOf('/');
            if((lastDot<0) || (lastSlash>lastDot)) { ss += ".sgf"; }

            sgf_save(ss, hidden.Games.toArray());
        }
    }
    public commonPlayer[] getPlayers() { return(players); }
    public commonPlayer getPlayer(int n)
    {
    	if(n>=0 && n<players.length) { return(players[n]); }
    	return(null);
    }
    /**
     * this gets player n's commonPlayer object, or a temporary new commonPlayer
     * if the player hasn't arrived yet.  Use this in setLocalBounds so the layout
     * can always be done based on real player objects.
     * @param n
     * @return get a player or a new temporary player table
     */
    public synchronized commonPlayer getPlayerOrTemp(int n)
    {	
     	extendPlayers(n);
    	commonPlayer p = getPlayer(n);
    	if(p ==null) { 
    		p=tempPlayers[n];
    		if(p==null) { tempPlayers[n]= p = new commonPlayer(n); }
    	}
    	return(p);
    }
    public void extendPlayers(int idx)
    {
    	G.Assert((idx>=0)&&(idx<=10), "%s is not a plausible number of players",idx);
    	if(idx>=players.length) 
    		{ adjustPlayers(idx+1);
    		}
    }
    public void adjustPlayers(int n)
    {	if(n!=players.length)
    	{
    	G.Assert((n>0)&&(n<=6),"too many players");
    	commonPlayer newp[] = new commonPlayer[n];
    	int minp = Math.min(n,players.length);
    	for(int i=0;i<minp;i++) { newp[i]=players[i]; }
    	//for(int i=minp;i<n;i++) { newp[i] = new commonPlayer(i); }
    	players = newp;
    	resetBounds();
 
    	}
    }
    public boolean selectGame(sgf_game game)
    {	ReplayGame(game);
    	hidden.selectedGame = game;
    	return(true);
    	
    }
    public boolean selectGame(String selected)
    {
        if (hidden.Games != null)
        {
            for (int i = 0; i < hidden.Games.size(); i++)
            {
                sgf_game game = hidden.Games.elementAt(i);

                if (game != null)
                {
                    String name = game.short_name();

                    if (name == null)
                    {
                        name = "Game " + game.sequence;
                    }

                    if (name.equals(selected))
                    {
                        return(selectGame(game));
                    }
                }
            }
        }

        return (false);
    }

    public void doLoadGameFile(String ss)
    {
        if (ss != null)
        {
            theChat.sendAndPostMessage(ChatInterface.GAMECHANNEL, KEYWORD_LOBBY_CHAT, "Loading " + ss);
            hidden.selectedGame = null;

            PrintStream pw = Utf8Printer.getPrinter(System.out);
            
            sgf_game gg[] = sgf_reader.parse_sgf_file(ss, pw);
           	if(gg!=null)
            	{hidden.Games = new sgf_gamestack();
            	 hidden.Games.pushArray(gg);
                 if((gg.length>0)) { selectGame(gg[0]); }
            	}
            pw.flush();
        }
    }

    public sgf_game addGame(CommonMoveStack moves,String name)
    {	for(int i=1,lim=moves.size();i<lim;i++) { moves.elementAt(i-1).next = moves.elementAt(i);}
		sgf_game game = save_game(moves);
		game.getRoot().set_property(sgf_names.gamename_property,name);
		return(addGame(game));
    }
    public sgf_game addGame(sgf_game game)
    {
		if(hidden.Games==null) { hidden.Games=new sgf_gamestack(); }
		hidden.Games.push(game);
		game.sequence = hidden.Games.size();
		return(game);
    }
    void removeAll(Menu gm)
    {
        //jdk 1.1
        gm.removeAll();
    }
    

    void doLoadGame()
    {
        String ss = sgf_reader.do_sgf_dialog(FileDialog.LOAD,gameName(), ("*.sgf"));
        doLoadGameFile(ss);
    }
    String unfile(String name)
    {
    	int ind = name.indexOf(':');
    	return(ind>=0? name.substring(ind+1) : name);
    }
    String zipArchive = null;
    public void setZipArchive(String name) { zipArchive = name; }
    public void doLoadUrl(String name, String gamename)
    {	       		
     	if (name.endsWith(".zip"))
        {
            zipArchive = name;
            return;
        }
    	else if(name.endsWith(".zzz"))
    	{
    		zipArchive = name;
    		gamename = null;
    		name = null;
    	}
    	else if (name.endsWith("/"))
        {
            zipArchive = null;
            return;
        }
     	
 

        {
          	String old = G.setErrorContext("reading "+name+" "+gamename);
          	PrintStream printer = Utf8Printer.getPrinter(System.out);
            //System.out.println("Geturl "+name);
            sgf_game gg[] = (zipArchive == null)
                ? sgf_reader.parse_sgf_file(G.getUrl(name, true), printer)
                : sgf_reader.parse_sgf_file(G.getUrl(zipArchive, true), unfile(name), printer);
            if(gg!=null)
            {
            	hidden.Games = new sgf_gamestack();
            	hidden.Games.pushArray(gg);
            if((gg.length>0) && "".equals(gamename)) { selectGame(gg[0]); }
            	else { selectGame(gamename); }
            }
            printer.flush();
            G.setErrorContext(old);
        }
    }
    /**
     * this is the method called to produce a game record.  For display in a window.
     */
    public void doEmailSgf()
    {
        sgf_game game = save_game();
        Utf8OutputStream lbs = new Utf8OutputStream();
        PrintStream os = Utf8Printer.getPrinter(lbs);
        sgf_save(os, game);
        os.close();
        String msg = lbs.toString();
        G.emailGame("",s.get(RecordOfGame,game.short_name()),msg);
     }
    /**
     * this is the method called to produce a game record.  For display in a window.
     */
    public void doShowSgf()
    {
        sgf_game game = save_game();
        Utf8OutputStream lbs = new Utf8OutputStream();
        PrintStream os = Utf8Printer.getPrinter(lbs);
        sgf_save(os, game);
        os.close();
        String msg = lbs.toString();
        commonDisplay f = new commonDisplay(s.get(RecordOfGame,game.short_name()));
		f.setText(msg);
    }
    public int playerNumberToken(String st)
    	{
    	if(st.equalsIgnoreCase("p-1")) { return(0); }
    	if(st.length()==2)
    	{
    	int ch = st.charAt(0);
    	int nn = st.charAt(1)-'0';
    	if(((ch=='p')||(ch=='P')) && (nn>=0) && (nn<=players.length)) { return(nn); }
    	}
    	return(-1);
     }
    public abstract void ReplayMove(sgf_node no);
    public void ReplayVariation(sgf_node no) { ReplayMove(no); }
    
    public boolean parsePlayerCommand(String name,String value)
    {	int player = playerNumberToken(name);
    	 if ((player>=0)&&(player<players.length))
         {	commonPlayer p = players[player];
             if (p == null)
             {
                 p = players[player] = new commonPlayer(player);
             }
              
             StringTokenizer tokens = new StringTokenizer(value);
             String first = tokens.nextToken();


                 if(parsePlayerInfo(p,first,tokens)) {}
                 else
                 { parsePlayerExecute(p,first,tokens);
                 }
         return(true);
         }	
    	 return(false);
    }
    public boolean parseVersionCommand(String name,String value,int max)
    { 	if (name.equals(version_property))
        {	int vv = G.IntToken(value);
        	if(vv>0 && vv<=max) { return(true); }
            throw G.Error("Game version %s not handled",value);
        }	
    	return(false);
    }
    
    public boolean parsePlayerExecute(commonPlayer p,String first,StringTokenizer tokens)
    {	
    	String next = tokens.hasMoreTokens() ? tokens.nextToken() : "";
    	// note; this breaks replays of games from the logs that include edits and errors after edits.
    	// normally the games won't include edit anyway
    	// if("edit".equals(next) && getBoard().GameOver()) { return(true); }
       	String rest = "".equals(next) ? next : next+" "+G.restof(tokens);
       	String msg = first + " "+ rest;
        return(PerformAndTransmit(msg, p.boardIndex,false,replayMode.Replay));	
    }
    
    public boolean parsePlayerInfo(commonPlayer p,String first,StringTokenizer tokens)
    {	if(KEYWORD_ID.equals(first))
    	{
    	String name = tokens.nextToken();
    	while(tokens.hasMoreTokens() 
    			&& (name.charAt(0)=='"') 
    			&& (name.charAt(name.length()-1)!='"')) 
    		{ name = name + " " +tokens.nextToken(); // accumulate the full quoted name  
    		}	
		p.setPlayerName(G.trimQuotes(G.decodeAlphaNumeric(name)),false,this);
		return(true);
    	}
    	else if(exHashtable.TIME.equals(first)
   				|| exHashtable.RANKING.equals(first) 
   				|| OnlineConstants.COUNTRY.equals(first))
    	{
    		p.setPlayerInfo(first,G.restof(tokens)); 
    		return(true);
 	   	}
        return(false);
    }
    private int parsedTime = -1;
    public Error replayNode(sgf_node root,boolean var)
    { 
    	Error theError = null;
   		try	{
   		while((root!=null) && (theError==null))
   		{	parsedTime = -1;
  			if(var) { ReplayVariation(root); } else { ReplayMove(root); }
  			if(parsedTime>=0) { History.top().setElapsedTime(parsedTime); }
   			int nSuccessors = root.nElements();
   			if(nSuccessors <= 1) { root = root.firstElement(); }	// iterate for simple nodes
   			else { 	
   					int n = History.size();
   				    for(int nth = 0;
   						(theError==null) && (nth<nSuccessors);
   	    				nth++)
   					{
   				     sgf_node elem = root.nThElement(nth);
   					 theError =  replayNode(elem,(nth!=0));
   					 doScrollTo(n);
   					}
   				    
   					root = null;
   			}
   		}
   		}
   		catch (Error err) 
   			{ theError = err; }
   		
   		return(theError);
    }
    //
    // select the principle variation.  The "natural" replay of a complex tree leaves
    // the last variation rather than the first as the final state.
    //
    void selectPrincipleVariation()
    {	
    	rewindHistory(1);		// this truncates the history
   		commonMove m = History.elementAt(0);
   		commonMove n;
   		// m.firstVariation() follows the selected path
   		// m.getVariation(0) selects the actual first
   		while((n=m.getVariation(0))!=null)
   		{	History.addElement(n);	// add the intended element to the history
   			if(m.nVariations()>1)	// make sure next is correct
   			{	m.next = n;
   			}
   			hidden.RedoStep(replayMode.Replay,n);	// replay it
   			m = n;
    	};
    }
    /** replayGame replays a SGF record structure.  This is the normal
     * route for game reviewers get games.  
     */
    public void ReplayGame(sgf_game ga)
        {
            boolean sound = myFrame.doSound();
            G.setNextIntCompatibility(false);
            mutated_game_record = false;
            if (sharedInfo.getInt("session") <= 0)
            {
                theChat.clearMessages(true);
                commentedMove = commentedMoveSeen = null;
            }

            theChat.setShortNameField("");
            theChat.setNameField("");
            Error theError = null;
            // this is to enhance replayability of archived games, 
            // where the rules may have evolved or old archives may
            // be damaged.  Setting the flag doesn't intrinsically
            // do anything, but is information available to the game.
            // 
            // this flag needs to remain set forever, which is ok
            // since we can't switch from replay back to live games.
            //
            try
            {
            	BoardProtocol b = getBoard();
                b.setPermissiveReplay(true);
                b.setColorMap(null);		// standardize the color map
                b.resetClientRevision();	// forget revision from the previous game 
                if (sound)
                {	// temporarily turn sound off
                    myFrame.setDoSound(false);
                }
               
                doInit(false);
                theChat.setShortNameField("Game " + ga.sequence);
                theChat.clearMessages(false);
                //b.board_state=PUZZLE_STATE;			//temp
                sgf_node root = ga.getRoot();
                //
                // this is nasty.  the color map has to be in effect when the setup property is seen, so put it first here.
                //
                sgf_property rootProperties = root.properties;
                sgf_property colormap = sgf_property.get_sgf_property(rootProperties,colormap_property);
                if(colormap!=null)
                {
                	sgf_property setup = sgf_property.get_sgf_property(rootProperties,setup_property);
                	if(setup!=null)
                	{	rootProperties = sgf_property.remove_sgf_property(rootProperties,setup);
                		setup.next = colormap.next;
                		colormap.next = setup;
                		root.properties = rootProperties;
                	}
                }
                theError = replayNode(root,false);
                
            }
            finally
            {
           		if(theError!=null) { throw theError; }
                if (sound)
                {
                    myFrame.setDoSound(true);
                }
                if(mutated_game_record)
                {
                	selectPrincipleVariation();
                }
            }
            resetBounds();
            generalRefresh();


            if ("".equals(theChat.nameField()))
            {
                String sf = ga.source_file;
                int idx = (sf==null)? 0 : sf.lastIndexOf("/");

                if (idx > 0)
                {
                    sf = sf.substring(idx + 1);
                }

                idx = (sf==null)?0:sf.lastIndexOf(".");

                if (idx > 0)
                {
                    sf = sf.substring(0, idx);
                }

                theChat.setNameField(sf);
                {	sgf_node root = ga.getRoot();
                	if("".equals(root.get_property(gamename_property))) 
                		{ root.set_property(gamename_property,sf);
                   		}
                }
            }
        }
    
    public void saveNode(sgf_node curr,commonMove m)
    {	while(m!=null)
    	{
        String ms = m.longMoveString();
        if((ms!=null) && !("".equals(ms)))
           {
            sgf_node nn = new sgf_node();
            curr.addElement(nn, Where.atEnd);
            curr = nn;
            curr.set_property(m.playerString(), ms);
            String comm = m.getComment();
            if (comm != null)
            {
                curr.set_property(comment_property, comm);
            }
            int tm = m.elapsedTime();
            if(tm>=0) 
            {
            	curr.set_property(time_property, ""+tm);
            }
            
        int nvar = m.nVariations();
        if(nvar>1) 
        	{
        	commonMove next = m.next;
        	if(next!=null) { saveNode(nn,next); }	// use the selected variation first
        	for(int i=0;i<nvar;i++) 
        		{ commonMove var =  m.getVariation(i);
        		  if(var!=next) { saveNode(nn,var); }
        		}
        		m = null; 
        	}
        else { m = m.getVariation(0); curr = nn; }
    	}}
   }
    /**
     * override this method to add properties to the sgf root when saving a game
     * @param root
     */
    public void setRootProperties(sgf_node root)
    {
    	
    }
    
    /** save the game as a sgf record structure, which will be printed
     * to a file.  This path is actually not much used, since we don't
     * usually output files directly.
     */
    public sgf_game save_game(CommonMoveStack  moves)
    {
        sgf_game game = new sgf_game();
        sgf_node root = game.getRoot();
        sgf_node curr = root;
  
        for (int i = players.length - 1; i >= 0; i--)	// iterate backwards, last player first
        {
            commonPlayer p = players[i];

            if (p != null)
            { //don't translate the color here

                {
                    String rank = p.getPlayerInfo(exHashtable.RANKING);

                    if ((rank != null) && !("".equals(rank)))
                    {
                        root.set_property(p.playerString(), exHashtable.RANKING+" " + rank);
                    }
                }

                {
                    String ct = p.getPlayerInfo(OnlineConstants.COUNTRY);

                    if ((ct != null) && !("".equals(ct)))
                    {
                        root.set_property(p.playerString(), OnlineConstants.COUNTRY+" " + ct);
                    }
                }
                // properties are being built backwards, so do the name last, which will be first.
                root.set_property(p.playerString(), " "+KEYWORD_ID+" " + p.prettyName("p"+i));

            }
        }
        root.set_property(gamename_property, theChat.shortNameField());
        root.set_property(gametitle_property, theChat.nameField());
        root.set_property(setup_property, gameType());
        if(offline()||USE_COLORMAP)
        {
        // only emit color map information if it's active in this environment
         root.set_property(colormap_property,colorMapString());
        }
        root.set_property(game_property, "" + sgfGameType());
        setRootProperties(root);
        saveNode(curr,moves.elementAt(0));
        

        for (int i = players.length - 1; i >= 0; i--)
        {
            commonPlayer p = players[i];

            if (p != null)
            {
                String timestring = p.getPlayerInfo(exHashtable.TIME);

                if (!"".equals(timestring))
                {
                    timestring = " "+exHashtable.TIME+" " + timestring;
                    curr.set_property(p.playerString(), timestring);
                }
            }
        }

        return (game);
    }
    /** save the game as a sgf record structure, which will be printed
     * to a file.  This path is actually not much used, since we don't
     * usually output files directly.
     */
    public sgf_game save_game()
    {	return(save_game(History));
    }
    
    public int[] getColorMap() 
    { return(getBoard().getColorMap()); 
    }
    
    public String colorMapString()
    {
        int colormap[] = getColorMap();
        String colorMapString = "";
        if(colormap!=null) 
        	{ String comma = "";
        	  for(int d : colormap) { colorMapString += comma+d; comma=","; }
        	}
        else { colorMapString = "0,1"; }
        return(colorMapString);
    }
    /** print the game record directly from the history.  This
     * is the way games are recorded by the server: printed by 
     * this PrintStream into a string, which is transmitted to the
     * server over the net connection, and the server writes the file.
     * The net effect should be very similar to the SGF output.
     */
    public void printGameRecord(PrintStream ps, String startingTime,CommonMoveStack  his,String filename)
    {
        String nameString = filename;
        ps.println("(;");
        ps.println(game_property+ "[" + sgfGameType() + "]" + version_property +"["+ sgfGameVersion()+"]");
        // colormap immediately after the game id, so it will be active when the setup happens
        if(offline()||USE_COLORMAP)
        	{
            // only emit color map information if it's active in this environment
        	String colormap = colorMapString();
        	if(colormap!=null) {  	ps.println(colormap_property+"["+colormap+"]"); }
        	}
        ps.println(setup_property+"[" + gameType() + "]");
        ps.println(date_property+ "[" + startingTime + "]");
        ps.println(gamename_property + "[" + nameString + "]");
        if(GameOver())
        {
        	ps.println(result_property+ "["+gameOverMessage()+"]");
        }
        for (commonPlayer p = commonPlayer.firstPlayer(players); p != null;
                p = commonPlayer.nextPlayer(players, p))
        {
            if (!nameString.equals(""))
            {
                nameString += "-";
            }

            nameString += p.trueName;
        }

 
        // version 1 original implementation
        // version 2 after initial fiascos.  Player sequence stabalized
 
        for (commonPlayer p = commonPlayer.firstPlayer(players); p != null;
                p = commonPlayer.nextPlayer(players, p))
        { //don't translate color here
            ps.println(p.playerString() + "[id \"" + p.trueName + "\"]");

            {
                String rank = p.getPlayerInfo(exHashtable.RANKING);

                if ((rank != null) && !("".equals(rank)))
                {
                    ps.println(p.playerString() + "["+exHashtable.RANKING+" " + rank + "]");
                }
            }

            {
                String ct = p.getPlayerInfo(OnlineConstants.COUNTRY);

                if ((ct != null) && !("".equals(ct)))
                {
                    ps.println(p.playerString() + "["+OnlineConstants.COUNTRY+" " + ct + "]");
                }
            }
        }

        // this is the standard method since forever.  Since it works perfectly,
        // be careful about featurizing it.  replace this clause with printNode(..);
        // would be the next step.
        for (int i = 0; i < his.size(); i++)
        {
        	commonMove m = his.elementAt(i);
        	String str = m.longMoveString();
        	if(str!=null && !"".equals(str))
        	{  ps.print("; ");
        	   ps.print(m.playerString());
        	   ps.print("[");
        	   ps.print(sgf_property.bracketedString(str));
        	   ps.print("]");
        	   int tm = m.elapsedTime();
        	   if(tm>=0)
        	   { ps.print(time_property);
        	     ps.print("[");
        	     ps.print(tm);
        	     ps.print("]");
        	   }
        	   ps.println();
         	}
        }

        ps.println(";");

        for (commonPlayer p = commonPlayer.firstPlayer(players); p != null;
                p = commonPlayer.nextPlayer(players, p))
        {
            int col = p.colourIndex();
            if ((col >= 0))
            {
                ps.println(p.playerString() + "["+exHashtable.TIME+" " +
                    G.timeString(p.elapsedTime) + "]");
            }
        }

        ps.println(")");
    }
    public void printDebugInfo(PrintStream ps)
    {
        if (rawHistory.size() > 0)
        {
            printGameRecord(ps, "Raw History", rawHistory, "");
        }
    }
    
    /**
     * override this method to censor the game history before printing.
     * this isn't intended for real censorship, just to remove unnecessary
     * elements.
     * 
     * @param hist
     * @return
     */
    public CommonMoveStack censoredHistory(CommonMoveStack hist) 
    { 	
    	CommonMoveStack newHist = hist;
     	boolean some = false;
    	int sz = hist.size()-1;
    	while(sz>=0)
    	{
    		commonMove m = newHist.elementAt(sz);
    		if(m.op==MOVE_PEEK)
    		{	if(!some) 
    				{ some = true;
    				  // implements copy on write.  This ought to be unnecessary
    				  // since it's the very last thing we do, but we're being conservative here.
    				  newHist = new CommonMoveStack();
    				  newHist.copyFrom(hist);
    				}
    			newHist.remove(sz,true);
    		}
    		sz--;
    	}
    	if(some)
    	{	// renumber
    		for(int i=newHist.size()-1; i>=0; i--)
    		{
    			commonMove old = newHist.elementAt(i);
    			commonMove n = old.Copy(null);
    			n.setIndex(i);
    			newHist.setElementAt(n,i);
    		}
    	}
    	return(newHist);
    }
    
    public void printGameRecord(PrintStream ps, String startingTime,String filename)
    {
        printGameRecord(ps, startingTime, censoredHistory(History), filename);

        if (G.debug())
        {
            printGameRecord(ps, startingTime, rawHistory, filename);
        }
    }  

    boolean startedARobot = false;
    public void ViewerRun(int waitTime)
    {	
    	runHiddenWindows();	// feed mouse events from hidden windows
    	for (int i = 0; i < players.length; i++)
        {   commonPlayer p = players[i];
            if(p!=null)
            	{
            	if(p.updated)
            		{ repaint(250,"player changed"); 
            		  p.updated=false; 
            		}
            	}
         }
        if (hidden.resign_needed)
        {	hidden.resign_needed=false;
        	doResign();
        }
        if (hidden.loadGameNeeded)
        {
        	hidden.loadGameNeeded = false;
            doLoadGame();
        }

        if (hidden.saveGameNeeded)
        {
        	hidden.saveGameNeeded = false;
            doSaveGame();
        }

        if (hidden.saveCollectionNeeded)
        {
        	hidden.saveCollectionNeeded = false;
            doSaveCollection();
        }
        if(hidden.replayCollectionNeeded)
        {
        	hidden.replayCollectionNeeded = false;
        	doReplayCollection();
        }
        if(hidden.replayFolderNeeded)
        {
        	hidden.replayFolderNeeded = false;
        	doReplayFolder();
        }
        boolean spritesIdle =  spritesIdle();
        boolean idle = spritesIdle && SoundManager.soundIdle();
       
        if(!spritesIdle) 
        	{ repaintSprites(); 
        	}
       
        if(( ((reviewOnly || mutable_game_record) && extraactions)  || offline() ) && !reviewMode() && idle)
        {	
            commonPlayer who = currentRobotPlayer();
	        if (who != null)
	        {if(who.robotStarted())
	        	{
	            startRobotTurn(who);
	        	}
	       String m = who.getRobotMove();
	       // this is where offline robot moves are made
	       if(m!=null) 
	       		{  
	    	    PerformAndTransmit(m); 
	    	    waitTime = Math.min(waitTime,20);
	       	    if(GameOverNow()) { stopRobots(); }
	       		}
	        }
        }
        if(animating && spritesIdle) 
    	{ if(reviewMode()) 
    		{long now = G.Date();
    		 int interval = (int)(250*masterAnimationSpeed);
    		 long pause = now-hidden.lastAnimTime;
    		 if(pause<0) { waitTime = Math.min(-(int)pause, waitTime); }	// got here too soon
    		 else {
    			 doForwardStep(replayMode.Single);
    			 repaint(0,"forward step");

    			 long next = hidden.lastAnimTime = Math.max(now, hidden.lastAnimTime+interval);
    			 waitTime = (int)(next-now);
    		 } 			    		 
    		}
    		else 
    		{ animating = false; }
    	}
        // not completely satisfactory to do this here,
        // because "whoseTurn" may change and get out of 
        // synch with the Game object.
        // handleDeferredMessages();	// if we just left review mode
        super.ViewerRun(waitTime);

    }
    public void doRobotMove(String m)
    {
    	PerformAndTransmit(m,false,replayMode.Replay);
    }
    public void doResign()
    {   
    if(players.length>2) 
    	{theChat.postMessage(ChatInterface.GAMECHANNEL, KEYWORD_CHAT,
            s.get(NoResignMessage));
    	}
    	else
    	{ 
    	if (ourActiveMove())
        {
            PerformAndTransmit(RESIGN);
        }
        else
        {
            theChat.postMessage(ChatInterface.GAMECHANNEL, KEYWORD_CHAT,
                s.get(CantResign));
        }
    	}
    }    
    
    public void setDoneState(boolean isDone)
    {	long now = G.Date();
    	hidden.doneAtTime = isDone ? now : 0;
    	hidden.startTurn=now; 
    }
    
    // do time related things for the board.
    public void doTime(commonPlayer whoseTurn,boolean doSound)
    { boolean turnChange = whoseTurn!=hidden.lastPlayer;
      boolean tournamentMode = sharedInfo.getBoolean(exHashtable.TOURNAMENTMODE,false);
      long currentT = G.Date();
      if(turnChange)
      {	hidden.lastPlayer = whoseTurn;
      	hidden.startTurn = currentT;
      }
      if ((whoseTurn==getActivePlayer()) && doSound && playTickTockSounds)
      {	long elapsed = (currentT - hidden.startTurn); 
        if ( (hidden.startTurn > 0) 
        		&& (((hidden.doneAtTime>0)&& (elapsed>hidden.timePerDone)) 
        		    || (elapsed > hidden.timePerTurn)))
           {
             SoundManager.playASoundClip(clockSound,5000);
             hidden.startTurn = currentT;	// restart the timer
             if(hidden.doneAtTime>0) { hidden.doneAtTime=currentT; }
           }

         if (tournamentMode)
            {
       	    long newtime = whoseTurn.elapsedTime;
            if ((hidden.hurryState<2) && (newtime > hidden.hurryTime))
                {   hidden.hurryState=2;
                SoundManager.playASoundClip(hurrySound,1000);
                }
            else if ((hidden.hurryState==0) && (newtime > (hidden.hurryTime-1000)))
            	{  
            	hidden.hurryState=1;
            	SoundManager.loadASoundClip(hurrySound);
            	}
              }
        }
    }

    /**
     * draw an image 
     * @param gc	the graphics
     * @param im	the image to draw
     * @param scale	the x,y,overall scale
     * @param x		x offset
     * @param y		y offset
     * @param boxw  box width and height
     * @param xscale xscale (y is unchanged)
     * @param jitter
     */
    public void drawImage(Graphics gc, Image im, double scale[],int x, int y, 
    		double boxw,double xscale,double jitter)
    {
    	drawImage(gc,im,scale,x,y,boxw,xscale,jitter,null,false);
    }
    /**
     * draw an image
     * @param gc
     * @param im
     * @param boxw
     * @param scale
     * @param x
     * @param y
     */
    public void drawImage(Graphics gc, Image im, double scale[],int x, int y,double boxw) 
    {
    	drawImage(gc,im,scale,x,y,boxw,1.0,0.0,null,false);
    }
  /** this is a horroble kludge to keep old game records
   * for a few games valid.  See the comments near G.nextInt
   * for more detail.  Affected games are container and yspahan 
   * for before 8/25/2012
   * @param b
   * @param name
   * @param value
   */
 public void nextIntCompatabilityKludge(BoardProtocol b,String name,String value,String ref)
 {
 	if(name.equals(date_property))
	{
 	BSDate result = G.parseDate(value,"EEE MMM dd kk:mm:ss z yyyy");
	BSDate refdate = G.parseDate(ref,"MMM dd yyyy");
	boolean newformat = result.getTime()<refdate.getTime();
		
	if(newformat!=G.OLD_NEXTINT_COMPATABILITY) 
		{	// note that games that depend on this (ie; container) need to
			// note this in their history initialization so spectators will
			// also get the note.
			G.setNextIntCompatibility(newformat);
			b.doInit();
 		}
	}
 }

/**
 * when reloading a game from a sgf game record, handle stock
 * properties such as game name, comments, etc.
 * @param name
 * @param value
 * @return true if this property was handled
 */
public boolean replayStandardProps(String name,String value)
{	
    //System.out.println("prop " + name + " " + value);
    if (name.equalsIgnoreCase(gamename_property))
    {   theChat.setShortNameField(value);
        return(true);
    }
    else if (name.equalsIgnoreCase(gametitle_property))
    {
        theChat.setNameField(value);
        return(true);
    }
    else if (name.equalsIgnoreCase(date_property))
    {
        theChat.sendAndPostMessage(ChatInterface.GAMECHANNEL, KEYWORD_LOBBY_CHAT,
            s.get(PlayedOnDate,value));
        return(true);
    }
    else if(name.equalsIgnoreCase(colormap_property))
    {
    	
    	getBoard().setColorMap(G.parseColorMap(value)); 
    	return(true);
    }
    else if(name.equalsIgnoreCase(time_property))
    {
    	parsedTime = G.IntToken(value);
    	return(true);
    }
    theChat.addAMessage("prop " + name + " = " +  value);
    return(false);
	}
//
// this is the default method used by all except Loa.  It's logic is very
// carefully balanced, so don't disturb it without careful testing
//

/**
 * handle mouse motion.  This is called in the run loop, not synchronous
 * with the mouse events.  The principle effect is to call your {@link #redrawBoard}
 * method with gc=null, for the purpose of locating what the mouse must
 * be pointing to.
 */
public HitPoint MouseMotion(int eventX, int eventY, MouseState upcode)
{	//if(upcode==MouseState.LAST_IS_UP) { painter.setRecord(false); }
	//if(upcode==MouseState.LAST_IS_PINCH||upcode==MouseState.LAST_IS_DOWN) { painter.setRecord(true); } 
	HitPoint p =  new HitPoint(eventX, eventY,upcode);
	HitPoint drag = getDragPoint();
    boolean newDrag = (drag!=null && drag.dragging) && (upcode!=MouseState.LAST_IS_UP);
	p.dragging =  newDrag;			//p.dragging indicates if something is being dragged
	p.inStandard = drag!=null ? drag.inStandard : false;
    p.hitCode = p.dragging ? drag.hitCode : DefaultId.HitNoWhere;			//if dragging, lock the hitCode on the drag
    
    if(p.dragging && (p.hitCode==VcrId.Slider))				// special treatment of the vcr slider
    	{   			  
    	drawVcrSlider(p,null);
    	}
    	else
    	{
    	p.hitCode = DefaultId.HitNoWhere;
    	p.spriteColor =null;
    	p.spriteRect = null;
    	//
    	// with on the fly rotations of the pointer for playtable, the absolute
    	// x,y tends to drift.  Combat this and other accidents by saving the
    	// location over the interaction with the client code.
    	//
     	int hx = G.Left(p);
     	int hy = G.Top(p);
        redrawBoard(p);
        G.SetLeft(p, hx);
        G.SetTop(p,hy);



    	// this doesn't integrate well with all the new layout logic
    	//if(adjustChatSize(p))
    	//	{
    	//	if(upcode==MouseState.LAST_IS_DOWN)
    	//		{ hidden.dragSizeAdj=0; 
    	//		  p.dragging=true; 
    	//		}
    	//	}
    	}
	   	if((G.isSimulator() || !G.isTouchInterface()) && mouse.drag_is_pinch)
		{	
	   		globalZoomRect.draw(null,p);
	   		if(globalZoomRect.hitcode==GameId.HitZoomSlider)
	   		{ changeZoom(getGlobalZoom(),getRotation());	// unconditionally
	   		}
		}
	HitPoint sp = setHighlightPoint(p);
	switch(upcode)
	{
	case LAST_IS_DOWN:
		setHasGameFocus(true);
		break;
	case LAST_IS_IDLE: 
		repaint(20,"mouse motion"); 
		break;
	default: break;
	}
    return(sp);
}
/**
 * return a name string appropriate for player at index n
 * @param n
 * @return a String
 */
public String prettyName(int n)
{	String def = s.get(PlayerNumber,(n+1));
	commonPlayer pl = getPlayer(n);
	if(pl!=null) { def = pl.prettyName(def); }
	return(def); 
}

/**
 * draw standard player stuff as a start button, or just as a player name rectangle
 * 
 * @param gc	the gc
 * @param button if true, draw as a start button
 * @param hit the hit point
 * @param fg the foreground color
 * @param bg the background color
 */
public void drawPlayerStuff(Graphics gc,boolean button,	HitPoint hit,Color fg,Color bg)
{	for(int i=0;i<players.length;i++)
	{
	drawPlayerStuff(gc,getPlayerOrTemp(i),button,hit,fg,bg);
	}
}
/**
 * draw standard player stuff for a single player as a start button, or just as a player name rectangle
 * 
 * @param gc	the gc
 * @param pl the player
 * @param button if true, draw as a start button
 * @param hit the hit point
 * @param fg the foreground color
 * @param bg the background color
 */
public void drawPlayerStuff(Graphics gc,commonPlayer pl,boolean button,	HitPoint hit,Color fg,Color bg)
{	if(pl!=null) 
	{ hidden.drawPlayerStuff(gc,pl,hit,button?GameId.HitStartP[pl.boardIndex]:null,fg,bg); 
	}
}

/** display the standard game state message, or any override message,
 * in the "what to do" rectangle.
 * 
 * @param gc
 * @param defaultMsg
 * @param addPlayer
 * @param who
 * @param stateRect
 */
public void standardGameMessage(Graphics gc,String defaultMsg,boolean addPlayer,int who,Rectangle stateRect)
{	standardGameMessage(gc,0,Color.black,defaultMsg,addPlayer,who,stateRect);
}
public void standardGameMessage(Graphics gc,double rotation,String defaultMsg,boolean addPlayer,int who,Rectangle stateRect)
{	
	standardGameMessage(gc,rotation,Color.black,defaultMsg,addPlayer,who,stateRect);
}
public void standardGameMessage(Graphics gc,double rotation,Color cc,String defaultMsg,boolean addPlayer,int who,Rectangle stateRect)
{	String msg = null;
	int cx = G.centerX(stateRect);
	int cy = G.centerY(stateRect);
	G.setRotation(gc, rotation, cx,cy);
    if (!allowed_to_edit && !reviewMode())
    {
        if (inLimbo)
        {
            msg = s.get(LimboMessage);
        }

        if (leftBarMessage != null)
        {
            msg = leftBarMessage;
            cc = leftBarMessageColor;
        }
    }
    if(msg==null)
    {	msg = defaultMsg;
    	if(addPlayer) { msg = currentPlayerPrettyName(who) + msg;	}
    }
	G.setColor(gc,cc);
	G.setFont(gc,standardBoldFont());
    G.Text(gc, false, stateRect, cc, null, msg);
	G.setRotation(gc, -rotation, cx, cy);
}
/**
 * general a "gameover" message appropriate for games where someone wins
 * but there is no score per se.
 * @return a gameOver message
 */
public String simpleGameOverMessage()
{
	for(int i=0;i<players.length;i++) 
	{ 
	commonPlayer pl = players[i];
	if((pl!=null) && WinForPlayer(pl))
		{ String msg = s.get(WonOutcome,prettyName(i));
		return(msg); 
		}
	}
	return(s.get(DrawOutcome));
}

class ScoreItem implements CompareTo<ScoreItem>
{
	int prettyScore;
	int score;
	String name;
	ScoreItem(String n,int sc,int ps)
	{
		name=n;
		score =sc ;
		prettyScore = ps;
	}
	public int compareTo(ScoreItem o) {
		return(G.signum(o.score-score));
	}
	public int altCompareTo(ScoreItem o) {
		return(-compareTo(o));
	}
}
/**
 * generate a "gameover" message appropriate for games where every player
 * has a final score.
 * @return a gameOver message
 */
public String scoredGameOverMessage()
{
	// multi player game
	String msg = s.get(GameOverMessage);
	ScoreItem scores[] = new ScoreItem[players.length];
	
	for(int i=0;i<players.length; i++) 
	{ commonPlayer p = getPlayerOrTemp(i);
	  scores[i] = new ScoreItem(prettyName(i),ScoreForPlayer(p),PrettyScoreForPlayer(p));
	}
		
	G.sort(scores);	// show the scores high to low
		
	for(ScoreItem score : scores)
		{	msg += " "+score.name+":"+score.prettyScore;
		}
	return(msg);	
}
/**
 * construct a "game won by" message, with scores for multiplayer games
 * @return a String
 */
public String gameOverMessage()
{	if(players.length<=2)
	{ return(simpleGameOverMessage());
	}
	else
	{ return(scoredGameOverMessage());
	}
}

/**
 * display the standard "goal of the game" message, or if there is a 
 * robot running, display the robot's progress slider.
 * @param gc
 * @param highlight 
 * @param message
 * @param progressRect
 * @param goalRect
 */
public void goalAndProgressMessage(Graphics gc,HitPoint highlight,String message,Rectangle progressRect, Rectangle goalRect)
{
	goalAndProgressMessage(gc,highlight,Color.black,message,progressRect, goalRect);
	
}
/**
 * display the standard "goal of the game" message, or if there is a 
 * robot running, display the robot's progress slider.
 * @param gc
 * @param highlight 
 * @param color
 * @param message
 * @param progressRect
 * @param goalRect
 */
public void goalAndProgressMessage(Graphics gc,HitPoint highlight,Color color,String message,
		Rectangle progressRect, Rectangle goalRect)

{	boolean someProgress = false;
	String ruledefault = G.debug() ? "rules" : null;
	String rules = sharedInfo.getString(exHashtable.RULES,ruledefault);
	G.setFont(gc,largePlainFont());
	//
	// this version displays the progress from any single robot that is running.
	// normally, the "current player" is also the running robot, but in simultaneous
	// play games (ie Raj), any player's robot can be running.
	//
	for(commonPlayer p : players)
	{
		if((p!=null) && p.drawProgressBar(gc,progressRect)) 
			{ someProgress = true; 
			  break; 	// if there are more running robots they're not displayed.
			}
	}
    if (!someProgress)
    {
        if(goalRect!=null)
        	{
        	int h = G.Height(goalRect);
        	G.Text(gc, true, G.Left(goalRect), G.Top(goalRect), 
        			G.Width(goalRect)-(rules!=null?h:0),
        			h, color, null,
        			message);
           	HitPoint.setHelpText(highlight,goalRect,s.get(GoalExplanation,message));
         	if(rules!=null)
        		{
        		int cx = G.Right(goalRect)-h/2;
        		int cy = G.centerY(goalRect);
        		if(StockArt.Rules.drawChip(gc,this,highlight,
        				GameId.HitRulesButton,h,cx,cy,null))
        			{
        			highlight.setHelpText(s.get(ShowRulesMessage));
        			highlight.hit_x = cx;
        			highlight.hit_y = cy;
        			highlight.awidth = h;
        			highlight.spriteColor = Color.red;
        			}
        		}
        	// this is a ui hack to provide visible control over the repaint delays
        	painter.positionSliders(gc,highlight,goalRect);
        	}
        
        	

    }
}
/**
 * return a String representing the current player name
 * @param who
 * @return a String
 */
public String currentPlayerPrettyName(int who)
{	// careful, who can be -1
	return(prettyName(who>=0?who:0)+" : ");
}

/**
 * translate the mouse coordinate x,y into a size-independent representation
 * presumably based on the cell grid.  This is used to transmit our mouse
 * position to the other players and spectators, so it will be displayed
 * at approximately the same visual spot on their screen.  
 *  */
public String encodeScreenZone(int x, int y,Point p)
{	
	if(G.pointInRect(x,y,boardRect))
	{ 	int screenXQuant = Math.max(2,G.Width(boardRect)/20);
		BoardProtocol b = getBoard();
		// this inited test is to combat an occasional nullpointerexception
		// when the mouse gets ahead of the game setup
		Point pp = (b!=null && b.inited()) 
						? (b.encodeCellPosition(x-G.Left(boardRect),y-G.Top(boardRect),screenXQuant))
						: null;
		if(pp!=null)
			{
			G.SetLeft(p,G.Left(pp));
			G.SetTop(p,G.Top(pp));
			return("boardEnc");
			}
	}
	
	// if in one of the named zones
	for(int z=0,lim=mouseZones.size(); z<lim; z++)
	{
		Rectangle zone = mouseZones.elementAt(z);
		if(G.pointInRect(x,y,zone))
		{	G.SetLeft(p,((x-G.Left(zone))*100)/G.Width(zone));
			G.SetTop(p,((y-G.Top(zone))*100)/G.Height(zone));
			String zn = getRectName(zone);
			//if(!myFrame.getSoundState()) 
			//	{ G.print("Encode "+zn+" "+p.x+" "+p.y); }
			return(zn);
		}
	}
	//if in the board zone
	Rectangle ref = fullRect;
	String name = "on";


	// full screen is encoded as arbitrary units from the upper left
	double quant = Math.max(2,G.Width(ref)/100.0);
	G.SetLeft(p,(int)((x-G.Left(ref))/quant));
	G.SetTop(p,(int)((y-G.Top(ref))/quant));
	return(name);
}
/**
 * decode a screen zone x,y
 * @param zone
 * @param x
 * @param y
 * @return a point representing the decoded position
 */
public Point decodeScreenZone(String zone,int x,int y)
{	//if(myFrame.getSoundState()) { G.print("Decode "+zone+" "+x+" "+y); }
	if("boardEnc".equals(zone))
		{ int screenXQuant = Math.max(2,G.Width(boardRect)/20);
		  BoardProtocol b = getBoard();
		// this inited test is to combat an occasional nullpointerexception
		// when the mouse gets ahead of the game setup
		  if(b!=null && b.inited())
		  {
		  Point mp = b.decodeCellPosition(x,y,screenXQuant);
		  G.Assert(!G.debug() || mp!=null,"%s %s,%s failed to decode",zone,x,y);
		  if(mp!=null)
		  {
		  G.SetLeft(mp,G.Left(mp) + G.Left(boardRect));
		  G.SetTop(mp, G.Top(mp) + G.Top(boardRect));
		  //G.print("Decode board as "+mp.x+" "+mp.y);
		  return(mp);
		  }}
		}
	{
	Rectangle zr = allRects.get(zone);
	if(zr!=null)
		{// named zones are encoded as a percentage of box size
		Point mp = new Point(G.Left(zr) + (int)(((x+0.5)/100)*G.Width(zr)), G.Top(zr) + (int)(((y+0.5)/100)*G.Height(zr)));
		//if(myFrame.getSoundState()) 
		//{G.print("Decode zone as "+mp.x+" "+mp.y+" from "+zr.y+" "+zr.height);
		//}
		return(mp);
		}
		 
	}
	// full screen is encoded as a arbitrary units from the upper left
	double quant = Math.max(2,G.Width(fullRect)/100.0);
	Point mp =new Point(G.Left(fullRect)+(int)((x+0.5)*quant),G.Top(fullRect)+(int)((y+0.5)*quant));
	//if(myFrame.getSoundState()) { G.print("Decode default as "+mp.x+" "+mp.y); }
	return(mp);
}

/**
 * absorb the first few tokens from a game history string.  These
 * will the produced by your {@link #gameType} method.
 * @param his
 */
public abstract void performHistoryInitialization(StringTokenizer his);

public void performPlayerInitialization(StringTokenizer his)
{	int fp = G.IntToken(his);
	BoardProtocol b = getBoard();
    if (fp < 0)   {  fp = 0;  }
    b.setWhoseTurn(fp);
    // in restoring poisoned games, the players may not be set up.
    // things are not going well, but don't get null pointer exceptions...
    if((players!=null) && players.length>fp)
    {
    commonPlayer p0 = players[fp];
    if(p0!=null)
    {
    p0.setOrder(0);
    if(players.length>1)
    	{
    	commonPlayer p1 = players[fp^1];
    	if(p1!=null) { p1.setOrder(1); }
    	}
    }
    }
	
}
public void performHistoryTokens(StringTokenizer his)
{	StringBuilder command = new StringBuilder();
    // now the rest
	boolean ended = false;
	boolean first = true;
	int time = -1;
    while (his.hasMoreTokens() && !ended)
    {
        String token = his.nextToken();
        ended = KEYWORD_END_HISTORY.equals(token);
        if (",".equals(token) || ended)
        {
            if (!first)
            {
                PerformAndTransmit(command.toString(), false,replayMode.Replay);
                if(time>=0) {
                	History.top().setElapsedTime(time);
                }
                command.setLength(0);
                first = true;
                time = -1;
            }
        }
       else if(first && (token.charAt(0)=='+'))
       {	// reserve all first tokens starting with + for future expansion
    	   if("+T".equals(token))
    	   {
    		   time = G.IntToken(his);   		   
    	   }
       }
       else
        {	first = false;
            command.append(" ");
            command.append(token);
        }
    }	
}
/**
 * reset the state of the game back to the previous "done" state, if that is allowed,
 * or back to the previous "pick" operation, if that is allowed.  This is done by truncating
 * the game record, and replaying back to the new end.  Normally this is triggered by
 * two missed clicks in a row, taken to indicate the user is confused about the state
 * of the game.
 * @see #allowPartialUndo()
 * @see #allowBackwardStep() 
 * 
 */
public void performReset()
{	if(!allowed_to_edit && reviewMode()) { scrollFarForward(); }
    else if(ourActiveMove() && (allowPartialUndo() || allowBackwardStep())) { PerformAndTransmit(RESET); }
	else  { leaveLockedReviewMode(); }
	if(theChat!=null) { theChat.closeKeyboard(); }
}

public void restorePlayerInfo2(String uid,int ord)
{	
	boolean found = false;
	int ordinal = ord%1000;
	for(commonPlayer pl : players) { if((pl!=null) && uid.equals(pl.uid) && (pl.getOrder()==ordinal)) { found=true; }}
	if(!found)
	{
	boolean change = false;
	for(commonPlayer pl : players)
	{	
		if(pl!=null)
		{
		if(!pl.restored && uid.equals(pl.uid) && (pl.getOrder()!=ordinal))
			{ pl.setOrder(ordinal); 
			  change = true; 
			  pl.restored = true;
			}
		}
	}
	if(change) {commonPlayer.reorderPlayers(players); }
	}
}

public void restorePlayerInfo(int seatposition,int ordinal)
{	boolean change = false;
	for(int i=0;i<players.length;i++)
	{	commonPlayer pl = players[i];
		if(pl!=null)
		{
		if(pl.getPosition()==seatposition) 
			{ if(pl.getOrder()!=ordinal)
				{ pl.setOrder(ordinal); change = true; 
				}
			}
		}
	}
	if(change) {commonPlayer.reorderPlayers(players); }
}

/**
 * return true if simultaneous game actions are allowed right now.  This is
 * used by the user interface to control prompts and actions the player is
 * looking at, which may be in review mode.
 *
 * @return true if simultaneous game actions are allowed right now
 */
public boolean simultaneous_turns_allowed()
{
	return(false);
}

/**
 * this should be overridden to return true when out-of-sequence moves will
 * actually occur.  The effect of "true" is that communications with
 * the server are held to a baseline and the players are allowed to overwrite each
 * other's view of the most recent move.
 */
public boolean fixed_move_baseline()
{
	return(false);
}
/* replay history as incoming commands.
Used by spectators, multiple reviewers, and players recovering their connection
*/
public void useStoryBuffer(String tok,StringTokenizer his)
{	if(tok==null) { tok = his.nextToken(); }
	if(his.hasMoreTokens())
	{	while(KEYWORD_PLAYER.equals(tok))
		{	int indx = G.IntToken(his);
			String name = G.decodeAlphaNumeric(his.nextToken());
			extendPlayers(indx);
			commonPlayer p = players[indx];
			if(p==null) { p = players[indx] = new commonPlayer(indx); }
			p.setPlayerName(name,false,this);
			tok = his.hasMoreTokens()? his.nextToken() : "";
		}
		while(KEYWORD_PINFO2.equals(tok))
		{
			String uid = his.nextToken();
			int ord = G.IntToken(his);
			restorePlayerInfo2(uid,ord);
			tok = his.hasMoreTokens()? his.nextToken() : "";
		}
		while(KEYWORD_PINFO.equals(tok))
		{	int seat = G.IntToken(his);
			int ord = G.IntToken(his);
			restorePlayerInfo(seat,ord);
			tok = his.hasMoreTokens()? his.nextToken() : "";
			if("true".equals(tok)||("false".equals(tok)))
			{	// eat the extra word for backward compatibility.
				// this can be eliminated about 11/1/2009
				tok = his.hasMoreTokens()? his.nextToken() : "";
			}
		}
		if (KEYWORD_COLORMAP.equals(tok))
		{
			String cm = his.nextToken();
			getBoard().setColorMap(G.parseColorMap(cm));
			tok = his.hasMoreTokens() ? his.nextToken() : "";
		}
		if (KEYWORD_START_STORY.equals(tok))
		{
			performHistoryInitialization(his);
			performPlayerInitialization(his);
			performHistoryTokens(his);
		}
	doScrollTo(FORWARD_TO_END);
	}
}
public void useEphemeraBuffer(StringTokenizer his)
{	for(int i=0; i<players.length && his.hasMoreElements(); i++)
	{	//commonPlayer pli = players[i];
		commonPlayer plp = commonPlayer.findPlayerByPosition(players,i);
		int tim = G.IntToken(his);
		if(plp!=null) 
		{ plp.setElapsedTime(tim); 
		//G.print("Restore "+plp+" "+tim+ ((pli==plp)?"":" not "+pli));
		}
	}	
	if(his.hasMoreElements())
	{
		String tok = his.nextToken();
		if(KEYWORD_SCROLL.equals(tok))
		{	// if a scroll position is specified, scroll there.
			int pos = G.IntToken(his);
			if(pos>=0) { doScrollTo(pos); }
		}
	}
	resetBounds();
}
/**
 * this is left poining to the duplicate board if an error is thrown from verifyGameRecord,
 *  so you can use the "show alternate board" to see that the bad duplicate looks like.
 */
public BoardProtocol dupBoard=null;	
public boolean DISABLE_VERIFY = false;
/**
 verify the game record is still correct by cloning the board
 and replaying it.  This is intended to catch "editing errors"
 by editHistory, but may also catch cases where Digest() is
 not producing the same result.  In the process this exercises
 a lot of the game machinery, so other latent bugs are likely
 to show up right away as errors thrown from verifyGameRecord
 <br>To assist with certain phases of debugging, where all this replaying
 can be confusing, set DISABLE_VERIFY=true;
 * 
 */
public void verifyGameRecord()
{	// this thrashes the garbage collector, and on IOS thrashing the GC
	// induces a lockup between sound and point handling.
	// https://github.com/codenameone/CodenameOne/issues/2860
	if(!G.isCodename1() && G.debug())
	{if(DISABLE_VERIFY) {  G.print("verifygamerecord is off"); }
	else {
	BoardProtocol ourB =  getBoard();
	long ourDig = ourB.Digest();
	BoardProtocol dup = dupBoard = ourB.cloneBoard();
	long dupDig = dup.Digest();
	// first get a duplicate of the board, it had better be good
	if(dupDig!=ourDig)
	{
	// hope that sameboard will produce a better error message
	ourB.sameboard(dup);
	G.Assert(dupDig!=ourDig,"Bad duplicate board - Digest Doesn't Match");
	}
	//
	// now reinitialize the copy and replay all the moves.
	//
	dup.doInit();
	int step = History.size();
	int limit = History.viewStep>=0 ? History.viewStep : step;
	for(int i=0;i<limit;i++) 
		{ commonMove mv = History.elementAt(i);
		  //G.print(".. "+mv);
		  dup.Execute(mv,replayMode.Replay);
		  // checkForRepetition maintains the gameover flag when it calls SetDrawState.
		  if(mv.gameover()) { dup.SetDrawState(); }
		}
	
	long dupRedig = dup.Digest();
	G.Assert(dup.whoseTurn()==ourB.whoseTurn(),"Whose turn mismatch, live %d vs replay %d",ourB.whoseTurn(),dup.whoseTurn());
	G.Assert(dup.moveNumber()==ourB.moveNumber(),"Move number mismatch, live %d vs replay %d",ourB.moveNumber(),dup.moveNumber());
	if(dupRedig!=ourDig)
	{
	// if the digest doesn't match, call sameboard in hope of getting a better error message
	ourB.sameboard(dup);
	// if sameboard passed, all we can say is the the digest doesn't match.  Tough to debug from here.
	//int d0 = ourB.Digest();
	//int d1 = dup.Digest();
	G.Assert(false,"Digest after replay doesn't match, but sameboard(dup) is ok");
	}
	// note: can't quite do this because the timing of "SetDrawState" is wrong.  ourB
	// may be a draw where dup is not if ourB is pending a draw.
	//G.Assert(dup.getState()==ourB.getState(),"Replay state matches");
	dupBoard = null;
	}}
	}

	public void enableSynchronization(boolean d)
	{	hidden.canSynchronize = d;
	}
	public boolean canSynchronize()
	{
		return(hidden.canSynchronize);
	}

	private commonMove changeMove = null;
    public boolean playerChanging()
    {
    	commonPlayer who = whoseTurn();
    	commonMove top = History.top();
    	boolean changed = (offline() || (who==my)) && ((who==null) || (who.boardIndex!=top.player));
    	if(changed && (top==changeMove)) { return(false); }
    	else if(changed) { changeMove = top; }
    	return(changed);
    }
    public void playTurnChangeSounds()
    {
        if (myFrame.doSound())
        {	playASoundClip(offline()||hasGameFocus()
				? turnChangeSoundName 
				: beepBeepSoundName,500);
        }
    }
    public boolean hasGameFocus=false;
    public boolean hasGameFocus() { return(hasGameFocus); }
    public void setHasGameFocus(boolean v) 
    	{ hasGameFocus = v; 
    	}
    
    private double boardZoomStartValue = 0.0;
    private double globalRotationStart = 0;
    private double globalTwistStart = 0;
    private double globalTwistLast = 0;
    public void paintSprites(Graphics g,HitPoint hp)
    { 	
    	super.paintSprites(g, hp);
    }

    public boolean enablefastPinch = true;
    public boolean globalPinchInProgress()
    {
    	return(super.globalPinchInProgress()
    			|| (enablefastPinch 
    			&& mouse.mouse_pinch
    					&& (globalZoomStartValue>0.0))
    			);
    }
    
    public void stopPinch()
    {	
    	boardZoomStartValue = 0.0;
    	globalZoomStartValue = 0.0;
    	generalRefresh();
    }
    public boolean panInProgress() { return((globalZoomStartValue>0.0) || draggingBoard);}
    private double startingZoom = 1.0;
    public void setGlobalZoomButton()
    {	startingZoom = getGlobalZoom();
    	changeZoomAndRecenter(getGlobalZoom()+0.5);
    }
    
    public void changeZoomAndRecenter(double z)
    {   
    	int w2 = getWidth()/2;
    	int h2 = getHeight()/2;
    	int sx = getSX();
    	int sy = getSY();
    	double cx = ((sx+w2)/startingZoom);
    	double cy = ((sy+h2)/startingZoom);
    	changeZoom(z,getRotation());
    	double finalZoom = getGlobalZoom();
    	int newcx = (int)(cx*finalZoom)-w2;
    	int newcy = (int)(cy*finalZoom)-h2;
    	setSX(newcx);
    	setSY(newcy);
     	startingZoom = z;
    	repaint();
    }

    public void setGlobalUnZoomButton()
    {
    	setGlobalZoom(1.0,0.0);
    }
/**
 * return true if it is possible to start a touch zoom "right now"
 */
    public boolean touchZoomEnabled() 
    { 	if(panInProgress()) { return(false); }	// if already panning, don't touch zoom
    	if(draggingBoard) { return(false); }
    	int x = mouse.getX();
		int y = mouse.getY();
		if(avoidChat(x,y)) { return(false); }
		return(true); 
    }
    private boolean draggingBoard = false;
    /**
     * note if a "drag board" operation is in progress.  This is used to 
     * lock out touch zoom for the duration of the pan
     * 
     * @param val
     */
    public void setDraggingBoard(boolean val)
    {	draggingBoard=val;
    }
    
    /**
     * determine that a "board drag" operation should be started.  This means
     * nothing has been hit by the mouse, which has actually moved, in the
     * game board rectangle, and not in the vcr zoom area, and touch zoom is
     * not in progress.
     * @param anySelect
     * @param tbRect
     * @return true if the drag should be started
     */
    public boolean startBoardDrag(HitPoint anySelect,Rectangle tbRect)
    {
	   	if((anySelect!=null)
	   		&&(anySelect.hitCode==DefaultId.HitNoWhere)	// nothing is hit 
	   		&& G.pointInRect(anySelect,tbRect)			// in the board rectangle
	   		&& !G.pointInRect(anySelect,vcrRect) 		// not in the vcr rectangle
	   		&& !touchZoomInProgress()					// not already doing a touch zoom
	   		&& (getDragPoint()==null))						// not already dragging
	   	{ //let him drag anywhere, just don't annoy with the hand icon.
 		anySelect.dragging = mouse.isDragging();		// mouse is actually moving
 		return(true);
	   	}
	   	return(false);
	}
    
    public void Pinch(int x,int y,double val,double twist)
    {	boolean startingPinch = val<0;
    	if(	(getGlobalZoom()<=MINIMUM_ZOOM)	// global zoom not in effect
    			&& zoomRect!=null
    			&& G.pointInRect(x,y,boardRect))
    	{
    	// in a board-only zoom.  Handled by the individual game, we just set the value
    	if(startingPinch) { boardZoomStartValue = zoomRect.value; val=1.0; }
   		zoomRect.setValue(boardZoomStartValue*val);
   		MouseMotion(x, y, MouseState.LAST_IS_DRAG);
    	repaint();
    	}
    	else 
    	{	// global pan/zoom
    		int scrollX = getSX();
    		int scrollY = getSY();
    		int realX = x-scrollX;
    		int realY = y-scrollY;
    		if(globalPinchEnable 
    			&& (boardZoomStartValue==0.0) 	// not in board-specific zoom
    			&& (globalZoomRect!=null) 
    			&& !touchZoomInProgress()
    			&& G.pointInRect(realX,realY,fullRect))
    		{	
    			//G.print("Twist "+startingPinch+" "+globalRotation+" "+twist);
        		if(startingPinch)	// start of a pinch 
        			{ 
        			  globalZoomStartValue = getGlobalZoom();
        			  globalPanStartX = realX;
        			  globalPanStartY = realY;
        			  globalRotationStart = globalRotation;
        			  globalTwistStart = twist;
        			  globalTwistLast = twist;
        			  // initial center for expansion
         			  globalPanLastX = realX;
        			  globalPanLastY = realY;
        			  val = 1.0;
        			}
        		scrollX += globalPanLastX-realX;	// add the local movement (assuming just drag)
        		scrollY += globalPanLastY-realY;
        		{
        		double dtwist = twist-globalTwistLast;
        		if(Math.abs(dtwist)>Math.PI/2)
        		{
        			// if we seems to have instantaneously twisted by more than 
        			// a quarter turn, it's more likely that the first/second finger flipped
        			// the direction by PI
        			globalTwistStart =+ dtwist>0 ? Math.PI : -Math.PI;
        		}}
        		globalTwistLast = twist;
        		globalPanLastX = realX;
        		globalPanLastY = realY;
        		
        		double prevZoom = getGlobalZoom();
        		double change = globalTwistStart-twist;
        		boolean nochange = setGlobalZoom(globalZoomStartValue*val,globalRotationStart + change);
        		if(nochange)
        		{
        			globalRotationStart = globalRotation;
        			globalTwistStart = twist;
        			globalTwistLast = twist;
        		}
         		double zoom = getGlobalZoom();
         		double newX = x * zoom/prevZoom;
         		double newY = y * zoom/prevZoom;
         		
         		scrollX += newX-x;	// compensate for shift due to changed zoom
         		scrollY += newY-y;
  
         		if(zoom>1.0)
         		{
         		// if zoomed back out, pan was reset to zero, so don't mess it up.
         		setSX(scrollX);
         		setSY(scrollY);
         		}
        		//G.print("rot "+globalRotation+" "+zoom);	
        		 
    	}
    	generalRefresh();	// force complete paint
    	}
    }
    /**
     * calculate a larger "square size" to maximize the size of a board within
     * a larger frame composed of cells.  The nominal layout is that in tall mode,
     * the whole width (less a reserve) is devoted to the board, in  wide mode, 
     * the whole height (less a reserve) is devoted to the board, in normal mode
     * all the other rows and columns are reserved.
     * 
     * @param width the width of the whole window
     * @param height the height of the whole window
     * @param chatHeight the height of the chat area, excluded in wide mode
     * @param wideFormat true if this is the calculation for a wide format window
     * @param tallFormat true of this is the calculation for a tall format window
     * @param CELLSIZE the cell size for all the non-board elements
     * @param ncols the number of columns in the whole window
     * @param boardcols the number of columns that will be converted to squares
     * @param reserveCols the number of reserved columns in tall mode
     * @param nrows the number rows in the whole window
     * @param boardrows the number of rows that will be converted to squares
     * @param reserveRows the number of reserved rows in wide mode
     * @return a double, presumably a somewhat larger than the cellsize
     */
    public double calcSquareSize(int width,int height,int chatHeight,
    		boolean wideFormat,boolean tallFormat,double CELLSIZE,
    		int ncols,int boardcols,double reserveCols,
    		int nrows,int boardrows,double reserveRows
    		)
    {
	    if(tallFormat)
	    {
	    // in tall format, enlarge the board to fill the width if possible
	    //
	    // width with the board filling all available space
	    double bcellW = (double)(width-reserveCols*CELLSIZE)/boardcols;
	    // height limited by the non-board columns which use the smaller cell size
	    double bcellH = (double)(height-chatHeight-(nrows-boardrows)*CELLSIZE)/boardrows;
	    return Math.min(bcellW, bcellH);
	    }
	    if(wideFormat)
	    {	// in wide format, enlarge the board to fill the height is possible
	    	//
	    	// width with wider board cells and the rest of the columns using the smaller cell
	        double bcellW = (double)(width-(ncols-boardcols)*CELLSIZE)/boardcols;
	        // height with the board filling all available space
	        double bcellH = (double)(height-CELLSIZE*reserveRows)/boardrows;
	        return Math.min(bcellW, bcellH);
	    }
	    else 
	    {	// in normal mode, both the extra rows and columns have to be respected
	        double bcellW = (double)(width-(ncols-boardcols)*CELLSIZE)/boardcols;
	        double bcellH = (double)(height-chatHeight-(nrows-boardrows)*CELLSIZE)/boardrows;
	        return Math.min(bcellW, bcellH);
	    }
    }
    private int layoutErrors = 0;
    public void checkLayouts()
    {
    	layoutErrors = 0;
    	int minw = getWidth()/2;
    	int minh = getHeight()/2;
    	int w = getWidth();
    	int h = getHeight();
    	Random r = new Random();
    	int neww=0;
    	int newh=0;
    	for(int i=0;(i<10000)&&(layoutErrors==0);i++)
    	{
    		neww = r.nextInt(w-minw)+minw;
    		newh = r.nextInt(h-minh)+minh;
    		double fac = G.adjustWindowFontSize(neww,newh);
      	  	adjustStandardFonts(fac*G.defaultFontSize);
      	  	setLocalBoundsSync(0,0,neww,newh);
    		if(layoutErrors==0) { layoutErrors += checkLayoutBounds(); }
    	}
    	if(layoutErrors==0) 
    		{ 
    		  double fac = G.adjustWindowFontSize(w,h);
      	  	  adjustStandardFonts(fac*G.defaultFontSize);

      	  	  setLocalBoundsSync(0,0,w,h); 
    		  G.print("ok"); 
    		}
    	else
    	{  
    	   G.print("New size "+neww+",",newh); 
    	}
    	generalRefresh();  	
    }
    /**
     * default implementation for games, which selects wide tall or normal layout
     */
    public void setLocalBounds(int x, int y, int width, int height)
    {
    	setLocalBoundsWT(x,y,width,height);
    }

    public double setLocalBoundsA(int x, int y, int width, int height,double aspects)
    {
    	throw G.Error("Override this method if you are using setLocalBoundsV");
    }
    /**
     * set local bounds, varying one parameter.  Normally, this is the "preferred aspect ratio"
     * 
     * the weakness of the layout manager is that it tries to optimize the size of the 
     * hole available for the board and "everything else", without knowing anything about
     * what the everything else is.  This sometimes does less well when the hole is 
     * the perfect size, then the "everything else" chips away at it.
     * 
     * running a few "wider" and "narrower" values helps these cases choose a better result.
     * in general, this algorithm is conservative in the sense that it will never choose a
     * worse result than we used to get anyway.
     * 
     * @param x
     * @param y
     * @param width
     * @param height
     * @param aspects a small array of doubles
     */
    public void setLocalBoundsV(int x, int y, int width, int height,double aspects[])
    {	
    	double best = 0;
    	double last = 0;
    	double bestsize = 0;
    	for(double as : aspects)
    	{	last = as;
    		contextRotation = 0;
    		// bs is a score, nominally the number of pixels in the board.
    		double bs = setLocalBoundsA(x,y,width,height,as);
    		if(bs>=bestsize)
    		{
    			best = as;
    			bestsize = bs;
    		}
    		if(G.debug()) { System.out.println("aspect "+as+" s "+bs+" "+selectedLayout); }
    	}

    	if(best!=last)
    	{	contextRotation = 0;
    		setLocalBoundsA(x,y,width,height,best);
    	}
		if(G.debug()) { System.out.println("Best "+best+" "+width+"x"+height); }
    }
    /**
     * this implements the standard "game" setLocalBounds which yields 
     * different layouts for "wide" and "tall" formats, whatever that 
     * means for a particular game.  
     * @param x
     * @param y
     * @param width
     * @param height
     */
    public void setLocalBoundsWT(int x,int y,int width,int height)
    {
    	int wide = setLocalBoundsSize(width,height,true,false);			// get the "wide" size metric
    	int tall = setLocalBoundsSize(width,height,false,true);			// get the "tall" size metric
    	int normal = setLocalBoundsSize(width,height,false,false);		// get the "normal" size metric
    	boolean useWide = wide>normal && wide>tall;
    	boolean useTall = tall>normal && tall>=wide;
    	if(useWide||useTall) { setLocalBoundsSize(width,height,useWide,useTall); }	// recall with the chosen metric
    	setLocalBoundsWT(x,y,width,height,useWide,useTall);			// do the actual layout
    }
    
    public int checkLayoutBounds()
    {	StringStack keys = new StringStack();
    	Hashtable<String,Rectangle> cop = new Hashtable<String,Rectangle>();
    	int errors = 0;
    	for(Enumeration<String> k = allRects.keys(); k.hasMoreElements();) 
		{	String key = k.nextElement();
			cop.put(key,(Rectangle)G.clone(allRects.get(key)));
			keys.push(key);
		}
    	setLocalBoundsSync(G.Left(fullRect),G.Top(fullRect),G.Width(fullRect),G.Height(fullRect));
    	for(int sz=keys.size(),i=0;i<sz;i++)
    		{	String key = keys.elementAt(i);
    			Rectangle r1 = allRects.get(key);
    			Rectangle r0 = cop.get(key);
    			if(!G.equals(r0,r1))
    			{	errors++;
    				G.print("\nunstable "+" "+key+"\n"+r0+"\n"+r1);
    			}
    		}
      	
    	for(int lim = keys.size()-1; lim>=0; lim--)
    	{	String key = keys.elementAt(lim);
    		if(key.charAt(0)!='.')
    		{
			Rectangle r1 = allRects.get(key);
			if( G.Height(r1)!=0 && G.Width(r1)>0 && !r1.intersects(fullRect) && !fullRect.contains(r1)) 
			{	errors++;
				G.print("out of bounds "+key+"\n"+r1+"\n"+fullRect);
			}
			else {
				
				for(int lim2 = lim-1; lim2>=0; lim2--)
				{ String key2 = keys.elementAt(lim2);
				  if(key2.charAt(0)!='.')
				  {
				  Rectangle r3 = allRects.get(key2);
				  if(r1.contains(r3)) {}
				    else if(r3.contains(r1)) {}
					else if(r1.intersects(r3)) 
						{ errors++;
						  G.print("\noverlap "+key+" "+key2+"\n"+r1+"\n"+r3); 
						}
				}}
				
			}}
		}
    	return(errors);
    }
    
    public void drawNoChat(Graphics gc,Rectangle r,HitPoint highlight)
    {	boolean cansee = seeChat();
    	CellId hitcode = cansee 
    						? GameId.HideChat 
    						: GameId.ShowChat;
    	StockArt img = cansee ? StockArt.Nochat : StockArt.Chat;
    	img.drawChip(gc, this, r, null);
    	String msg = !cansee
    					? s.get(ShowChatMessage)
    					: s.get(HideChatMessage);
    	int w = G.Width(r);
    	int h = G.Height(r);
    	// enlarge the target area
    	if(HitPoint.setHelpText(highlight,G.centerX(r),G.centerY(r),w*2,h*2,msg))
    	{
    		highlight.hitCode = hitcode;
    		highlight.spriteRect = r;
    		highlight.spriteColor = Color.red;
    	}
    	else if(!cansee && (theChat!=null) && theChat.hasUnseenContent())
    		{ 
    		long now = G.Date();
    		if(((now/1000)&1)==0) { G.frameRect(gc, Color.blue,r); }
    		repaint(1000);
    		}
    }
    /**
     * return a metric for the cell size for a particular layout. Nominally,
     * this corresponds to the square size of the board.  The intention is
     * that setLocalBoundsWT will select the layout option that yields the 
     * biggest board.
     * @param w
     * @param h
     * @param wide
     * @param tall
     * @return the "square size" for this size window, using the normal, wide, or tall template.
     */
    public int setLocalBoundsSize(int w,int h,boolean wide,boolean tall)
    	{ throw G.Error("you must override this method"); 
    	}
    /**
     * do setLocalBounds with wide, tall, or normal formatting
     * @param x
     * @param y
     * @param w
     * @param h
     * @param wide
     * @param tall
     */
    public void setLocalBoundsWT(int x,int y,int w,int h,boolean wide,boolean tall)
    	{ G.Error("you must override this method"); 
    	}
    /**
     * set a standard progress rect, inset in the goal rect
     * @param progress
     * @param goal
     */
    public void setProgressRect(Rectangle progress,Rectangle goal)
    {	int w = G.Width(goal);
    	int h = G.Height(goal);
    	G.SetRect(progress, G.Left(goal)+w/3,G.Top(goal)+h/4,w/3,h/3);
    }
    /** this is the place where the canvas is actually repainted.  We get here
     * from the event loop, not from the normal canvas repaint request.
     */
    public void drawCanvas(Graphics offGC, boolean complete,HitPoint hp)
    {	//G.addLog("draw canvas");

    	if(!complete)
    		{ Keyboard k = theChat.getKeyboard();
    		  // if the keyboard is up, draw it and the chat and nothing else
    		  if(k!=null) 
    		  	{ redrawChat(offGC,hp);
    		  	  drawKeyboard(offGC,hp);
    		  	 return; 
    		    }
    		}
   	
    	drawFixedElements(offGC,complete);
    	// draw the board contents and changing elements.
     	int hx = G.Left(hp);
     	int hy = G.Top(hp);
     	chatHasRun = false;
        redrawBoard(offGC,hp);
        if(!chatHasRun) { redrawChat(offGC,hp); }
        drawKeyboard(offGC,hp);


        G.SetLeft(hp, hx);
        G.SetTop(hp,hy);
        //      draw clocks, sprites, and other ephemera
        drawMice(offGC);
       
        DrawArrow(offGC,hp);
        
        drawUnmagnifier(offGC,hp);
        //G.addLog("finish canvas");
    }
    public double getPreferredRotation() { return(0); }
    public void drawUnmagnifier(Graphics offGC,HitPoint hp)
    {
        double z = getGlobalZoom(); 
        if(z>1.0)
        {
        	int w =getWidth();
        	int h = getHeight();
        	int size = Math.max(w, h)/20;
        	int sx = getSX();
        	int sy = getSY();
        	int cx = sx+w/2;
        	int cy = sy+h/2;
        	double rot = getPreferredRotation();       
    		G.setRotation(offGC, rot,cx,cy);
    		G.setRotation(hp, rot, cx, cy);
     		switch(G.rotationQuarterTurns(rot))
        	{
        	default:
        	case 0:
        		StockArt.UnMagnifier.drawChip(offGC,this,hp,GameId.HitMagnifier,size,getSX()+w-size,getSY()+h-size,null);
        		break;
        	case 1:
        		StockArt.UnMagnifier.drawChip(offGC,this,hp,GameId.HitMagnifier,size,cx+h/2-size,cy+w/2-size,null);
        		break;
        	case 2:
        		StockArt.UnMagnifier.drawChip(offGC,this,hp,GameId.HitMagnifier,size,cx+w/2-size,cy+h/2-size,null);
        		break;
        	case 3:
        		StockArt.UnMagnifier.drawChip(offGC,this,hp,GameId.HitMagnifier,size,cx+h/2-size,cy+w/2-size,null);       		
        		break;
        	}

        G.setRotation(offGC, -rot,cx,cy);
        G.setRotation(hp, -rot, cx, cy);
        }
    }
    
    /** these are drawn separately, directly on the canvas.  They
    might seem to flash on and off.
    */
    public void drawCanvasSprites(Graphics offGC, HitPoint hp)
    {	//G.startLog("draw sprites");
        DrawTileSprite(offGC,hp); //draw the floating tile, if present
        drawSprites(offGC);
        //G.addLog("finish sprites");
    }
    public void setTheChat(ChatInterface chat,boolean framed)
    {
    	super.setTheChat(chat,framed);
    	hidden.separateChat = framed;
    	
    }
	public void setSeeChat(boolean v) 
	{	
		if(hidden.hiddenChat==v)
		{   hidden.hiddenChat = !v;
			if(hidden.separateChat)
				{
				if(v && theChat!=null) { theChat.moveToFront(); }
				}
				else 
				{ 
				  if(hidden.noChatMenu!=null) { hidden.noChatMenu.setState(!v); }
				  resetBounds();
				}
		}
	}
	public boolean seeChat() { return(!hidden.hiddenChat); }
	
	// support for 1 hidden window per player
	   private HiddenGameWindow[] hiddenWindows = null;
	   public void drawHiddenWindow(Graphics gc, HitPoint hp, HiddenGameWindow hiddenGameWindow) 
	   {
		G.print("Draw hidden window "+hiddenGameWindow);
	   }
	   public void nameHiddenWindow(HiddenGameWindow win)
	   {
		   G.print("Name hidden window "+win);
	   }
	    // call from main window drawing
	public void drawHiddenWindows(Graphics useAgc)
	    {	// the GC is not used, but if it is not null, we get one and really draw
			// otherwise this is a scan for mouse effect only
	    	if(hiddenWindows!=null)
	    	{	// we only need to do this when we're really drawing
	    		// the mouse movement phase is done as a callback from
	    		// the remote window.
	    		for(HiddenGameWindow window : hiddenWindows)
	    		{	if(window!=null)
	    		{	nameHiddenWindow(window);
	    			if(window.hasConnection())
	    			{
	    			Graphics gc =  useAgc!=null ? window.getGraphics() : null;
	    			window.redraw(gc);	
	    				}}
	    		}
	    	}
	    }
	    // factory method to override
	   	public HiddenGameWindow makeHiddenWindow(String name,int index,int width,int height)
	   	{
	   		return new HiddenGameWindow(name,index,this,width,height);
	   	}
	    // call from game setup
	    public void createHiddenWindows(int np,int width,int height)
	    {      
	    	disposeHiddenWindows();
	    	HiddenGameWindow w[] = new HiddenGameWindow[np];
	    	for(int i=0;i<np;i++)
	    	{	// position the virtual windows left of the real window
	    		HiddenGameWindow pi = makeHiddenWindow("hidden window "+i,i,width,height);
	    		w[i] = pi;
	    		VNCService.registerService(pi);
	    	}
	    	hiddenWindows = w;
	    }
	    // find the board that corresponds to hp, or null if its the main board
	    public HiddenGameWindow findHiddenWindow(HitPoint hp)
	    {	if(hp!=null)
	    	{
	    	MouseClient cl = hp.parentWindow;
	    	if(cl!=null && cl instanceof HiddenGameWindow)  { return((HiddenGameWindow)cl); }
	    	}
	    	return(null);
	    }
	    
	    // cleanup, call from stopRobots
	    public void disposeHiddenWindows()
	    {	HiddenGameWindow[] hidden = hiddenWindows;
	    	hiddenWindows = null;
	    	if(hidden!=null)
	    	{
	    		for(HiddenGameWindow w : hidden)
	    		{	if(w!=null)
	    		{	
	    			VNCService.unregisterService(w);
	    			w.stopVNC("game closing");
	    		}
	    	}
	    }
	    }
	    public void runHiddenWindows()
	    {	
	    	if(hiddenWindows!=null)
	    	{
	    		for(int i=0;i<hiddenWindows.length;i++)
	    		{	HiddenGameWindow w = hiddenWindows[i];
	    			if(w!=null) { w.performMouse(); }
	    		}
	    	}
	    }
	    public HiddenGameWindow getHiddenWindow(int n)
	    {
	    	if(hiddenWindows!=null && n>=0 && n<hiddenWindows.length)
	    	{
	    		return(hiddenWindows[n]);
	    	}
	    	return(null);
	    }
	    // hidden game window is active
	    public void touchPlayer(int index)
	    {	commonPlayer p = getPlayer(index);
	    	if(p!=null)
	    	{
	    		p.UpdateLastInputTime();
	    	}
	    }
	    public void notifyFinished(int index)
	    {	commonPlayer p = getPlayer(index);
	    	if(p!=null)
	    	{
	    		p.ClearLastInputTime();
	    	}
	    }
	    
	    /**
	     * get the rotation for help text, based on the current player's orientation
	     */
	    public double getHelpTextRotation()
	    {
	    	commonPlayer p = players[getBoard().whoseTurn()];
	    	double rotation = p!=null ? p.displayRotation : 0;
	    	return(rotation);
	    }
	    public int standardFontSize() 
	    { 	int v = G.getFontSize(standardPlainFont());
	    	return v; 
	    }
	    public String getErrorReport()
	    {	return(gameRecordString());
	    }
	    public Bot salvageRobot()
	    {
	    	return ((Bot)sharedInfo.get(exHashtable.WEAKROBOT));
	    }
	    public void placeStateRow(int l,int t,int w,int h,Rectangle icon,Rectangle... r)
	    {
	    	G.SetRect(icon, l, t, h, h);
	    	G.placeRow(l+h+h/2,t,w-h-h/2,h,r);
	    }
	    /*
	     * this returns PI or 0.  PI is appropriate if the player's
	     * rotation is PI, not otherwise
	     * 
	     */
	    public double messageRotation(commonPlayer pl)
	    {	double rot = pl.displayRotation;
	    	return((G.rotationQuarterTurns(rot)==2)?rot:0);
	    }

		public double currentPlayerRotation()
		{	commonPlayer wt = whoseTurn();
			return wt==null ? 0 : wt.displayRotation;
		}
}