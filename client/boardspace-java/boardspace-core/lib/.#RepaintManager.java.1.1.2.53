package lib;
/**
 * all the gritty details of constructing and displaying the main window image 
 * are here.   Generally speaking, the image is constructed from three pieces,
 * a "fixed elements" bitmap with unchanging contents (between major reformatting)
 * a "display image" with fixed elements overlaid by current contents
 * a "ephemeral" layer of things that are always drawn on the fly.
 * 
 * four different styles of constructing this are supported.
 * 
 * direct, where everything is drawn on the fly and there are no backing bitmaps. This is normally
 * used only when memory is low.
 * 
 * single buffer, where one buffer image is constructed from fixed+dynamic, 
 *  then the ephemeral elements are painted on top
 * double buffer, where front and back images generated by single buffer mode are flipped
 *  this is used on android devices where single buffering results in undesirable flickering.
 * deferred, where no actual drawing is done in response to paint requests, but the drawing is
 *  scheduled and performed in the user loop.  This is the standard display mode for traditional java.
 *   
 */

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.image.ImageObserver;
import javax.swing.JCheckBoxMenuItem;
import javax.swing.JMenu;
import bridge.MasterForm;
/* below here should be the same for codename1 and standard java */
import lib.DeferredEventManager;
import lib.G;
import lib.ProgressMonitor;
import online.common.LFrameProtocol;
import vnc.VNCTransmitter;
import vnc.VncInterface;

enum CanvasId implements CellId
{
	FrameTime, ReleaseTime;
	public String shortName() { return(name()); }
}

public class RepaintManager implements VncInterface
{	boolean USE_BUFFERED_IMAGE = true;
	enum RepaintStrategy {
		Direct(0,0,0),
		Deferred(0,0,0),
		SingleBufferNofixed(0,0,0),
		SingleBuffer(0,0,0),
		DoubleBufferNofixed(80,0,0),
		DoubleBuffer(80,0,0);
		int frameTime;
		int frameDelay;
		int releaseTime;
		RepaintStrategy(int fr,int fd,int rt)
		{ frameTime = fr;
		  frameDelay = fd;
		  releaseTime = rt;
		}
	}
	public Color fill = Color.gray;
	public String message = "";
	public boolean showBitmaps = false;

	//
	// this is what the companion has to supply, in addition to being a standard window component
	//
	public interface RepaintHelper extends ImageObserver
	{
		public void actualPaint(Graphics g,HitPoint hp);
		public void actualRepaint();
		public void actualRepaint(int n);
		public boolean lowMemory();
		public void setLowMemory(String s);
		public void handleError(String s,String context,Throwable r);
		public void drawClientCanvas(Graphics g,boolean complete,HitPoint p);
		public void ShowStats(Graphics gc, int i, int j);
		public void showRectangles(Graphics gc, int i);
		public Font getDefaultFont();
		public void manageCanvasCache(int time);
		public void paintSprites(Graphics offGC, HitPoint pt);
		public boolean globalPinchInProgress();
		public void drawActivePinch(Graphics g,Image im,boolean useLast);
		public int getSX();
		public int getSY();
		public int getWidth();
		public int getHeight();
		public double getRotation();
		public double getGlobalZoom();
		
	}
	Component client;
	RepaintHelper helper;
	private boolean needManagement = false;
	public RepaintManager(RepaintHelper cl,Component c) 
	{ client = c;
	  helper = cl;
	}
	
	public RepaintManager(RepaintHelper cl,Component c,RepaintStrategy m)
	{	this(cl,c);
		repaintStrategy = m;
	}
	
	// 
	// painting the screen and related activity
	//
	public RepaintStrategy repaintStrategy = G.isCodename1() 
			? (G.isAndroid() ? RepaintStrategy.DoubleBuffer : RepaintStrategy.SingleBuffer)
					: RepaintStrategy.Deferred;
	public boolean deferSprites() { return(repaintStrategy!=RepaintStrategy.Deferred); }
	private Image allFixed = null; 		// for drawing unchanging elements of the board
	private Image panZoomBuffer = null;	//
	private XImage offScreen = null; 	// for drawing the main board offscreen
	private XImage offScreen2 = null;	// for optional double buffering 
	private Image duplicateImage = null;
    private boolean waked = false;		// we were waked, so don't sleep immediately
	private long nextWakeup = 0;		// scheduled time for next wakeup
	private long lastPaint = 0;			// when the last actual paint to the real screen occurred
	
	public int paintSteps = 0;			// number of repaints
	public int sleepTime = 0;			// time spent sleeping
	public long benchTime = 0;
	public long paintTime = 0;			// time spent painting
		
	public void clearStats()
	{
		sleepTime =  0;
		benchTime = 0;
 	   	paintSteps = 0; 
	}
	public String statString()
	{	long now = G.Date();
        int pt = (int)(paintTime / Math.max(1,paintSteps));
        int pctsleep = (int)(sleepTime*100/Math.max(now-benchTime,1));
		return(" P:"+ paintSteps + " "+pt+ " S:"+pctsleep+"% ");
	}
	boolean shutdown = false;
	// call this to release bitmaps and prevent getting them back
	public void shutdown()
	{ shutdown = true;
	  stopVNC("window shutdown");
	  ProgressMonitor.stopProgress();
	  setAllFixed(null);
	  setOffScreen(null);
	  
	}	 
	    // some help mapping the java refresh actions into our canvas.  It's desirable 
	    // to do all the drawing synchronously, in the main game thread, so there's 
	    // no question of synchronization among the game thread, the refresh thread
	    // and the mouse input thread.
	private boolean completeRefresh = true; //we need to repaint everything
	private synchronized boolean setComplete(boolean val)
	{
		boolean old = completeRefresh;
		completeRefresh = val;
		return(old);
	}
	enum RefreshReason  { GeneralRefresh , Paint, PlainRefresh,DeferredComplete,Swap,FellIntoDirect,ReadyToSee};
	
    private RefreshReason someRefresh = null;
    HitPoint highlightPoint = null;
    public void setHighlightPoint(HitPoint p)
    { highlightPoint = p; 
    }
    
    public Slider frameTimeSlider = null;
    public Slider releaseTimeSlider = null;
	    
    
public boolean performStandardButtons(CellId id)
{	 if(id==CanvasId.FrameTime) 
    		{
			if(frameTimeSlider!=null) { repaintStrategy.frameTime = (int)(frameTimeSlider.value*100); }
			return(true);
		}
	else if(id==CanvasId.ReleaseTime) 
		{ if(releaseTimeSlider!=null) { repaintStrategy.releaseTime = (int)(releaseTimeSlider.value*100); }
		return(true);
		}
	return(false);
}

    public void generalRefresh()
    {
    	someRefresh = RefreshReason.GeneralRefresh;
    	setComplete(true);
    	wakeMe();		// wake, but don't trigger a repaint
    }
    int imageErrors=0;

    //
    // this is a debugging utility to inset a postage stamps of the backing bitmaps
    // that are used to construct the main image.
    //
    static int step = 0;
    public void showBitmaps(Graphics g)
    {
		int w = client.getWidth();
		int h = client.getHeight();
		int w1 = w/6;
		int h1 = h/6;
		int xx = -G.getTranslateX(g)+w1/2;
		int x = xx;
		int y = -G.getTranslateY(g)+h1*3; 
		G.setClip(g,x,y,w,h);
		G.fillRect(g,Color.black,x,y,w1*4,h1+h1/2);
		y+=h1/8;
		x+= w1/4;
		Image im = ((panZoomBuffer==null)?allFixed:panZoomBuffer);
		if(im!=null) { G.drawImage(g,im,x,y,w1,h1,client); }
		else { G.setColor(g,Color.blue); G.drawLine(g,x,y,x+w1/2,y+h1/2); }
		G.frameRect(g,Color.blue,x,y,w1,h1);
		x += w1+w1/8;
		if(offScreen2!=null) { G.drawImage(g,offScreen2.theImage,x,y,w1,h1,client); }
		else { G.setColor(g,Color.blue); G.drawLine(g,x,y,x+w1/2,y+h1/2); }
		G.frameRect(g,Color.blue,x,y,w1,h1);
		x += w1+w1/8;
		if(offScreen!=null) { G.drawImage(g,offScreen.theImage,x,y,w1,h1,client); }
		else { G.setColor(g,Color.blue); G.drawLine(g,x,y,x+w1/2,y+h1/2); }
		G.frameRect(g,Color.blue,x,y,w1,h1);
		if(message!=null)
		{	G.Text(g,false,xx+w1/8,y+h1,w1*5, h1/2,Color.white, null,""+step+":"+message+" rr "+repaintReadyCount+" rs "+repaintSpritesCount);
			message = "";
			repaintReadyCount = 0;
			repaintSpritesCount = 0;
		}
	}
	private boolean checkReadyToSee(XImage im)
	{	if(im.readyToSee()) { return(true); }
		if(im.written)
		{
		long now = G.Date();
    	long delay = (im.endWriteTime+repaintStrategy.releaseTime)-now;
    	if(delay<=0) { im.setReadyToSee(); return(true); }
		}
    	return(false);
    }
    public void paint(Graphics g)
    { 	if(shutdown) { return; }
     	if(G.canRepaintLocally(client)
				|| G.canRepaintLocally(g))
    	{
    	G.setFont(g,helper.getDefaultFont());	// start with a consistent font

    	switch(repaintStrategy)
    	{
    	case Deferred:
    		someRefresh = RefreshReason.DeferredComplete;
    		setComplete(true);		// say we need it
            wake();						// and wake us up
            break;
            
   		  	
    	case DoubleBuffer:
    	case SingleBuffer:
    	case SingleBufferNofixed:
    	case DoubleBufferNofixed:
    	{
    	XImage im = getOffScreen();
    	if(im!=null)
     		{
    		//if(showBitmaps) { G.print(""+step+": start "+repaintStrategy); }
    		@SuppressWarnings("unused")
			long lp = lastPaint;
    		boolean pinch = helper.globalPinchInProgress();
    		im.startReadTime = G.Date();
    		long prevPaint = lastPaint;
    		if(pinch || ((panZoomBuffer!=null) && !checkReadyToSee(im)))
    		{
    		// when a pinch or a pinch/drag is in progress, we paint
    		// using a saved bitmap and blank the margins that are being
    		// exposed.
    		if(panZoomBuffer==null) 
    			{ // we use the allFixed buffer, since it will have
    			  // to be rewritten anyway.  Draw the last normal 
    			  // screen bitmap into the panZoomBuffer, use it fro
    			  // the duration of the drag.
    			  panZoomBuffer = allFixed();
    			   if(panZoomBuffer==null) { panZoomBuffer = createBlankImage(client.getWidth(),client.getHeight(),fill);}
    			   else { setAllFixed(null); }
    			  if(panZoomBuffer!=null)
    			  {
    				  Graphics gr = panZoomBuffer.getGraphics();
    				  drawToRealScreen(gr,im);
    				  gr.setFont(helper.getDefaultFont());
    				  HitPoint hp = (highlightPoint == null) ?  new HitPoint(-1,-1) : highlightPoint;
    				  step++;
    		    	  helper.actualPaint(gr,hp);
    				  // make sure that when re resume normal painting
    				  // we don't see any residue from the previous pan/zoom
    				  if(offScreen!=null) { offScreen.clear();offScreen.invalid = true;  }
    				  if(offScreen2!=null) { offScreen2.clear(); offScreen2.invalid = true;  }
    			  }
    			}
    		double r = helper.getRotation();
    		int w = helper.getWidth()/2;
    		int h = helper.getHeight()/2;	
    		G.setRotation(g, r,w,h);
    		helper.drawActivePinch(g,panZoomBuffer,!pinch);
    		G.setRotation(g, -r, w, h);
    		lastPaint = G.Date();
			if(!pinch) 
				{ 
				  repaint();	// get things going 
				}
			if(showBitmaps)
				{
	    		message += "pan/zoom cl "+helper.getSX()+","+helper.getSY()+" "+helper.getGlobalZoom()+" "+(lastPaint-prevPaint);
	    		showBitmaps(g);
				}
			helper.ShowStats(g,0,h*2-25);
    		}
    		else
    		{
    		panZoomBuffer = null;
    		//G.addLog("drawing for real");

    		drawToRealScreen(g,im);
    		lastPaint = im.endReadTime = G.Date();
    		HitPoint hp = (highlightPoint == null) ?  new HitPoint(-1,-1) : highlightPoint;

    		swapBuffersIfReady(im);	// mark this buffer seen, swap the next if ready
    		step++;
    		helper.actualPaint(g,hp);		// this does the rest of painting, ie; painting components
    		if(showBitmaps)
	    		{
    			long now = G.Date();
	    		message += someRefresh+" "+(lastPaint-prevPaint)+" next: "+(nextWakeup-now);
	    		showBitmaps(g);
	    		}
    		}

       		return;
    		}
    	}
     		if(showBitmaps) 
     		{ G.print(""+step+": fall into direct "+someRefresh+" "+G.isCompletelyVisible(client));
      		}
     	   	someRefresh = RefreshReason.FellIntoDirect;
    		/* fall into the direct draw case if there's no backing store */
       	case Direct:
    		//G.fillRect(g,fill,0,0,client.getWidth(),client.getHeight());
       		repaintCanvas(g);
  	   		HitPoint hp = (highlightPoint == null) ?  new HitPoint(-1,-1) : highlightPoint;
  	   		step++;
    		helper.actualPaint(g,hp);		// this does the rest of painting, ie; painting components
  		  	lastPaint = G.Date();
  		  	break;
    	}
 
 
     }}


    /** create a blank image with the specified size.
	    * 
	    * @param w
	    * @param h
	    * @return an Image
	    */
	    public Image createBlankImage(int w,int h,Color fillColor)
	    {	
	        try {
	        	Image im = //Toolkit.getDefaultToolkit().createImage();
	        		USE_BUFFERED_IMAGE ? G.createTransparentImage(w,h) : G.createImage(client,w,h);
	        	if(im==null)
	        	{setRepaintStrategy(RepaintStrategy.Direct);
	        	 helper.setLowMemory("CreateImage "+w+"x"+h+" failed with null");
	        	}
	        	else if(fillColor!=null){
	        		Graphics gr = im.getGraphics();
	        		G.fillRect(gr,fillColor,0,0,w,h);
	        	}
	        	return(im); 
	        }
	    	catch (ThreadDeath err) { throw err;}
	        catch (Throwable err)
	        { imageErrors++;
	          setRepaintStrategy(RepaintStrategy.Direct);
	          helper.setLowMemory("CreateImage "+w+"x"+h+" failed with "+err);
	          if(imageErrors<3)
	          {
	        	  throw G.Error("createAllFixed #"+imageErrors+" "+w+"x"+h+" "+err) ;
	          }
	        }
	        return(null);
	    }

	    private void setAllFixed(Image newv)
	    {	
	        Image im = allFixed;
	        allFixed = newv;
	        if ((im != null) && (im != newv))
	        {
	            G.Dispose(im);
	        }
	    }
	    /**
	     * create (of necessary) and return an offscreen image
	     * with the specified size.  This image is intended to be
	     * used to draw background, rarely changing elements in the
	     * background.
	     * @param w
	     * @param h
	     * @return true if a new image was created
	     */
	    public boolean createAllFixed(int w, int h)
	    {	boolean newv=false;
	    	switch(repaintStrategy)
	    	{
	    	default:
	    		if(!helper.lowMemory())
	    		{
	    			if (needNewImage(allFixed,w,h))
	    	    	{	
	    	    		setAllFixed(null);	// release the old first
	    	    		setAllFixed(createBlankImage(w, h,fill));
	    	    		newv=true;
	    	    	}
	    			break;
	    		}
	    	case Direct:
	    	case DoubleBufferNofixed:
	    	case SingleBufferNofixed:
	    	{ // by convention, the "allfixed" array is only a performance enhancement
	    		// and we can do without it pretty well.
	    		if(allFixed!=null)
		    		{
	    		setAllFixed(null);
	    		newv=true;
	    		}
	    	}
	    	}
	    	return (newv);
	    }
	    
	    public Image allFixed() { return(allFixed); }

	    public XImage getOffScreen() 
	   	{ 
	    	switch(repaintStrategy)
	    	{
	    	case Direct:
	    		if(offScreen!=null) { setOffScreen(null); } 
	    		return(null); 
	    	default:
	        	if(offScreen!=null)
	        		{int w = client.getWidth();
	        	     int h = client.getHeight();
	        	     if(needNewImage(offScreen,w,h)) 
	        	     	{ setOffScreen(null); 
	        	     	}
	        		}
	        	  return(offScreen); 
	    	}
	    }
	    private XImage getOffScreen2() 
	    { 
	    	switch(repaintStrategy)
	    	{
	    	case Direct: setOffScreen(null);
	    		return(null);
	    	case DoubleBuffer: 
	    	case DoubleBufferNofixed:
	    		return(offScreen2);
	    	case Deferred:
	    	case SingleBuffer: 
	    	case SingleBufferNofixed:
	    	default:
	    		return(offScreen);
	    	}
	    }
	    
	    private void swapOffScreen()
	    { 	XImage off = offScreen;
	    	XImage backBuffer = offScreen2;
	    	if(off!=null && backBuffer!=null)
	    	{
	    	long now = G.Date();
	    	long delay = (backBuffer.endWriteTime+repaintStrategy.releaseTime)-now;
	    	if(delay<=0) 
	    	{
	    	 backBuffer.setReadyToSee();
	    	 if(!off.readyToSee() || off.seen())
	    	 {
	    		 swapOffScreenNow();
	    	 }

	    	}
	    	else
	    	{
	    		// let the buffer age before releasing it
	    		someRefresh = RefreshReason.Swap;
	    		repaint((int)-delay);
	    	}}
	    }
	    private void swapOffScreenNow()
	    {	XImage off = offScreen;
	    	 // inhibit the swap if there's an unseen frame ready
	        offScreen = offScreen2;
	        offScreen2=off;
	        if(off!=null) { off.clear(); }
	    }
	    private void swapBuffersIfReady(XImage im)
	    {	im.setSeen();
	    	if((repaintStrategy==RepaintStrategy.DoubleBuffer)
	    			|| (repaintStrategy==RepaintStrategy.DoubleBufferNofixed))
	    	{	XImage off = offScreen2;
	    		if(off!=null && off.readyToSee() && !off.seen())
	    		{	// make the current front ready to be reused
	    			swapOffScreen();
	    		}
	     	}
	    }
	    private Image recycle(Image r,Image n,int w,int h)
	    {	if((r==null) && (n!=null) && (G.Width(n,helper)==w) && (G.Height(n,helper)==h)) 
	    		{ //G.print("recycling "+n+" from "+this);
	    		  Graphics g = n.getGraphics();
	    		  G.fillRect(g,fill,0,0,w,h);
	    		  return(n); 
	    		}
	    	if(n!=null) { G.Dispose(n); }
	    	return(r);
	    }
	    
	    // get a recycled image with a given size, or null, and trash the other cached images.
	    public Image getRecycledImage(int w,int h)
	    {	Image rim = null;
	    	if((repaintStrategy==RepaintStrategy.DoubleBuffer)
	    			|| (repaintStrategy==RepaintStrategy.DoubleBufferNofixed))
	    		{	XImage im = getOffScreen2();
	    			offScreen2=null;
	    			if(im!=null) { rim = recycle(rim,im.theImage,w,h); }
	    		}
	     	{ Image im = allFixed();
	    	  allFixed = null;
	    	  rim = recycle(rim,im,w,h);
	    	}
	       	{ XImage im = getOffScreen();
	       	  offScreen = null;
	       	  if(im!=null) { rim = recycle(rim,im.theImage,w,h); }
	       	}
	       	return(rim);
	    }
	    
	    private void setOffScreen(XImage newv)
	    {
	        XImage im = offScreen;
	        offScreen = newv;
	        if ((im != null) && (im != newv))
	        {
	            G.Dispose(im.theImage);
	        }
	        if(newv==null && (offScreen2!=null))
	        {	// always flush both
	        	swapOffScreenNow();
	        	setOffScreen(null); 
	        }
	    }
	    private final boolean needNewImage(XImage im,int w,int h)
	    {	return((im==null) || needNewImage(im.theImage,w,h));
	    }
	    private final boolean needNewImage(Image im,int w,int h)
	    {	return((im==null)
	    		 || (G.Width(im,helper)!=w)
	    		 || (G.Height(im,helper)!=h));
	    }
	    public void setRepaintStrategy(RepaintStrategy strat)
	    {
	    	repaintStrategy = strat;
	    	switch(strat)
	    	{
	    	case DoubleBufferNofixed:
	    	case SingleBufferNofixed:
	    	case Direct:
	    		setAllFixed(null);
	    		break;
	    	default:
	    	}
	    	switch(strat)
	    	{
	    	case Direct:
	    		setOffScreen(null); 
	    		/** fall through */
	    	case SingleBuffer:
	    	case SingleBufferNofixed:
	    	case Deferred:
				if(offScreen2!=null) { swapOffScreenNow(); setOffScreen(null); }
				break;
	    	default:
	    		break;
	    	}
	    	setBufferMenuChoice();
	    }
	    /**
	     * create (if necessary) and return an offscreen image with
	     * a specified size.  This image is intended to be used for
	     * routine offscreen drawing before displaying on the canvas.
	     * If double buffering is in effect, the back buffer is returned.
	     * 
	     * @param w
	     * @param h
	     * @return true if a new image was created
	     */
	    public XImage createOffScreen(int w, int h)
	    {	
	    	XImage im = getOffScreen2();
	    	if ( needNewImage(im,w,h))            
	    	{	
	    		setOffScreen(null);
	        	Image newim =G.getRecycledImage(w,h);
	        	if(newim==null) { newim = createBlankImage(w, h,fill); }
	        	if(newim!=null) { setOffScreen(im = new XImage(newim)); }
	        	if((repaintStrategy==RepaintStrategy.DoubleBuffer) 
	        			|| (repaintStrategy==RepaintStrategy.DoubleBufferNofixed)) 
	            {
	            	Image second = createBlankImage(w, h,fill);
	            	if(second!=null) 
	            	{
	            	swapOffScreenNow();
	            			setOffScreen(new XImage(second));
	            			im = getOffScreen2();
	            	}
	            	else { // emergency downgrade to single buffer
	            			setRepaintStrategy((repaintStrategy==RepaintStrategy.DoubleBuffer)
	            			? RepaintStrategy.SingleBuffer
	            			: RepaintStrategy.SingleBufferNofixed); 
	            		}
	            }
	        }
	       return (im);
	    }
	     public void repaintCanvas()
	     {	if(shutdown) { return; }
	     	//G.addLog("repaintCanvas");
	    	 Graphics g = (repaintStrategy==RepaintStrategy.Deferred) ? client.getGraphics() : null;

	    	 boolean rotated = MasterForm.rotateCanvas(client, g);
	       	 repaintCanvas(g);
	       	 if(rotated) { MasterForm.unrotateCanvas(client, g); }
	       	 
	         if(g==null) { repaintReady(); }	// get the real repaint out
	     }
	     private int repaintReadyCount = 0;
	     public void repaintReady() 
	     {	 repaintReadyCount++;
	    	 helper.actualRepaint();
	     }
	     private int repaintSpritesCount = 0;
	     public void repaintSprites()
	     {	 repaintSpritesCount++;
	    	 helper.actualRepaint();
	     }
	     public void repaintCanvas(Graphics g)
	     {	 switch(repaintStrategy)
	    	 {	default:
	    		 if(helper.globalPinchInProgress())
	    		 	{ return;		// inhibit real drawing until we stop pan/zoom 
		     		}
	    		 	break;
	    	 case Deferred:
	    	 }
	    	 boolean complete = setComplete(false);
	         if(complete) { paintSteps=0; } else { paintSteps++; }

	 //        setVisible(shouldBeVisible);
	 //        imageCache.clearCachedImages();

	         final HitPoint hp = (highlightPoint == null) ?  new HitPoint(-1,-1) : highlightPoint;
	         final Graphics hg = g;
	         final boolean hcomplete = complete;
	         //
	         // start the paint with no hitobject, this makes the 
	         // actual drawing pass behave the same as the mouse-only pass
	         //
	         // IOS only does rendering in EDT
	         if(G.isCodename1())// this forces all drawing into the edt thread
	         {
	        	 G.runInEdt(
	     				new Runnable () 
	     				{	public void run() 
	     					{ //G.addLog("real paint");
	     					  paintCanvas(hg,hcomplete,hp);
	     					}
	     				}); 
	         }
	         else {
	         paintCanvas(hg, hcomplete,hp);
	         }
	     }
	     
	     int errors = 0;
	     private XImage createOffScreen()
	     {
	    	 int width = client.getWidth();
	    	 int height = client.getHeight();
	    	 return createOffScreen(width,height);
	     }
	     /**
	      * this is the method that actually draws the window, which will
	      * can be superseded by the final window class.  This default method
	      * creates an off screen bitmap and calls {@link #repaintCanvas } with the 
	      * gc of the off screen bitmap, so if that is the desired behavior
	      * repaintCanvas can be overridden instead. 
	      * 
	      * @param gc a graphics object
	      * @param completePaint if true, do a complete refresh
	      * @param pt a {@link lib.HitPoint}, representing the state of the mouse.
	      * 
	      * @see HitPoint
	      */
	    public void paintCanvas(Graphics gc, boolean completePaint,HitPoint pt)
	 	{	try {
	 		XImage localOffScreen = createOffScreen();
	 		boolean complete = completePaint | (localOffScreen !=null && localOffScreen.mustBeComplete);
	 		if(localOffScreen!=null)
	 	    {  
	 			if((repaintStrategy==RepaintStrategy.DoubleBuffer)
	 					|| (repaintStrategy==RepaintStrategy.DoubleBufferNofixed))
	 	    	{

	    	    	if(!localOffScreen.written())
		    	    	{
	 	   	    	long now = G.Date();
	       	   	    	long delay = now-(localOffScreen.endReadTime+repaintStrategy.frameTime);
		    	    	if(delay<0)
		    	    		{ //G.print("Reschedule "+delay);
	   	    	    		  if(completePaint) { setComplete(true); }	// reinstate completeness
		    	    		  repaint((int)-delay);	// wait for the buffer to be cleaned
		    	    		  return; 
		    	    		}	// reschedule for later
		       	    	localOffScreen.startWriteTime = now;
			   	        

		       	    	repaintCanvas(localOffScreen,gc,complete,pt);
		       	    	localOffScreen.mustBeComplete = false;
		       	    	localOffScreen.setWritten(G.Date());
		    	    	}
		       		swapOffScreen();
		       		if(completePaint)
		       			{
		       			XImage off2 = createOffScreen();
			       			if(off2!=null)
			       			{	off2.mustBeComplete = true;
			       				off2.clear();
			       			}
		       			}
	 	    	}
	 	    	else 
	    	    	{	// single buffer
	    	    		repaintCanvas(localOffScreen,gc,complete,pt);
	    	    		localOffScreen.mustBeComplete = false;
	    	    		localOffScreen.setWritten(G.Date());
	        		}
	 	    }
	 	    else if(gc!=null)
	 	    	{
	 	    	helper.drawClientCanvas(gc,complete,pt);
	      		needManagement = true;
	      		G.setColor(gc,Color.blue);
	        	helper.showRectangles(gc,100);
	 	    	}
	 		}
	 		catch (ThreadDeath err) { throw err;}
	 		catch (Throwable err)
	 		{	if(errors++<10) {	helper.handleError("in paintCanvas",null,err); }
	 		}
	  	}
	    	
	 	private void repaintCanvas(XImage offScreen,Graphics gc,boolean complete0, HitPoint pt)
	 	{	someRefresh = null;
	 		boolean complete = setComplete(false)|complete0;
	  		Graphics offGC = offScreen.getGraphics();	// also marks it as unseen
	  		G.setFont(offGC,helper.getDefaultFont());
  			
	  		// font, line style, etc are not well defined at this point
	  		helper.drawClientCanvas(offGC,complete,pt);
      		needManagement = true;

	    	if(repaintStrategy==RepaintStrategy.Deferred)
	    	{	int x = helper.getSX();
	    		int y = helper.getSY();
	    		offGC.translate(-x,-y);
	    		helper.paintSprites(offGC,pt);
	    		offGC.translate(x,y);
	    	}
			    
		    
		    if(gc==null)
		    {
		    	G.setColor(offGC,Color.blue);
		    	helper.showRectangles(offGC,100);
		    }
		    else 
		    	{
		    	offScreen.startReadTime = G.Date();
		    	drawToRealScreen(gc,offScreen);
	    	    lastPaint = offScreen.endReadTime = G.Date();
		    	G.setColor(gc,Color.blue);
		    	helper.showRectangles(gc,100);
		    	}
	 	}
	 	public void drawToRealScreen(Graphics gc,XImage im)
	 	{	double rot = helper.getRotation();
	 		int w = client.getWidth()/2;
	 		int h = client.getHeight()/2;
    		G.setRotation(gc, rot,w,h);
	    	G.drawImage(gc,im.theImage,0,0,client);
	    	G.setRotation(gc, -rot, w,h);
	    	Image dup = duplicateImage;
	    	if(dup!=null)
	    	{
	    		Graphics g2 = dup.getGraphics();
	    		G.drawImage(g2, im.theImage, 0, 0, client);
	    		captureState = im.writtenState;
	    		duplicateImage = null;
	    		G.wake(dup);
	    	}
	    	helper.ShowStats(gc,0,h*2-25);	// add some stats on top of everything

	 	}
	     /** request a normal refresh of the window
	      * some background elements may not be repainted.
	      */
	     public void repaint()
	 	{ 	if(G.canRepaintLocally(client))
	 		{ 
	     		repaint(0);
	 		}
	 	}
	     public void repaint(int tm)
	     {	long now = G.Date();
	     	boolean sleeping = sleeping();
	     	long nextFrame = lastPaint+repaintStrategy.frameDelay-now;     	
	     	long wakeup = sleeping ?  nextWakeup-now : tm ;
	     	long paint = nextFrame>0 ? Math.max(tm,nextFrame) : tm;
	     	nextWakeup = now + Math.min(wakeup,paint);
	     	// wake if the request is for immediate, or if the new wakeup time is
	     	// less than already scheduled.
	     	boolean wake = (sleeping && (paint<wakeup)) || (tm==0);
	     	refresh();
	     	if(wake)
	     	{
	     	wakeMe();   	
	     	}
	     }
	     private boolean sleeping = false;
	     public synchronized void setSleeping(boolean val) { sleeping = val; }
	     public synchronized boolean sleeping() { return(sleeping); }
	     
	     private int deferCount = 0;
	     public boolean waitAWhile(long now,int howLong)
	     {	 G.addLog("w "+howLong+" "+waked);
	     	 boolean waited = false;
	    	 if (!waked)
	    	 {	long next = nextWakeup-now;
	    	 	long sleep = next>0?Math.min(next,howLong):howLong;
	    	 	if(sleep>0) 
	    	 	{ long beginsleep = now; 
	    	 	  deferCount = 0;
	    	 	  setSleeping(true);
	    	 	  G.waitAWhile(client,sleep);
	    	 	  setSleeping(false);
	    	 	  waited = true;
	    	 	  long sl = G.Date()-beginsleep;
	    	 	  if(sl<sleep) { G.addLog("Waked early" + client+" "+sl); }
	    	 	  sleepTime += sl; 
	    	 	  if(benchTime==0) { benchTime = beginsleep; }
	    	 	}
	    	 }
	    	 else 
	    	 	{ waked = false;
	    	 	  deferCount++;
	    	 	}
	    	 //G.addLog("waked");
	    	 return(waited);
	     }
	     /**
	      * this captures the standard java "update" request,
	      * but doesn't do any painting.
	      */
	     public void update(Graphics g)
	     { 	// this is an attempt to affect the "blank screen" problem.
	     	// the theory is that our non-painting is resulting in a damaged
	     	// drawing engine.
	     	//G.combinedClip(g,0,0,0,0);
	     	//super.update(g);
	     	//
	     	// also note; dealing with problems where the chat area is blank, you 
	     	// can frequently "fix" the problem by forcing theChar.update(g) here,
	     	// or by adding super.update(g) here.   Drawing a colored line here
	     	// also is useful to diagnose some problems.  See comments about JPanel
	     	// verses Panel in commonChatApplet and commonPanel.
	     	//
	     	switch(repaintStrategy)
	     	{
	     	case Deferred:
	     		refresh();
	         	wakeMe();
	         	break;
	     	default:
	     		paint(g);
	     	}
	     }

	    public void refresh()
	    {	someRefresh=RefreshReason.PlainRefresh;
	    }
	    public void wakeMe()
	    { 	refresh();
	    	G.addLog("wake");
	    	wake();
	    }
	    /** wake the run loop early.  This should not normally be necessary
	     * 
	     *
	     */
	    public void wake()
	    {
	        waked = true;
	        G.wake(client);
	    }
	    public boolean setWaked(boolean newval) 
	    { boolean oldval = waked;
	      waked = newval;
	      return(oldval);
	    }
	    public void repaintAndOrSleep(final int howLong)
	    {	
	    	final long now = G.Date();
	    	boolean waited = false;
		   	boolean wasWaked = setWaked(false);
		   	G.startLog("r "+howLong+" "+waked);
		   	if(howLong>0 && !wasWaked) 
		   		{
	    	    if(needManagement) 
	    	    	{ 
	    	    	needManagement=false;
	    	    	G.startInEdt(new Runnable() { public void run() { 	helper.manageCanvasCache(howLong); }});		    
	    	    	}
	    	    int howLongNow = Math.min((int)(nextWakeup-now),howLong);
		   		waited |= waitAWhile(now,howLongNow); 
		   		// if there's no "repaint" in the idle loop, make sure the
		   		// last frame painted is actually seen
		   		// the "deferred" clause fixes a problem with the tantrix lobby,
		    		// where refresh() messages trigger excess "paint(g)" in response
		    		if(  (repaintStrategy!=RepaintStrategy.Deferred)
		    			    && (now<nextWakeup))
		    		{	
		    			XImage im = getOffScreen();
		    			if((im!=null)
		    					&& checkReadyToSee(im)
		    					&& !im.seen)
		    			{
    			    	someRefresh = RefreshReason.ReadyToSee;
			    		repaintReady();
		    		}
		    	}
		   		}
	       if ((someRefresh!=null) 
	        		&& (wasWaked || (now>=nextWakeup))
	        		)
	        {	//System.out.println("Some "+someRefresh);
	        	boolean canSee = G.isCompletelyVisible(client) || G.isPartlyVisible(client);
	        	if(nextWakeup<=now) { nextWakeup = now+howLong; }
	    	    someRefresh=null;
	        	if(canSee)
	        	{	// if we can't see the window, don't actually repaint
	        		// we'll get another paint request when we can see it.
	        	repaintCanvas();
	            paintTime += (G.Date()-now);
	            paintSteps++;
	        }
	        }
	        else if(howLong>0)
	        {
	        if(needManagement) 
	    		{ 
	        	needManagement=false;
    	    	G.runInEdt(new Runnable() { public void run() { 	helper.manageCanvasCache((int)(nextWakeup-now)); }});		    
	    		}	        		
	        	if(!waited)
	        		{ 
	        		  waitAWhile(now,howLong);
	        		}	//sleep but don't reset the "next redraw" timer
	        	if(waked || wasWaked) 	// waked now
	        		{
	        		repaintAndOrSleep(0); 
	        		}
	        }
	    }
	
	    public JCheckBoxMenuItem noBufferChoice = null;
	    public JCheckBoxMenuItem singleBufferChoice = null;
	    public JCheckBoxMenuItem doubleBufferChoice = null;
	    public JCheckBoxMenuItem deferredChoice = null;
	    public JCheckBoxMenuItem doubleBufferNofixedChoice = null;
	    public JCheckBoxMenuItem singleBufferNofixedChoice = null;

	    public boolean handleDeferredEvent(Object target)
	    {
	        if(target==noBufferChoice)
	        	{ if(noBufferChoice.getState()) {setRepaintStrategy(RepaintStrategy.Direct);}
	        	  return(true); 
	        	}
	        else if(target==doubleBufferChoice)
	        	{ if(doubleBufferChoice.getState()) {setRepaintStrategy(RepaintStrategy.DoubleBuffer);}
	        	  return(true); 
	        	}
	        else if(target==singleBufferChoice)
	        	{ if(singleBufferChoice.getState()) { setRepaintStrategy(RepaintStrategy.SingleBuffer);}
	        	  return(true); 
	        	}
	        else if(target==doubleBufferNofixedChoice)
	        	{ if(doubleBufferNofixedChoice.getState()) {setRepaintStrategy(RepaintStrategy.DoubleBufferNofixed); }
	        	  return(true); 
	        	}
	        else if(target==singleBufferNofixedChoice)
	        	{ if(singleBufferNofixedChoice.getState()) { setRepaintStrategy(RepaintStrategy.SingleBufferNofixed);}
	        	  return(true); 
	        	}
	        else if(target==deferredChoice)
	        	{ if(deferredChoice.getState())  {setRepaintStrategy(RepaintStrategy.Deferred); }
	        	  return(true); 
	        	}
	        
	        if(frameTimeSlider!=null) { frameTimeSlider.setValue( repaintStrategy.frameTime*100); }
	        if(releaseTimeSlider!=null) { releaseTimeSlider.setValue( repaintStrategy.releaseTime*100);}
	        return(false);
	
	    }
	    private void setBufferMenuChoice()
	    {
	    	if(noBufferChoice!=null) 
	    		{ boolean newstate  = repaintStrategy==RepaintStrategy.Direct;
	    		  if(newstate!=noBufferChoice.getState())
	    			  {noBufferChoice.setState(newstate); }}
	    	if(singleBufferNofixedChoice!=null)
	    		{ boolean newstate = repaintStrategy==RepaintStrategy.SingleBufferNofixed;
	    		  if(newstate!=singleBufferNofixedChoice.getState())
	    			  {singleBufferNofixedChoice.setState(newstate); }}
	    	if(doubleBufferNofixedChoice!=null) 
	    		{ 	boolean newstate = repaintStrategy==RepaintStrategy.DoubleBufferNofixed;
	    			if(newstate!=doubleBufferNofixedChoice.getState())
	    				{ doubleBufferNofixedChoice.setState(newstate); }}
	    	if(singleBufferChoice!=null) 
	    		{ boolean newstate = repaintStrategy==RepaintStrategy.SingleBuffer;
	    		  if(newstate!=singleBufferChoice.getState())
	    			  { singleBufferChoice.setState(newstate);}}
	    	if(doubleBufferChoice!=null)
	    		{ boolean newstate = repaintStrategy==RepaintStrategy.DoubleBuffer;
	    		  if(newstate!=doubleBufferChoice.getState())
	    			  {doubleBufferChoice.setState(newstate); }}
	    	if(deferredChoice!=null) 
	    		{ boolean newstate = repaintStrategy==RepaintStrategy.Deferred;
	    		  if(newstate!=deferredChoice.getState())
	    			  { deferredChoice.setState(newstate);}}
	    }
	    public void addUIChoices(LFrameProtocol myFrame,DeferredEventManager deferredEvents)
	    {	if(myFrame!=null)
	    	{
	    	JMenu setBuffer = myFrame.addChoiceMenu("Set Buffering",null);
           	noBufferChoice = new JCheckBoxMenuItem("No Buffer");
           	noBufferChoice.addItemListener(deferredEvents);
           	
          	singleBufferNofixedChoice = new JCheckBoxMenuItem("Single Buffer, No fixed");
           	singleBufferNofixedChoice.addItemListener(deferredEvents);
          	
           	singleBufferChoice = new JCheckBoxMenuItem("Single Buffer");
           	singleBufferChoice.addItemListener(deferredEvents);

            doubleBufferNofixedChoice = new JCheckBoxMenuItem("Double Buffer, No fixed");
           	doubleBufferNofixedChoice.addItemListener(deferredEvents);

           	doubleBufferChoice = new JCheckBoxMenuItem("Double Buffer");
           	doubleBufferChoice.addItemListener(deferredEvents);
           	
           	deferredChoice = new JCheckBoxMenuItem("Deferred to Worker");
           	deferredChoice.addItemListener(deferredEvents);
           	 setBuffer.add(noBufferChoice);
           	 setBuffer.add(singleBufferNofixedChoice);
           	 setBuffer.add(singleBufferChoice);
           	 setBuffer.add(doubleBufferNofixedChoice);
           	 setBuffer.add(doubleBufferChoice);
           	 setBufferMenuChoice();
           	 if(!G.isCodename1()) { setBuffer.add(deferredChoice); }
           	 
             //frameTimeSlider = new Slider("frame=",CanvasId.FrameTime,0,1,repaintStrategy.frameTime/100.0);
             //releaseTimeSlider = new Slider("release=",CanvasId.ReleaseTime,0,1,repaintStrategy.releaseTime/100.0);
	    	}
	    }
	    public void positionSliders(Graphics gc,HitPoint highlight,Rectangle goalRect)
	    {
        	if(((repaintStrategy==RepaintStrategy.DoubleBuffer) )
        			|| (repaintStrategy==RepaintStrategy.DoubleBufferNofixed))
        	{
        		if(frameTimeSlider!=null)
        		{
           			G.SetRect(frameTimeSlider,
        			G.Left(goalRect),
        			G.Top(goalRect),
        			G.Height(goalRect)*6,
        			G.Height(goalRect));
           			G.fillRect(gc,Color.white,frameTimeSlider);
           			frameTimeSlider.draw(gc,highlight);
        		}
        		if(releaseTimeSlider!=null)
        		{
           			G.SetRect(releaseTimeSlider,
        			G.Right(frameTimeSlider),
        			G.Top(frameTimeSlider),
        			G.Width(frameTimeSlider),
        			G.Height(frameTimeSlider));
           			G.fillRect(gc,Color.white,releaseTimeSlider);
           			releaseTimeSlider.draw(gc,highlight);
        		}
        	}
	    }
	    
	    int captureState = 0;
	    VNCTransmitter transmitter;
	    public void setTransmitter(VNCTransmitter m) { transmitter = m; }
	    public VNCTransmitter getTransmitter() { return(transmitter); }
	    public boolean isVncActive() { return(transmitter!=null && transmitter.isActive()); };
	    String stopReason = null;
	    public void stopVNC(String reason)
	    {	stopReason = reason;
	    	G.wake(duplicateImage);
	    	duplicateImage = null;

	    	VNCTransmitter tm = transmitter;
	    	transmitter = null;
	    	if(tm!=null)
	    	{
	    		tm.stop(reason);
	    	}
	    }
	    public boolean needsRecapture()
	    {
	    	XImage im = getOffScreen();
	    	return(im==null ? true : im.writtenState!=captureState);
	    }
	    // capture a copy of the screen to an image.  This is
	    // synchronized with the actual drawing, so there's no
	    // flashy-flashy behavior
	    public void captureScreen(Image im,int timeout)
	    {
	    	duplicateImage = im;
	    	while(duplicateImage!=null)
	    	{	G.waitAWhile(im, timeout);
	    		client.repaint(); 
	    	}
	    }
	    //
	    // capture the current image, but not synchronized so some flashy
	    // behavior will appear
	    //
		public Image captureScreen() 
		{
			XImage im = createOffScreen();
			captureState = im.writtenState;
			return(im.getImage());
		}

		public Rectangle getScreenBound() {
			return(new Rectangle(0,0,client.getWidth(),client.getHeight()));
		}

}