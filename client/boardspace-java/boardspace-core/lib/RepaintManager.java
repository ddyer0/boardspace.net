/*
	Copyright 2006-2023 by Dave Dyer

    This file is part of the Boardspace project.
    
    Boardspace is free software: you can redistribute it and/or modify it under the terms of 
    the GNU General Public License as published by the Free Software Foundation, 
    either version 3 of the License, or (at your option) any later version.
    
    Boardspace is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
    without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
    See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along with Boardspace.
    If not, see https://www.gnu.org/licenses/. 
 */
package lib;
/**
 * all the gritty details of constructing and displaying the main window image 
 * are here.   Generally speaking, the image is constructed from three pieces,
 * a "fixed elements" bitmap with unchanging contents (between major reformatting)
 * a "display image" with fixed elements overlaid by current contents
 * a "ephemeral" layer of things that are always drawn on the fly.
 * 
 * four different styles of constructing this are supported.
 * 
 * direct, where everything is drawn on the fly and there are no backing bitmaps. This is normally
 * used only when memory is low.
 * 
 * single buffer, where one buffer image is constructed from fixed+dynamic, 
 *  then the ephemeral elements are painted on top
 * double buffer, where front and back images generated by single buffer mode are flipped
 *  this is used on android devices where single buffering results in undesirable flickering.
 * deferred, where no actual drawing is done in response to paint requests, but the drawing is
 *  scheduled and performed in the user loop.  This is the standard display mode for traditional java.
 *   
 *  9/30/2022 new stuff to deal with the windows having 4 valid rotations.
 *  the general approach is that the buffers reflect the rotated width,height of window,
 *  and they are always drawn without modification.  The layouts were made with the rotated
 *  coordinates.  When drawing a final bitmap to the real window, or when drawing directly
 *  without a buffer, rotate the coordinate system in the graphics.
 */

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.Rectangle;
import java.security.AccessControlException;

import javax.swing.JCheckBoxMenuItem;

import bridge.Config;
import bridge.JMenu;
import vnc.VNCTransmitter;
import vnc.VncScreenInterface;

enum RepaintId implements CellId
{
	FrameTime, ReleaseTime;
	public String shortName() { return(name()); }
}
enum RefreshReason  {
	GeneralRefresh ,	// repaint immediately and draw completely
	Paint,				// repaint after a delay
	VirginBuffer,		// newly created buffer with no content
	DeferredComplete,	// received "paint" in deferred buffer mode, need to draw now.
	Swap,				// back buffer ready, swap with front buffer
	ReadyToSee,			// single buffer is ready to view, trigger "paint" now.
	Timed,				// just a timer, no repaint needed
	Sprites,			// timer, need to draw sprites for animation but not main buffer
}

class PaintTimer
{	// if RECORD is on, we save a stack trace for every paint timer, and log 
	// the events that trigger a redraw to the console.  This is intended as
	// the ultimate debugging aid for "why am I repainting already!"
	static boolean RECORD = false;
	long expiration;	// expiration time
	int plus = 0;		// original "plus time"
	RefreshReason why;
	String stackTrace = null;
	String caller = null;
	public String toString() { return("<timer "+plus+" "+why+" "+caller+">"); }
	PaintTimer(long ex,int pt,RefreshReason w,String call) 
	{	expiration = ex;
		plus = pt;
		why = w;
		caller = call;
		if(RECORD && (why!=RefreshReason.Timed)) { stackTrace = G.getStackTrace(); }
	}
}
class PTStack extends OStack<PaintTimer>
{
	public PaintTimer[] newComponentArray(int sz) { return(new PaintTimer[sz]); }
	public long topz(int def)
	{
		PaintTimer top = top();
		if(top==null) { return(def); }
		return(top.expiration);
	}
	
	public String show()
	{
		long n = G.Date();
		StringBuilder b = new StringBuilder("\n");
		for(int lim = size()-1; lim>=0; lim--)
		{	PaintTimer t = elementAt(lim);
			b.append("time ");
			b.append(t.expiration-n);
			b.append(" ");
			b.append(t.why);
			b.append("\n");
		}
		return b.toString();
	}
}

public class RepaintManager implements VncScreenInterface,Config
{	boolean USE_VOLATILE_IMAGE = true;	// this uses native hardware, fixes the mac/catalina "terrible font" bug, 4/2020
	boolean USE_BUFFERED_IMAGE = true;
	boolean ZOOM_IS_SLOW = G.isCodename1();
	int MINIMUM_FRAME_TIME = 1000/60;		// frames per second
	boolean SHOW_TIMERS = true;
	boolean SIMULATE_LOW_MEMORY = false;
	public boolean deferSprites = true;
	public boolean hasRunLoop = true;			// client has its own run loop
	public boolean drawLockRequired = true;		// lock is required for direct drawing
	private int repaintReadyCount = 0;
	public boolean deferSprites() { return(deferSprites && (repaintStrategy!=RepaintStrategy.Deferred)); }
	public boolean useBackgroundBitmap = true; 
	public boolean trigger = true;
	public String showTimers() { return timers.show(); }
	public enum RepaintStrategy {
		Direct_SingleBuffer(0,G.isCodename1()?30:0,"Direct Single Buffer"),
		Direct_Unbuffered(0,5,"Direct Unbuffered"),		// used by android textwindow and ios
		Deferred(0,0,"Deferred Single Buffer"),
		Deferred_Unbuffered(0,0,"Deferred Unbuffered"),
		// single buffer strategy, if the viewing buffer is not ready to reuse, repaint anyway, schedule another repaint after it is ready
		// draw to the buffer, and wait (inline) until it is ready to be seen
		SingleBuffer(0,0,"Single Buffer"),
		// double buffer strategy, there is always a frame available for immediate viewing.
		// if the back buffer is ready to view, flip it and make the new back buffer available for drawing
		// if the back buffer has been drawn and not seen, defer this drawing operation under the buffer flips.
		DoubleBuffer(80,0,"Double Buffer")			//used by codename1 android
		;
		int delayBeforeWriting;		// time to delay after reading before rewriting
		int delayBeforeReading;		// time to delay after writing before reading
		String menuString = "";
		JCheckBoxMenuItem menu = null;
		
		RepaintStrategy(int fr,int rt,String menu)
		{ delayBeforeWriting = fr;
		  delayBeforeReading = rt;
		  menuString = menu;
		}
	     // true if this strategy normally uses a single or double buffer
	     private boolean useViewBuffer()
	     {
	    	 switch(this)
	    	 {
	    	 case Deferred_Unbuffered:
	    	 case Direct_Unbuffered: 
	    		 return false;
	    	 default: return true;
	    	 }
	     }
		public static void addUIMenu(JMenu parent,DeferredEventManager deferredEvents,RepaintStrategy current)
		{
			for(RepaintStrategy v : RepaintStrategy.values())
	    	{
			if(G.isCodename1() 
					&& (v==RepaintStrategy.Deferred || v==RepaintStrategy.Deferred_Unbuffered)) 
			{}
			else
			{
			v.menu = new JCheckBoxMenuItem(v.menuString);
           	v.menu.addActionListener(deferredEvents);
           	v.menu.setState(v==current);
           	parent.add(v.menu);
	    	}}
		}
		
		private static void setStrategyMenuChoice(RepaintStrategy current)
		{
			for(RepaintStrategy v : values()) 
			{	if(v.menu!=null)
				{	v.menu.setState(v==current);
				}
			}
		}
		
		private static RepaintStrategy isStrategyMenu(Object target,RepaintStrategy current)
		{	
			for(RepaintStrategy v : values()) 
			{
				if(v.menu==target) 
				{
					return v;
				}
			}
			return(null);
		}
		
	    static public boolean showFrameTimers = false;
	    static public JCheckBoxMenuItem frameTimersOn = null;
	    static public Slider frameTimeSlider = null;
	    static public Slider releaseTimeSlider = null;
	    static public boolean handleDeferredEvent(Object target)
	    {
	    	if(target==frameTimersOn)
	        {
	        	showFrameTimers = frameTimersOn.getState();
	        	return(true);
	        }
	    	return(false);
	    }
	    private void setSliders()
	    {
	        if(frameTimeSlider!=null) { frameTimeSlider.setValue( delayBeforeWriting);  }
	        if(releaseTimeSlider!=null) { releaseTimeSlider.setValue( delayBeforeReading); }
	    }
	    static private void positionSliders(Graphics gc,HitPoint highlight,Rectangle goalRect,RepaintStrategy repaintStrategy)
	    {	if(showFrameTimers)
        	{	int x = G.Left(goalRect);
        		int y = G.Top(goalRect);
        		int h = G.Height(goalRect);
        		int sz = h*10;
        		if(frameTimeSlider!=null)
        		{
           			G.SetRect(frameTimeSlider,	x,y,sz,h);
           			x += sz;
           			GC.fillRect(gc,Color.white,frameTimeSlider);
           			frameTimeSlider.draw(gc,highlight);
           			if(G.pointInRect(highlight, frameTimeSlider) && highlight.down)
           			{
           				repaintStrategy.delayBeforeWriting = (int)(frameTimeSlider.value);
           			}
        		}
        		if(releaseTimeSlider!=null)
        		{
           			G.SetRect(releaseTimeSlider,x,y,sz,h);
           			x += sz;
           			GC.fillRect(gc,Color.white,releaseTimeSlider);
           			releaseTimeSlider.draw(gc,highlight);
          			if(G.pointInRect(highlight, releaseTimeSlider) && highlight.down)
           			{	int val = (int)(releaseTimeSlider.value);
           				if(val!=repaintStrategy.delayBeforeReading)
           					{//G.print("change "+repaintStrategy+" "+val);
           					 repaintStrategy.delayBeforeReading = val;
           					}
           			}
        		}
        	}
	    }
	}
	boolean record = false;
	public void setRecord(boolean v) 
	{	if(v)
		{if(!record) 
			{ Log.startLog("recording"); 
			record = true;	
			}
		}
		else { Log.finishLog(); record = false; } 

	}
	public Color fill = Color.gray;
	public String message = "";
	static public boolean showBitmaps = false;
	//
	// if using direct drawing on regular java, the drawing thread
	// interacts badly with the game thread.  This scheme implements
	// a wait-until-safe synchronization.  While the game thread is
	// waiting, which ought to be almost all the time, the painter
	// is allowed to paint.  If the painter arrives at a bad time, 
	// it just repaints the last frame and schedules another paint.
	//
	long waitingToPaintStart = 0;
	SimpleLock directDrawingLock = new SimpleLock("Direct_SingleBuffer Draw");
	boolean getDirectDrawingLock()
	{	return(!drawLockRequired || directDrawingLock.Lock());
		
	}
	boolean releaseDirectDrawingLock()
	{
		return(!drawLockRequired || directDrawingLock.UnlockIfHeld());
	}
    public void showMenu(MenuInterface m,MenuParentInterface parent,int x,int y) throws AccessControlException
    {	// this is carefully constucted.  Normally when showing a menu, the 
    	// main game loop is in "run" state, but that means that it is holding the
    	// lock that prevents direct drawing.  This results in the "white frame"
    	// under the menu that appears.   We arrange for lobby and game windows
    	// to pass through here when showing a menu, so that won't be a problem.
    	//
    	// the menu, when up, locks out refresh for the windows below it, so the
    	// refresh caused by inserting the menu had better succeed, also to prevent
    	// the white frame.
    	//
    	releaseDirectDrawingLock();
    	parent.show(m,helper.unrotateCanvasX(x,y),helper.unrotateCanvasY(x,y)); 
    	getDirectDrawingLock();
    }

	//
	// this is what the companion has to supply, in addition to being a standard window component
	//
	public interface RepaintHelper extends ErrorReporter,SizeProvider
	{
		public void actualPaint(Graphics g,HitPoint hp);	// paint on the real window
		public void actualRepaint();						// request paint on the real screen
		public boolean lowMemory();							// memory ran out sometime
		public void setLowMemory(String s);					// memory ran out while getting buffers
		public void handleError(String s,String context,Throwable r);	// report an error
		public void drawClientCanvas(Graphics g,boolean complete,HitPoint p);	// actual drawing, usually to a buffer
		public void ShowStats(Graphics gc, HitPoint hp,int i, int j);
		public void showRectangles(Graphics gc, HitPoint pt,int i);
		public Font getDefaultFont();
		public void manageCanvasCache(int time);
		public boolean needsCacheManagement();
		public void paintSprites(Graphics offGC, HitPoint pt);
		public boolean globalPinchInProgress();
		public void drawActivePinch(Graphics g,Image im,boolean useLast);
		public int getSX();
		public int getSY();
		public double getRotation();
		public double getGlobalZoom();
		public Component getComponent();
		public void drawBackground(Graphics gc, Image image);
		public void resetLocalBoundsIfNeeded();
		public boolean rotateCanvas(Graphics g);
		public void unrotateCanvas(Graphics g);
		public int unrotateCanvasX(int x,int y);
		public int unrotateCanvasY(int x,int y);
		public int getRotatedWidth();
		public int getRotatedHeight();
		
	}
	Component client;
	RepaintHelper helper;
	public RepaintManager(RepaintHelper cl) 
	{ client = cl.getComponent();
	  helper = cl;
	  repaintStrategy.setSliders();
	}
	
	public RepaintManager(RepaintHelper cl,RepaintStrategy m)
	{	this(cl);
		repaintStrategy = m;
	}
	
	// 
	// painting the screen and related activity
	//
	public RepaintStrategy repaintStrategy = 
			G.isCodename1() 
				? (G.isIOS()
						? RepaintStrategy.Direct_Unbuffered 
						: RepaintStrategy.Direct_Unbuffered)// was DoubleBuffered
					: G.isJavadroid()
						? RepaintStrategy.Direct_SingleBuffer
						: RepaintStrategy.Deferred;//RepaintStrategy.Direct_SingleBuffer; //RepaintStrategy.Deferred;
	private XImage allFixed = null; 		// for drawing unchanging elements of the board
	private XImage viewBuffer = null; 	// for drawing the main board offscreen
	private XImage drawBuffer = null;	// for optional double buffering 
	private Image duplicateImage = null;
	private PTStack timers = new PTStack();
	private boolean paintedAFrame = false;

	private void addTimer(long now,int increment,RefreshReason why,String call)
	{	synchronized (this)
		{
		if(now==0) { now = G.Date(); }
		if(!hasRunLoop) { startRunLoop(); }
		long future = now + increment;
		PaintTimer newtime = new PaintTimer(future,increment,why,call);
		boolean some = false;

		for(int lim = timers.size()-1; lim>=0 ; lim--)
		{
			PaintTimer nextTimer = timers.elementAt(lim);
			long expiration = nextTimer.expiration;
			if(expiration<now)	{}					// ignore all expired timers
			if(some) {
				if(nextTimer.why==why)
					{ 
					  timers.remove(lim,true); 
					}		// remove a later timer of the same type
				}
			else if(nextTimer.expiration>=future)
				{ // expires after us, this is the insertion point
				  if(nextTimer.why==why)
				  	{  // replace with a shorter timer
					  
					  timers.setElementAt(newtime,lim);  
				  	}
				  else { 
				  		timers.insertElementAt(newtime,lim+1); 
				  	}
				  some = true; 
				}
			else if(nextTimer.why==why) 
				{ // expires before us
				  
				  some = true; 	// already exists with a shorter time				
				}
		}
		if(record)
		{ StringBuilder msg = new StringBuilder();
		  msg.append("Timers: ");
		  for(int lim=timers.size()-1; lim>=0; lim--) { msg.append(timers.elementAt(lim).toString()); }
		}
		if(!some)
		{
		timers.insertElementAt(newtime,0);
		}}
		if(sleeping()) 
		{ 
		  wakeMe(); 
		} 
	}
	private boolean paintNeeded = false;
	private PaintTimer triggerEvent = null;
	public synchronized boolean setPaintNeeded(boolean val) 
	{ 	boolean old = paintNeeded;
		paintNeeded = val; 
		if(val) 
			{ doActualRepaint(); 
			}
		return(old);
	}
	public void doActualRepaint()
	{
		 switch(repaintStrategy)
			{
		 	default: 
		 		repaintReadyCount++;
		 		//
		 		// jcomponent responds with paint(), whereas 
		 		// component responds with update()
		 		helper.actualRepaint();
		 		break;
		 	case Deferred:
		 	case Deferred_Unbuffered:
		 		// in deferred mode, both the drawing and displaying occurs in the
		 		// game process, so we do NOT want the paint action to be triggered
		 		// in other modes, the drawing occurs in the game
		 		// process and the displaying occurs in the paint(g) method.
		 		// 
		 		// this is doubly mysterious when comparing boardspace and tantrix.  
		 		// because tantrix windows inherit from "jcomponent" which respond to 
		 		// repaint with paint, whereas boardspace game windows inherit from "component"
		 		// which respond to repaint with "update", which filters out the events for deferred mode.
		 		break;
			}
	}
	//
	// get the next timer if it is in the future
	// handle any expired timers
	//
	private PaintTimer getNextTimer()
	{	long now = G.Date();
		PaintTimer next = null;
		synchronized (this)
	{	
		boolean exit = false;
		while( !exit && (null != (next = timers.top())))
			{
			boolean expired = next.expiration<=now;
			if(expired) 
				{ timers.pop(); 
				}
			switch(next.why)
				{
				case ReadyToSee: 
					if(expired)
					{
					if(expired) 
						{ doActualRepaint();	} // trigger paint in buffered modes
					next = null;	// fully handled
					}
					else { exit = true; }
					break;
				case Timed:			// just wake up
					exit = true;
					break;
				default:
					// all the rest assumed to require redrawing after a delay
					exit = true;
					if(expired && !setPaintNeeded(true))
					{ 	// if this is the triggering event, maybe record it
						triggerEvent = next;
						if(record)
						{
						Log.startLog("trigger paint");
						if(next.stackTrace!=null) { Log.addLog(""+next+":"+next.stackTrace); }
						}
					}
				}
			}

		}
		return(next); 	// wait for the future
	}
	
	public int paintSteps = 0;			// number of repaints
	public int sleepTime = 0;			// time spent sleeping
	public long benchTime = 0;
	public long paintTime = 0;			// time spent painting
	public long lastPaintTime = 0;		// most recent paint
	public void clearStats()
	{
		sleepTime =  0;
		benchTime = 0;
 	   	paintSteps = 0; 
 	   	paintTime = 0;
	}
	public String statString()
	{	long now = G.Date();
        int pt = (int)(paintTime / Math.max(1,paintSteps));
        int pctsleep = (int)(sleepTime*100/Math.max(now-benchTime,1));
        String te = triggerEvent==null ? "" : ""+triggerEvent;
		return(" P:"+ paintSteps + " "+(lastPaintTime)+"/"+pt+"u S:"+pctsleep+"% "+te);
	}
	boolean shutdown = false;
	// call this to release bitmaps and prevent getting them back
	public void shutdown()
	{ shutdown = true;
	  stopService("window shutdown");
	  //ProgressMonitor.stopProgress();
	  setAllFixed(null);
	  setViewBuffer(null);
	  
	}	 
	    // some help mapping the java refresh actions into our canvas.  It's desirable 
	    // to do all the drawing synchronously, in the main game thread, so there's 
	    // no question of synchronization among the game thread, the refresh thread
	    // and the mouse input thread.
	private boolean completeRefresh = true; //we need to repaint everything
	private synchronized boolean setComplete(boolean val)
	{
		boolean old = completeRefresh;
		completeRefresh = val;
		return(old);
	}
	
	// this logically should be in setComplete, but there's a deadly
	// embrace involving volatile images there.  So this defers the
	// marking of buffers to another time.
	private void setBuffersComplete()
	{
		switch(repaintStrategy)
		{
		case DoubleBuffer:
		{
			XImage im = getViewBuffer();
			if(im!=null) { im.mustBeComplete = true; }
		}
		default:
			break;
		}
	}
    HitPoint highlightPoint = null;
    public void setHighlightPoint(HitPoint p)
    { 
      highlightPoint = p; 
    }
    
	    
    public void generalRefresh(String w)
    {
    	setComplete(true);
    	addTimer(0,1,RefreshReason.GeneralRefresh,w);
    }
    int imageErrors=0;

    //
    // this is a debugging utility to inset a postage stamps of the backing bitmaps
    // that are used to construct the main image.
    //
    // TODO: show bitmaps doesnt work if rotation is 180
    static int step = 0;
    public void showBitmaps(Graphics g,String msg)
    {
		int w = client.getWidth();
		int h = client.getHeight();
		int w1 = w/6;
		int h1 = h/6;
		int w2 = h1*helper.getRotatedWidth()/helper.getRotatedHeight();
		int tx = -GC.getTranslateX(g);
		int ty = -GC.getTranslateY(g);
		int xx = tx+w1/2;
		// draw in the same visual location, regardless of pan/zoom
		int x = xx;
		int y = ty+h1*3; 
		int hs = h1+h1/2;
		int ws = w1*4;
		GC.fillRect(g,Color.black,x,y,ws,hs);
		GC.Text(g, true, x,y+hs-hs/10,ws,hs/10,Color.white,null,repaintStrategy.name());
		y+=h1/8;
		x+= w1/4;
		XImage im = allFixed;
		if(im!=null) 
		{ 
		  im.getImage().drawImage(g,x,y,w2,h1); 
		  GC.Text(g,false,x,y+h1,w1,20,Color.white,Color.black,""+allFixed+((msg==null)?"":" "+msg));
		}
		else { GC.setColor(g,Color.blue); GC.drawLine(g,x,y,x+w2/2,y+h1/2); }
		GC.frameRect(g,Color.blue,x,y,w2,h1);
		
		
		x += w1+w1/8;
		if(drawBuffer!=null)
			{ 
			  Image im0 = drawBuffer.theImage;
			  Graphics gr = im0.getGraphics();
			  GC.fillRect(gr, Color.red, 10,10,20,20);
			  drawBuffer.theImage.drawImage(g,x,y,w2,h1);
			  GC.Text(g,false,x,y+h1,w1,20,Color.white,Color.black,""+drawBuffer);
			}
		else { GC.setColor(g,Color.blue); GC.drawLine(g,x,y,x+w2/2,y+h1/2); }
		GC.frameRect(g,Color.blue,x,y,w2,h1);
		
		x += w1+w1/8;
		if(pinchBuffer!=null)
		{
			  Image im0 = pinchBuffer.theImage;
			  Graphics gr = im0.getGraphics();
			  GC.setColor(gr,Color.blue);
			  GC.fillRect(gr, 10,10,20,20);
			  pinchBuffer.theImage.drawImage(g,x,y,w2,h1);
			  GC.Text(g,false,x,y+h1,w1,20,Color.white,Color.black,""+pinchBuffer);
			
		}
		else if(viewBuffer!=null)
			{ 
			  Image im0 = viewBuffer.theImage;
			  Graphics gr = im0.getGraphics();
			  GC.setColor(gr,Color.blue);
			  GC.fillRect(gr, 10,10,20,20);
			  viewBuffer.theImage.drawImage(g,x,y,w2,h1);
			  GC.Text(g,false,x,y+h1,w1,20,Color.white,Color.black,""+viewBuffer);
			  
			}
			else { GC.setColor(g,Color.blue); GC.drawLine(g,x,y,x+w1/2,y+h1/2); }
		GC.frameRect(g,Color.blue,x,y,w2,h1);
		
		if(message!=null)
		{	GC.Text(g,false,xx+w1/8,y+h1,w1*5, h1/2,Color.white, null,""+step+":"+message+" rr "+repaintReadyCount+" rs "+repaintSpritesCount);
			message = "";
			repaintReadyCount = 0;
			repaintSpritesCount = 0;
		}
	}
  boolean cantPaint=false;
	private void cantPaintNow()
	{	Thread ll = directDrawingLock.locker();
		Thread cc = Thread.currentThread();
		Plog.log.addLog("Can't paint, locker "+ll+" current "+cc);
		cantPaint = true;
		long now = G.Date();
		if(waitingToPaintStart==0) { waitingToPaintStart = now; }
		setPaintNeeded(true);
		if(now-waitingToPaintStart>500)
		{	//String msg = directDrawingLock.lockThreadStack();
			//G.print("Waiting to paint ",msg);
			waitingToPaintStart = now;
		}
	}
	private XImage pinchBuffer = null;
	private void pinchRedisplay(Graphics g,boolean pinch)
	{
		viewBuffer=null; 
		drawBuffer = null;
		double r = helper.getRotation();
		int w = helper.getWidth()/2;
		int h = helper.getHeight()/2;	
		GC.setRotation(g, r,w,h);
		pinchBuffer.usedForPinch = true;
		G.Assert(pinchBuffer.written(),"not written");
		boolean rotated = helper.rotateCanvas(g);
		helper.drawActivePinch(g,pinchBuffer.getImage(),!pinch);
		if(rotated) { helper.unrotateCanvas(g); }
		if(showBitmaps)
		{
			showBitmaps(g,"pinch redisplay");
		}
		GC.setRotation(g, -r, w, h);
	}
	private boolean paintDirect(Graphics gc,boolean prerotated)
	{	boolean got = false;
		int tries = 0;
		while (!got)
			{ got = getDirectDrawingLock();
			  if(got || tries++ >= 3) { break; }
			  { try {
				synchronized (this) { wait(10); }
				} catch (InterruptedException e) {} 
			}
			} ;		
		if(got)
		{	if(cantPaint) 
				{//System.out.println("can paint"); 
				cantPaint=false;
				}
			try {
  			setPaintNeeded(false);
  			redrawCanvas(gc,prerotated);
			}
			finally { releaseDirectDrawingLock(); }	
		}
		else {
			if(G.debug()) { GC.fillRect(gc,Color.red,0, 0, 10, helper.getHeight()); }
			cantPaintNow();
		}
		return(got);
	}
	// return true if the buffer was drawn
	// if false is returned, a timer has been set
	private boolean drawBufferIfReady(Graphics g,XImage back)
	{
		long now = G.Date(); 
		int delay = back.timeUntilReadyToSee(now);
		if(delay<=0)
		  {
			step++;		
	   		boolean rotated = helper.rotateCanvas(g);
			drawToRealScreen(g,back);
	   		HitPoint hp = (highlightPoint == null) ?  new HitPoint(-1,-1) : highlightPoint;
    		helper.actualPaint(g,hp);		// this does the rest of painting, ie; painting components
    		if(rotated) { helper.unrotateCanvas(g); }
    		return(true);
		  }
		  else 
		  { 
		    addTimer(now,delay,RefreshReason.ReadyToSee,"buffer not ready");
		    return(false);
		  }
	}
    public void paint(Graphics g)
    { 	if(shutdown) { return; }
    	boolean didit = false;
      	if(G.canRepaintLocally(client)
				|| GC.canRepaintLocally(g))
    	{
    	GC.setFont(g,helper.getDefaultFont());	// start with a consistent font
		boolean pinch = helper.globalPinchInProgress();

   		if(pinch && ZOOM_IS_SLOW)
   		{	// to make pan/zoom responsive, work from a saved bitmap of some kind
   			if(pinchBuffer==null)
   			{	
   				XImage pbuffer = getOrCreateViewBuffer();
   				if(pbuffer!=null)
   				{
   				if(repaintStrategy.useViewBuffer())
   					{
   					// make sure some data is forthcoming
   					// this path is used by pinch zoom the lobby and seatingViewer 
   					if(!pbuffer.written()) {paintDirect(null,true); }	// trigger a write
  					if(!pbuffer.written()) { pbuffer = null; }
   					}
   				else {
   					// we don't normally use a view buffer, so this one was created for us
   					// we need to write it
   					Graphics off = pbuffer.getImage().getGraphics();
   					// this will fall through the stages without drawing on a backing bitmap,
   					// then draw to the new one we just created.
   					if(paintDirect(off,true))
   						{
   						long fintime = G.Date();
   						long when = fintime+repaintStrategy.delayBeforeReading;
   						pbuffer.setWritten(when);
   						didit = true;
   						}
   					else { pbuffer = null; }
    				}
   				}
   				pinchBuffer = pbuffer;
   			}
   			if(pinchBuffer!=null)
   			{
   				pinchRedisplay(g,pinch);
   	   			return;
   			}
   		}
   		

   		if(pinchBuffer!=null)
   		{
   		pinchBuffer = null;
   		}
    	switch(repaintStrategy)
    	{   	
    	case Deferred_Unbuffered:
    	case Deferred:
       		setComplete(true);		// say we need it
    		addTimer(0,0,RefreshReason.DeferredComplete,"Paint");
            break;
            
   		  	
    	case DoubleBuffer:
    		swapBuffersIfReady();
    	case SingleBuffer:
    	{	// draw a buffer that was prepared elsewhere
    	{	
    		XImage im = getOrCreateViewBuffer();
    		if(im!=null)
     		{
    		//if(showBitmaps) { G.print(""+step+": start "+repaintStrategy); }
    			if(im.written())
    			{
    			if(!drawBufferIfReady(g,im))
    				{ 
    				  return; 
    			}
    			didit = true;
    			}
     			}}
			if(write_needed) 
			{ 
			  write_needed = false; repaint(repaintStrategy.delayBeforeWriting,"delayed write after"); 
    		}
       		return;
    		}
     		
    	// can fall through if unable to create a buffer
       	case Direct_Unbuffered:
       		triggerEvent = null;
       		helper.resetLocalBoundsIfNeeded();
       		{
      		String msg = null;
       		if(!paintDirect(g,false))
       		{	msg = "skip paint";
       			addTimer(G.Date(),10,RefreshReason.Paint,"can't paint now");

       		}
       		if(showBitmaps)
    		{
    			showBitmaps(g,msg);
    		}}

       		break;
    	
       	/* fall into the direct draw case if there's no backing store or a pinch is in progress*/
       	case Direct_SingleBuffer:
    		//GC.fillRect(g,fill,0,0,10,client.getHeight());
       		helper.resetLocalBoundsIfNeeded();
       		
       		triggerEvent = null;
       		{
       		String msg = null;
   			XImage back = getOrCreateViewBuffer();
  			if(back!=null)
  			{	
  				if(back.unseen())
  				{
  						boolean nowSeen = drawBufferIfReady(g,back);
  						if(nowSeen) 
  							{ if(showBitmaps) { showBitmaps(g,"buffer not ready"); } 
  							  if(!paintNeeded) { return; } 
  							}
   				}

  			// drop into paint
  			long now = G.Date();
  			int delay = back.timeUntilReadyToWrite(now);
  			Graphics off = back.getImage().getGraphics();
   			if(delay<=0 && paintDirect(off,false))
       			{
    	    	long fintime = G.Date();
  	   	    	long when = fintime+repaintStrategy.delayBeforeReading;
       	    	back.setWritten(when);
       	    	didit = true;
  	   	    	drawBufferIfReady(g,back); 
       			}
   			else if(back.readyToSee(now) && back.seenCount<3)
   			{  	// we didn't draw anything.  If there's a buffer ready show it.
   				step++;		
   				msg = "reuse bitmap";
   				drawImageNow(g,back);
  				now = G.Date();

   				int paintDelay = back.timeUntilReadyToWrite(now);
   				// try to delay the next paint attempt until the image will be ready to rewrite,
   				// but if seencount gets too high, give up.  This probably results in a
   				// flash frame. Oh well.
   				addTimer(now,paintDelay==0?0:paintDelay+10,RefreshReason.Paint,"not ready before draw");
   			}
  			else
  				{	//G.addLog("no paint");
  				msg = "No paint now";
   				addTimer(now,delay+10,RefreshReason.Paint,"not ready after draw");
  				}
 
         	}
       		else  
       		{	// no buffer available
       			msg = "no buffer available";
  				if(!paintDirect(g,false)) {
  	      			addTimer(G.Date(),10,RefreshReason.Paint,"can't paint direct now");
  				};	// show what we've got
       		}
  			if(showBitmaps)
	    		{
				showBitmaps(g,msg);
	    		}}
		  	break;
    	}
 
 
     }
      	if(!didit) { 
      		//G.print("no paint");
      	}
    }

    /** create a blank image with the specified size.
	    * 
	    * @param w
	    * @param h
	    * @return an Image
	    */
	    public Image createBlankImage(int w,int h,Color fillColor)
	    {	
	        try {
	        	Image im = //Toolkit.getDefaultToolkit().createImage();
	        		SIMULATE_LOW_MEMORY 
	        			? null 
	        			: USE_VOLATILE_IMAGE 
	        				? Image.getVolatileImage(helper.getComponent(),w,h) 
	        				: USE_BUFFERED_IMAGE 
	        				  ? Image.createTransparentImage(w,h) 
	        				  : Image.createImage(w,h);
	        	if(im==null)
	        	{setRepaintStrategy(RepaintStrategy.Direct_Unbuffered);
	        	 useBackgroundBitmap = false;
	        	 helper.setLowMemory("CreateImage "+w+"x"+h+" failed with null");
	        	}
	        	else if(fillColor!=null){
	        		Graphics gr = im.getGraphics();
	        		GC.fillRect(gr,fillColor,0,0,w,h);
	        	}
	        	return(im); 
	        }
	    	catch (ThreadDeath err) { throw err;}
	        catch (Throwable err)
	        { imageErrors++;
	          setRepaintStrategy(RepaintStrategy.Direct_Unbuffered);
	          useBackgroundBitmap = false;
	          helper.setLowMemory("CreateImage "+w+"x"+h+" failed with "+err);
	          if(imageErrors<3)
	          {
	        	  throw G.Error("createAllFixed #"+imageErrors+" "+w+"x"+h+" "+err) ;
	          }
	        }
	        return(null);
	    }

	    private void setAllFixed(XImage newv)
	    {	
	        XImage im = allFixed;
	        allFixed = newv;
	        if ((im != null) && (im != newv))
	        {
	            im.getImage().Dispose();
	        }
	    }
	    /**
	     * create (of necessary) and return an offscreen image
	     * with the specified size.  This image is intended to be
	     * used to draw background, rarely changing elements in the
	     * background.
	     * @param w
	     * @param h
	     * @return true if a new image was created
	     */
	    public boolean createAllFixed(int w, int h)
	    {	boolean newv=false;
	    	if(!useBackgroundBitmap)
	    	{	setAllFixed(null);	// release the old first
	    		return(false);
	    	}
	    	if (needNewImage(allFixed,w,h))
	    	{	
	    		setAllFixed(null);	// release the old first
	    		Image im = createBlankImage(w, h,fill);
	    		if(im!=null) { setAllFixed(new XImage(im)); }
	    		newv=true;
	    	}
	    	return (newv);
	    }
	    
	    public XImage allFixed() 
	    { 	XImage im = allFixed;
	    	if(im!=null)	    		
	    	if(!Image.getImageValid(client,im.getImage()))
	    		{ setAllFixed(null); 
	    		}
	    	return(im); 
	    }

	    public XImage getViewBuffer() 
	   	{ 
	    	switch(repaintStrategy)
	    	{
	    	case Direct_Unbuffered:
	    	case Deferred_Unbuffered:
	    		if(viewBuffer!=null) { setViewBuffer(null); } 
	    		return(null); 
	    	default:
	        	if(viewBuffer!=null)
	        		{int w = helper.getRotatedWidth();
	        	     int h = helper.getRotatedHeight();
	        	     if(needNewImage(viewBuffer,w,h)) 
	        	     	{ setViewBuffer(null); 
	        	     	}
	        		}
	        	  return(viewBuffer); 
	    	}
	    }
	    
	    public Image getOffScreenImage()  
	    { XImage pb = getViewBuffer();
	      return((pb!=null)? pb.theImage : null);
	    };
	    public XImage getOrCreateViewBuffer()
	    {
	    	XImage im = getViewBuffer();
	    	if(USE_VOLATILE_IMAGE && im!=null)
	    	{	if(!Image.getImageValid(client,im.getImage()))
	    			{ 
	    			  im = null; 
	    			}
	    	}
	    	if(im==null)
	    		{ im = createViewBuffer(); 
	       		  if(im!=null)
	       		  { //if we got a virgin bitmap, schedule an actual paint asap
	       			  addTimer(0,0,RefreshReason.VirginBuffer,"virgin paint buffer "+im);
	       		  }
	    		}
	    	return(im);
	    }
	    
	    public XImage getOrCreateDrawBuffer()
	    {
	    	XImage im = getDrawBuffer();
	    	if(USE_VOLATILE_IMAGE && im!=null)
	    	{	if(!Image.getImageValid(client,im.getImage()))
	    			{ 
	    			  im = null; 
	    			}
	    	}
	    	if(im==null)
	    	{ switch(repaintStrategy)
	    		{
	    		case DoubleBuffer:
	    			im = createDrawBuffer(); 
	    			break;
	    		default:
	    			im = createViewBuffer();
	    			break;
	    		}
	    	}
	    return(im);
	  	}
	    
	    private XImage getDrawBuffer() 
	    { 
	    	switch(repaintStrategy)
	    	{
	    	case Deferred_Unbuffered:
	    	case Direct_Unbuffered:
	    		setViewBuffer(null);
	    		return(null);
	    	case DoubleBuffer: 
	    		{int w = helper.getRotatedWidth();
	    		 int h = helper.getRotatedHeight();
	    		 if(needNewImage(drawBuffer,w,h)) 
	    		 	{ drawBuffer = null; 
	    		 	}
	    		}
	    		return(drawBuffer);
	    	case Deferred:
	    	case Direct_SingleBuffer:
	    	case SingleBuffer: 
	    	default:
	    		return(getViewBuffer());
	    	}
	    }
	    
	    private void swapOffScreenNow()
	    {	XImage off = viewBuffer;
	    	 // inhibit the swap if there's an unseen frame ready
	        viewBuffer = drawBuffer;
	        drawBuffer=off;
	        if(off!=null) { off.clear(); }
	    }
		private boolean write_needed = false;

	    private void swapBuffersIfReady()
	    {	switch(repaintStrategy)
	    	{
	    	default: break;
	    	case DoubleBuffer:
	    	{	XImage draw = drawBuffer;
	    		if(draw!=null)
	    		{
	    		long now = G.Date();
	    		boolean readytosee = draw.readyToSee(now);
	    		if(readytosee)
	    			{ 
	    			swapOffScreenNow();
	    			}
	    		}
	    	}}
	    }
	    
	    	    
	    private void setViewBuffer(XImage newv)
	    {
	        XImage im = viewBuffer;
	        viewBuffer = newv;
	        if ((im != null) && (im != newv))
	        {
	            im.theImage.Dispose();
	        }
	        if(newv==null && (drawBuffer!=null))
	        {	// always flush both
	        	swapOffScreenNow();
	        	setViewBuffer(null); 
	        }
	    }
	  
	    private final boolean needNewImage(XImage im,int w,int h)
	    {	return((im==null) || needNewImage(im.theImage,w,h));
	    }
	    private final boolean needNewImage(Image im,int w,int h)
	    {	if((im==null)
	    		|| !Image.getImageValid(client,im)) { return true; }

	    	if( (im.getWidth()!=w
	    			|| (im.getHeight()!=h)))
	    	{
	    		return true;
	    	}
	    	return false;
	    }
	    
	    public void setRepaintStrategy(RepaintStrategy strat)
	    {
	    	repaintStrategy = strat;
	    	RepaintStrategy.setStrategyMenuChoice(strat);
	    	repaintStrategy.setSliders();
	    	switch(strat)
	    	{
	    	case Deferred_Unbuffered:
	    	case Direct_Unbuffered:
	    		setViewBuffer(null); 
	    		/** fall through */
	    	case SingleBuffer:
	    	case Direct_SingleBuffer:
	    	case Deferred:
				if(drawBuffer!=null) { swapOffScreenNow(); setViewBuffer(null); }
				break;
	    	default:
	    		break;
	    	}
	    }
	    /**
	     * create (if necessary) and return an offscreen image with
	     * a specified size.  This image is intended to be used for
	     * routine offscreen drawing before displaying on the canvas.
	     * If double buffering is in effect, the back buffer is returned.
	     * 
	     * @param w
	     * @param h
	     * @return true if a new image was created
	     */
	    public XImage createOffScreen(int w, int h)
	    {	
	    	Image newim = createBlankImage(w, h,fill); 
	    	if(newim!=null) 
	            {
	    		return(new XImage(newim));
	            }
	    	return(null);
	    }



	     /** timer expired requiring a real paint */
	     public void redrawCanvas()
	     {	if(shutdown) { return; }
	     
	     	switch(repaintStrategy)
	     	{
	     	case Direct_Unbuffered:
	     	case Direct_SingleBuffer:	
	     		setPaintNeeded(true);
	     		break;
	     	case Deferred_Unbuffered:
	     	case Deferred:
		    	 {
		    	 Graphics g = Graphics.create(client.getGraphics());
		       	 redrawCanvas(g,false);
		    	 }
		    	 break;
	     	default:
	     		{
		       	 redrawCanvas(null,false);
	     		}
	     		break;
	     	} 	 
	     }
	     private int repaintSpritesCount = 0;
	     public void repaintSprites(int timer,String caller)
	     {	
	    	repaintSpritesCount++;
	    	addTimer(G.Date(),timer,RefreshReason.Sprites,caller);
	     }
	     public void redrawCanvas(Graphics g,boolean prerotated)
	     {	 
	    	 boolean complete = setComplete(false);
	 //        setVisible(shouldBeVisible);
	 //        imageCache.clearCachedImages();

	         final HitPoint hp = (highlightPoint == null) ?  new HitPoint(-1,-1) : highlightPoint;
	         final Graphics hg = g;
	         final boolean hcomplete = complete;
	         //
	         // start the paint with no hitobject, this makes the 
	         // actual drawing pass behave the same as the mouse-only pass
	         //
	         // IOS only does rendering in EDT
	         if(G.isCodename1())// this forces all drawing into the edt thread
	         {	
	        	 G.runInEdt(
	     				new Runnable () 
	     				{	public String toString() { return("draw main screen"); }
	     					public void run() 
	     					{ 
	     			          if(hcomplete) { setBuffersComplete(); clearStats(); }
	     					  ErrorReporter old = G.setErrorReporter(helper);
	     					  drawCanvas(hg,hcomplete,hp,prerotated);
	     					  G.setErrorReporter(old);
	     					}
	     				}); 
	         }
	         else {
		     if(complete) { setBuffersComplete(); clearStats(); }
	         drawCanvas(hg, hcomplete,hp,prerotated);
	         }
	     }
	     
	     int errors = 0;
	     private XImage createViewBuffer()
	     {
	    	 int width = helper.getRotatedWidth();
	    	 int height = helper.getRotatedHeight();
	    	 XImage pb = createOffScreen(width,height);
	    	 setViewBuffer(pb);
	    	 return(pb);
	     }
	     private XImage createDrawBuffer()
	     {
	    	 int width = helper.getRotatedWidth();
	    	 int height = helper.getRotatedHeight();
	    	 XImage pb = createOffScreen(width,height);
	    	 drawBuffer =pb;
	    	 return(pb);
	     }

	     /**
	      * this is the method that actually draws the window, which will
	      * can be superseded by the final window class.  This default method
	      * creates an off screen bitmap and calls {@link #repaintCanvas } with the 
	      * gc of the off screen bitmap, so if that is the desired behavior
	      * repaintCanvas can be overridden instead. 
	      * 
	      * @param gc a graphics object
	      * @param completePaint if true, do a complete refresh
	      * @param pt a {@link lib.HitPoint}, representing the state of the mouse.
	      * 
	      * @see HitPoint
	      */
	    public void drawCanvas(Graphics gc, boolean completePaint,HitPoint pt,boolean prerotated)
	 	{	
	 		long now = G.Date();
	 		boolean drawn = false;
	 		boolean direct = false;
	    	try {
	    	switch(repaintStrategy)
	    	{
	    	case Deferred_Unbuffered:
	    	case Direct_Unbuffered:
	    			direct = true;
	    			break;
	    	case Direct_SingleBuffer:
	    		break;
	    	default:
		    	{
		 		XImage localOffScreen = getOrCreateDrawBuffer();
		 		boolean complete = completePaint | (localOffScreen !=null && localOffScreen.mustBeComplete);
		 		if(localOffScreen!=null)
		 	    {  	localOffScreen.mustBeComplete = false;
		 			switch(repaintStrategy)
		 			{
		 			case DoubleBuffer:
		 			case SingleBuffer:	
	    	    	if(localOffScreen.unseen() || !localOffScreen.readyToDiscard(now))
				       	{
	    	    		write_needed = true;
	    	    		if(completePaint) { setComplete(true); }	// reinstate completeness
	    	    		int delay = localOffScreen.timeUntilReadyToWrite(now);
	    	    		//G.addLog("Delay writing "+localOffScreen+" for "+delay);
	    	    		addTimer(now,delay,RefreshReason.ReadyToSee,"deferred write");
	    	    		return; 
				    	}
			       	   default: break;
		 	    	}
		        	boolean rotated = helper.rotateCanvas(gc);
		    	    redrawCanvas(localOffScreen,gc,complete,pt);
		 			if(rotated) { helper.unrotateCanvas(gc); }
		       		drawn = true;
		 	    }
		 		else { direct = true; }

		        		}
		 		}
		    	
		    	if(gc!=null && !drawn)
		 	    	{
		           	int x = helper.getSX();
		        	int y = helper.getSY();
		        	boolean rotated = !prerotated && direct && helper.rotateCanvas(gc); 
		        	GC.translate(gc,-x,-y);
		 	    	helper.drawClientCanvas(gc,completePaint,pt);
		 	    	helper.paintSprites(gc,pt);
		 	    	GC.translate(gc,x,y);
		 	    	if(rotated) { helper.unrotateCanvas(gc); }
		 	    	if(showBitmaps && !helper.globalPinchInProgress())
		 	    	{
		 	    		showBitmaps(gc,"no buffer available");
		 	    	}
		 	    	paintedAFrame = true;
		      		GC.setColor(gc,Color.blue);
		        	helper.showRectangles(gc,pt,100);
		        	helper.ShowStats(gc,pt,0,0);
	    	
		    	}
	    	}
	 		catch (Throwable err)
	 		{	if(errors++<10) {	helper.handleError("in paintCanvas",null,err); }
	 		}
       
	 		long later = G.Date()-now;
	 		lastPaintTime = later;
	    	paintTime += later;
	    	paintSteps++;
	  	}
	    	
	 	private void redrawCanvas(XImage offScreen,Graphics gc,boolean complete0, HitPoint pt)
	 	{	
	 		boolean complete = setComplete(false)|complete0;
	  		Graphics offGC = offScreen.getGraphics();	// also marks it as unseen
	  		GC.setFont(offGC,helper.getDefaultFont());
           	int x = helper.getSX();
        	int y = helper.getSY();
        	GC.translate(offGC,-x,-y);
	  		// font, line style, etc are not well defined at this point
	  		helper.drawClientCanvas(offGC,complete,pt);
	  		paintedAFrame = true;
			    
	    	helper.showRectangles(offGC,pt,100);
	    	helper.paintSprites(offGC,pt);

	    	helper.ShowStats(offGC,pt,x,y);	// add some stats on top of everything

	    	GC.setColor(offGC,Color.blue);
	    	GC.translate(offGC,-x,-y);
    	//G.addLog("writing "+offScreen);
	    	drawToRealScreen(gc,offScreen);
		    
		    offScreen.mustBeComplete = false;
   	    	long fintime = G.Date();
   	    	long when = fintime+repaintStrategy.delayBeforeReading;
   	    	offScreen.setWritten(when);
   	    	//if((offScreen.sequence&1)==0)
   	    	//{
   	    	//	G.startLog("new frame "+offScreen);
   	    	//}
   	    	if(repaintStrategy!=RepaintStrategy.Deferred) 
   	    	{
   	    	addTimer(fintime,repaintStrategy.delayBeforeReading,RefreshReason.ReadyToSee,"RepaintCanvas");	    // wake us when the frame is ready
   	    	//System.out.println("Release delay "+repaintStrategy.releaseTime);
   	    	}
   	    	else 
   	    	{ 
   	    		offScreen.setReadyToSee(); 
   	    	}
	 	}
	 	private void drawImageNow(Graphics gc,XImage im)
	 	{
	 	 im.theImage.drawImage(gc, 0,0);
	 		long now = G.Date();
	 		im.setReadyToRewrite(now+repaintStrategy.delayBeforeWriting);
	 	}
	 	public void drawToRealScreen(Graphics gc,XImage im)
	 	{	
	 		double rot = helper.getRotation();
	 		int w = client.getWidth()/2;
	 		int h = client.getHeight()/2;
    		GC.setRotation(gc, rot,w,h);
    		drawImageNow(gc,im);
	    	GC.setRotation(gc, -rot, w,h);
	    	
    		if(showBitmaps && (gc!=null)  && !helper.globalPinchInProgress())
    		{	boolean rotated = gc._rotated_;
				if(rotated) { helper.unrotateCanvas(gc); }
    			showBitmaps(gc,null);
    			if(rotated) { helper.rotateCanvas(gc); }
    		}

	    	Image dup = duplicateImage;
	    	if(dup!=null)
	    	{
	    		Graphics g2 = dup.getGraphics();
	    	 im.theImage.drawImage(g2, 0, 0);
	    		captureState = im.writtenState;
	    		duplicateImage = null;
	    		G.wake(dup);
	    	}
	 	}
	     /** request a normal refresh of the window
	      * some background elements may not be repainted.
	      */
	     public void repaint(String w)
	 	{ 	if(G.canRepaintLocally(client))
	 		{ 	
	     		repaint(0,w);
	 		}
	 	}
	     public void repaint(int tm,String w)
	     {	
	    	 addTimer(0,tm,RefreshReason.Paint,w);
	     }

	     private boolean sleeping = false;
	     private synchronized void setSleeping(boolean val) { sleeping = val; }
	     private synchronized boolean sleeping() { return(sleeping); }	   
	     private boolean waitAWhile(PaintTimer timer)
	     {	
	     	 boolean waited = false;
	     	 long now = G.Date();
	     	 long howLong = timer.expiration - now;
	    	 if(howLong>0) 
	    	 	{ long beginsleep = now; 
	    	 	  setSleeping(true);
	    	 	  //
	    	 	  // direct drawing lock is released only while we sleep
	    	 	  //
	    	 	  releaseDirectDrawingLock();
	    	 	  G.timedWait(client,howLong);
	    	 	  setSleeping(false);
	    	 	  waited = true;
	    	 	  long later = G.Date();
	    	 	  long sl = later-beginsleep;
	    	 	  //
	    	 	  // re acquire the direct drawing lock
	    	 	  while(!getDirectDrawingLock()) 
	    	 	  	{ G.waitAWhile(client,10); 
	    	 	  	}

	    	 	  sleepTime += sl; 
	    	 	  if(benchTime==0) { benchTime = beginsleep; }
	    	 	}
	    	 return(waited);
	     }

	     /**
	      * this captures the standard java "update" request,
	      * but doesn't do any painting.
	      */
	     public void update(Graphics g)
	     { 	// this is an attempt to affect the "blank screen" problem.
	     	// the theory is that our non-painting is resulting in a damaged
	     	// drawing engine.
	     	//G.combinedClip(g,0,0,0,0);
	     	//super.update(g);
	     	//
	     	// also note; dealing with problems where the chat area is blank, you 
	     	// can frequently "fix" the problem by forcing theChar.update(g) here,
	     	// or by adding super.update(g) here.   Drawing a colored line here
	     	// also is useful to diagnose some problems.  See comments about JPanel
	     	// verses Panel in commonChatApplet and commonPanel.
	     	//
	     	switch(repaintStrategy)
	     	{
	     	case Deferred:
	     	case Deferred_Unbuffered:
	         	wakeMe();
	         	break;
	     	case SingleBuffer:
	     	case DoubleBuffer:
	     	case Direct_Unbuffered:
	     	case Direct_SingleBuffer:
	     		paint(g);
	     		break;
	     	default: G.Error("Not expecting strategy %s",repaintStrategy);
	     		break;
	     	}
	     }

	    public void wakeMe()
	    { 	
	    	wake();
	    }
	    /** wake the run loop early.  This should not normally be necessary
	     * 
	     *
	     */
	    public void wake()
	    {	
	        G.wake(client);
	    }
	    //
	    // this should be called instead of "repaintAndOrSleep" when the user interface hasn't been 
	    // fully initialized.  #1 because there has to be a sleep somewhere in the event loop
	    // and #2 because if "direct draw" is possible (ie; IOS) we need to lock out drawing
	    // until the UI us set up.
	    //
	    public void justSleep(int howLong)
	    {	
	    	setBoundsNonPaint();
	    	if(howLong>=0)
	    	{
	    	if(shutdown)
	    		{
	    		// this can occur when a window is in the process of being removed
	    		G.timedWait(client,100);
	    		}
	    	else {
	    	final long now = G.Date();
	    	//G.startLog("repaintOrSleep "+howLongMax);
		   	addTimer(now,howLong,RefreshReason.Timed,"repaintAndOrSleep");
		   	PaintTimer next = getNextTimer();
		   	waitAWhile(next);
		   	//G.print("Uninit sleep "+howLong);
	    	}}
	    }
	    public void setBoundsNonPaint()
	    {	switch(repaintStrategy)
	    	{
	    	case Direct_Unbuffered:
	    	case Direct_SingleBuffer: 
	    		break;
	    	default:
	    		helper.resetLocalBoundsIfNeeded();
	    	}
	    }
	    
	    //
	    // call this to sleep and take appropriate actions when the sleeping
	    // is interrupted.  The ought to be the ONLY place in the event loop
	    // where sleeping is done.  It also orchestrates redrawing and other
	    // activity that should happen, related to the game activity
	    //
	    public void repaintAndOrSleep(final int howLongMax)
	    {	
	    	if(howLongMax>=0)
	    {	
	    	final long now = G.Date();
	    	//G.startLog("repaintOrSleep "+howLongMax);
		   	addTimer(now,howLongMax,RefreshReason.Timed,"repaintAndOrSleep");
		   			
		   	// process timers until we wait once
		    PaintTimer next = null;
		    boolean waited = false;
		    paintedAFrame = false;				// exit when we've actually painted a frame, let the main loop run around
		   	do { next = getNextTimer(); 
		   		if(next!=null)
		   			{
		   			final int nextv = (int)(next.expiration-now);
		   		    if(nextv>0 && helper.needsCacheManagement())
   						{
		   				G.startInEdt(new Runnable() { public void run()	{ 	 helper.manageCanvasCache(nextv); 	}});
   						}
		   			waited |= waitAWhile(next);
				   	next = getNextTimer();
					setBoundsNonPaint();
		   			{ if(setPaintNeeded(false) && !paintedAFrame)
		   				{
		   				boolean canSee = G.isCompletelyVisible(client) || G.isPartlyVisible(client);
		   				if(canSee)
		   				{	// if we can't see the window, don't actually repaint
		   					// we'll get another paint request when we can see it.
		   					redrawCanvas(); 
		   			    }}}
		   			}
		   	} while(next!=null && !waited && !paintedAFrame);
	    	}
	   	
	    }
	    private JCheckBoxMenuItem showBitmapsChoice = null;
	    private JCheckBoxMenuItem slowZoomChoice = null;
	    private JCheckBoxMenuItem fixedBackgroundChoice = null;
	    private JCheckBoxMenuItem useVolatileChoice = null;


	    public boolean handleDeferredEvent(Object target)
	    {	
	    	RepaintStrategy v = RepaintStrategy.isStrategyMenu(target,repaintStrategy);
    		if(v!=null)
    		{
    			setRepaintStrategy(v);
        	}
    		else if(target==useVolatileChoice)
    		{
    			USE_VOLATILE_IMAGE = useVolatileChoice.getState();
     			setViewBuffer(null);
     			setAllFixed(null);
    		}
    		else if(target==fixedBackgroundChoice)
	    	{
	    		useBackgroundBitmap = fixedBackgroundChoice.getState();
	    	}
	    	else if(target==showBitmapsChoice)
	    	{
	    		showBitmaps = showBitmapsChoice.getState();
	    	}
	    	else if(target==slowZoomChoice)
	    	{
	    		ZOOM_IS_SLOW = slowZoomChoice.getState();
	    	}
	        else if(RepaintStrategy.handleDeferredEvent(target)) { return(true); }
	        else {  return(false); }
	    	return(true);	
	    }

	    public void addUIChoices(LFrameProtocol myFrame,DeferredEventManager deferredEvents)
	    {	if(myFrame!=null)
	    	{
	    	JMenu setBuffer = myFrame.addChoiceMenu("Set Buffering",null);
	    	useVolatileChoice = new JCheckBoxMenuItem("use volatile images");
	    	useVolatileChoice.setState(USE_VOLATILE_IMAGE);
	    	useVolatileChoice.addItemListener(deferredEvents);
	    	setBuffer.add(useVolatileChoice);
	    	
	    	fixedBackgroundChoice = new JCheckBoxMenuItem("use background bitmap");
	    	fixedBackgroundChoice.setState(useBackgroundBitmap);
	    	fixedBackgroundChoice.addItemListener(deferredEvents);
	    	setBuffer.add(fixedBackgroundChoice);
	    	
	    	if(SHOW_TIMERS)
	    	{
	    	setBuffer.add(RepaintStrategy.frameTimersOn = new JCheckBoxMenuItem("Show Frame Timers"));
	    	RepaintStrategy.frameTimersOn.addItemListener(deferredEvents);
	    	RepaintStrategy.frameTimeSlider = new Slider("rewrite=",RepaintId.FrameTime,0,250,repaintStrategy.delayBeforeWriting);
	    	RepaintStrategy.releaseTimeSlider = new Slider("read=",RepaintId.ReleaseTime,0,250,repaintStrategy.delayBeforeReading);
	    	}
	    	showBitmapsChoice = new JCheckBoxMenuItem("show debug bitmaps");
	    	showBitmapsChoice.setState(showBitmaps);
	    	showBitmapsChoice.addItemListener(deferredEvents);
	    	setBuffer.add(showBitmapsChoice);
       	 
	    	slowZoomChoice = new JCheckBoxMenuItem("slow zoom");
	    	slowZoomChoice.setState(ZOOM_IS_SLOW);
	    	slowZoomChoice.addItemListener(deferredEvents);
	    	setBuffer.add(slowZoomChoice);

	    	RepaintStrategy.addUIMenu(setBuffer,deferredEvents,repaintStrategy);
	    	           	 
	    	}
	    }
	    public void positionSliders(Graphics gc,HitPoint highlight,Rectangle goalRect)
	    {	RepaintStrategy.positionSliders(gc,highlight,goalRect,repaintStrategy);
	    }
	    
	    int captureState = 0;
	    VNCTransmitter transmitter;
	    public void setTransmitter(VNCTransmitter m) { transmitter = m; }
	    public VNCTransmitter getTransmitter() { return(transmitter); }
	    public boolean isActive() { return(transmitter!=null && transmitter.isActive()); };
	    String stopReason = null;
	    public void stopService(String reason)
	    {	stopReason = reason;
	    	G.wake(duplicateImage);
	    	duplicateImage = null;

	    	VNCTransmitter tm = transmitter;
	    	transmitter = null;
	    	if(tm!=null)
	    	{
	    		tm.stop(reason);
	    	}
	    }
	    public boolean needsRecapture()
	    {
	    	XImage im = getViewBuffer();
	    	return(im==null ? true : im.writtenState!=captureState);
	    }
	    // capture a copy of the screen to an image.  This is
	    // synchronized with the actual drawing, so there's no
	    // flashy-flashy behavior
	    public void captureScreen(Image im,int timeout)
	    {
	    	duplicateImage = im;
	    	while(duplicateImage!=null)
	    	{	G.waitAWhile(im, timeout);
	    		client.repaint(); 
	    	}
	    }
	    //
	    // capture the current image, but not synchronized so some flashy
	    // behavior will appear
	    //
		public Image captureScreen() 
		{
			XImage im = createViewBuffer();
			captureState = im.writtenState;
			return(im.getImage());
		}

		public Rectangle getScreenBound() {
			return(new Rectangle(0,0,client.getWidth(),client.getHeight()));
		}
		double imageSize(Image x,ImageStack im) { return(x==null) ? 0 : x.imageSize(im); }
		
		double imageSize(XImage x,ImageStack im)
		{ return((x==null) ? 0 : x.imageSize(im)); } 
		public double imageSize(ImageStack im)
		{	return( imageSize(allFixed,im)
					+ imageSize(duplicateImage,im)
					+ imageSize(viewBuffer,im)
					+ imageSize(drawBuffer,im)
					);
		}
		public boolean performStandardButtons(CellId id)
		{	return(id instanceof RepaintId);
	    } 		
		/**
		 * a minimal run and report errors loop
		 */
		public void runLoop()
		{	
			try {
			do {
				repaintAndOrSleep(1000);
				if(paintNeeded)
					{ 
					  helper.actualRepaint(); 
					}
			} while(!shutdown);
			}
			catch (Throwable err)
			{	helper.handleError("in repaint run loop", null,err);
			}

			hasRunLoop = false;
		}
		/**
		 * this starts a minimal run loop for the benefit of windows
		 * that use the repaintmanager but do not need a run loop of
		 * their own.
		 */
		public void startRunLoop()
		{	hasRunLoop = true;
			new Thread(new Runnable() { public void run() { runLoop(); }}).start();
		}
		
	    Image blank = Image.createTransparentImage(1,1);

        public void drawFixedElements(Graphics gc,boolean complete)
        {
			GC.setFont(gc,helper.getDefaultFont());
			int w = helper.getRotatedWidth();
			int h = helper.getRotatedHeight();
			complete |= createAllFixed(w,h);				// true if this is a new bitmap that needs to be painted
          	XImage fixed = allFixed();		 // create backing bitmaps;
          	boolean drawn = false;
        	if(fixed!=null)
        	{	// draw the fixed background elements, either into the fixed bitmap
            	// or to the immediate bitmap, or to the screen directly.
          		int tx = helper.getSX();
        		int ty = helper.getSY();
        		if(complete) 
        	    	 { // redraw the deep background
        	    		Graphics allFixedGC = fixed.getGraphics();
        	    		allFixedGC.translate(-tx,-ty);
        	    		helper.drawBackground(allFixedGC, fixed.getImage());
        	    		// this is an experiment to stall the pipeline and try
        	    		// to avoid the damaged background image problem
        	    		blank.drawImage(allFixedGC,0,0);
        	    		allFixedGC.translate(tx,ty);
   						long fintime = G.Date();
   						long when = fintime+repaintStrategy.delayBeforeReading;
   						fixed.setWritten(when);
         	    	 }
            	// draw the deep background on the immediate background
            	// the main gc will have already been shifted by scrollX,scrollY,
            	// so we need to unshift it.
        		long now = G.Date();
        		if(fixed.readyToSee(now))
        		{
        		fixed.getImage().drawImage(gc,tx,ty);
        		drawn = true; 
        		}
        	}
        	if(!drawn)
        		{
        		// this will redraw live if the background isn't ready to see yet
            	helper.drawBackground(gc, null);
        		}

         }
}