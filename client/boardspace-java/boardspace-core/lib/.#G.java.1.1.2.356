package lib;

import bridge.*;
import bridge.Polygon;
import bridge.TextArea;
import java.awt.*;
import java.net.URL;
import java.security.AccessControlException;

import javax.swing.JOptionPane;
import java.net.MalformedURLException;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.TimeZone;

/**
 * Class G contains "General utilities", and small static functions
 * that any program may need.
  * @author Dave Dyer <ddyer@real-me.net>
 * 
 */
public class G extends Platform implements Timestamp
{	
	// names of constant strings used here.
	public static final String CODEBASE = "codebase";
	public static final String DOCUMENTBASE = "documentbase";
	public static final String DEBUG = "debug";
	public static final String OFFLINE = "offline";
	public static final String VNCCLIENT = "vncclient";
	public static final String ALLOWOFFLINEROBOTS = "allowofflinerobots";
	public static final String PLAYTABLE = "playtable";
	public static final String GAMEBOARD = "gameboard";
	public static final String TABLENAMEKEY = "playtablename";
	public static final String LANGUAGE = "language";
	public static final String TABLEWIDTH = "tablewidth";
	public static final String TABLEHEIGHT = "tableheight";
	
	public enum GlobalStatus { awake,asleep }
	public static GlobalStatus globalStatus = GlobalStatus.awake;
	public static GlobalStatus getGlobalStatus() { return(globalStatus); }
	public static void setGlobalStatus(GlobalStatus st ) { globalStatus = st; }
	
	public static boolean TimeControl() { return globals.getBoolean("timecontrol",true); }
	public static boolean allowRobots()
	{
		return(!globals.getBoolean(G.OFFLINE,false) || globals.getBoolean(G.ALLOWOFFLINEROBOTS,false));
	}
	static String name = null;
	public static String uniqueName() 
	{
		if(name==null) { name = "U"+(int)(nanoTime()%10000); }
		return(name);
	}
	public static void setUniqueName(String s)
	{
		if(name==null) { name=s; }
	}
	/**
	 * get a string that is not upper case or null.
	 * @param a
	 * @return a String
	 */
	public static String lcString(String a) { return((a==null) ? "" : a.toLowerCase()); }

	static ShellProtocol printer=null;
	/**
	 * set a shell as the printer used by {@link #print}, or null to use System.out
	 * @param p null or an instance of {@link ShellProtocol}
	 */
	public static void setPrinter(ShellProtocol p) { printer=p; }
	/** get the current printer being used by {@link #print}
	 * @return null or an instance of {@ ShellProtocol}
	 */
	public static ShellProtocol getPrinter() { return(printer); }
	/**
	 * the last error posted by {@link Http#postError}
	 */
	public static String postedError = null;
	/**
	 * set by {@link Http#postError}, these messages are relayed to
	 * the current chat window so the player is also aware of the trouble.
	 * @param m
	 */
	public static void setPostedError(String m)
	{
		if(postedError==null) { postedError = m; } else { postedError += "\n"+m; }
	}
	/**
	 * get the posted error, if any, and clear the error.  This is used by the chat
	 * window to collect and relay errors so the user sees them.
	 * @return a string or null
	 */
	public static String getPostedError() { String p = postedError; postedError = null; return(p); }
	
	public static Hashtable<String,String>messages = new Hashtable<String,String>();
	public static boolean p1(String msg)
	{
		if(messages.get(msg)==null)
		{	messages.put(msg, msg);
			G.print("P1: "+msg);
			return(true);
		}
		return(false);
	}
    /**
     * utility to print test messages, use "find callers" to find messages still in place.
     * This method also interfaces with shells created by the "open shell" menu item.  If
     * a shell has been opened, it is used instead of System.out as the output device.
     * 
     * @param msg
     */
	public static boolean print(Object... msg)
	{
		if(printer!=null)
		{
			printer.println(msg);
		}
		else
		{ for(int i=0;i<msg.length;i++) { Object m = msg[i]; System.out.print( m==null?"null":m.toString()); }
		  System.out.println();
		}
		return(false);
	}
    public static String toString(Object ob[])
    {
    	StringBuilder p = new StringBuilder();
    	if(ob==null) { p.append(""+ob); }
    	else { p.append("#{");}
    	for(Object c :  ob) { p.append(""+c+" "); }
    	p.append("}");
    	return(p.toString());
    }
    public static String toString(byte ob[])
    {
    	StringBuilder p = new StringBuilder();
    	if(ob==null) { p.append(""+ob); }
    	else { p.append("#{");}
    	for(byte c :  ob) { p.append(""+(0xff&c)+" "); }
    	p.append("}");
    	return(p.toString());
    }
	// boolean so print can be used as a breakpoint test 
    public static boolean print(String msg) 
    	{ 	if(printer!=null) { printer.println(msg); }
    		else { System.out.println(msg); } 
    		return(false);
    	} 
 
    /** print the stack trace associated with an error */
    public static void printStackTrace(Throwable e)
    {	if(printer!=null) { printer.println(getStackTrace(e)); }
    	else { 	printStackTrace(e, System.out);}
    }
    static long last_time = -1;
    public static long time_offset = 0;
    static boolean time_changed = false;
    private static Object dateCheck = new Object();
    /**
     * get the current date.  This is synchronized so different threads can't see decreasing times
     * @return the current time in milliseconds, guaranteed to be monotonically increasing
     */
    // 
    static public long Date() 
    {	
    	synchronized (dateCheck)
    	{
    	long this_time = System.currentTimeMillis(); 
    	if(this_time<last_time)
    		{ time_changed=true; 
    		  time_offset += (last_time-this_time); 
    		}
    	last_time = this_time;
    	return(time_offset+this_time);
    	}
    }

   /**
    * return true if the clock has ever been set back.  Setting the clock back can be
    * a clever way to try to get extra time, or it can be an accident.
    * @return true if the time of day has unexpectedly changed
    */
   static public boolean isTimeCheat() 
   	{ synchronized (dateCheck)
   		{ boolean tc = time_changed;
   		  time_changed=false;
   		  return(tc); 
   		}
   	}

    /** draw a tooltip bubble with the pointer pointing to x,y, constrained
	 * to appear in rectangle R.  Text may be multiple lines separated by \n  The
	 * position of the pointer is adjusted appropriately if the x,y is too close
	 * to the edges of the rectangle.
	 * should be brief.
	 * @param inG	the graphics to draw
	 * @param x		the x of the focus of attention
	 * @param y		the y of the focus of attention
	 * @param msg   the text to be displayed
	 * @param r		the bounding rectangle
	 * @param rot	the rotation angle to display the box
	 */
	static public void drawBubble(Graphics inG, int x, int y, String msg, Rectangle r,double rotation)
	{ drawBubble(inG,x,y,TextChunk.split(msg),r,rotation);
	}
    /** draw a tooltip bubble with the pointer pointing to x,y, constrained
	 * to appear in rectangle R.  Text may be multiple lines separated by \n  The
	 * position of the pointer is adjusted appropriately if the x,y is too close
	 * to the edges of the rectangle.
	 * should be brief.
	 * @param inG	the graphics to draw
	 * @param x		the x of the focus of attention
	 * @param y		the y of the focus of attention
	 * @param msg   the text to be displayed
	 * @param r		the bounding rectangle
	 * @param rotation	the rotation angle to display the box
	 */
	static public void drawBubble(Graphics inG, int x, int y, Text msg, Rectangle r,double rotation)
	{ if(inG!=null)
	  {
	  int margin = 4;
	  int quarterTurns = rotationQuarterTurns(rotation);
	  FontMetrics myFM = getFontMetrics(inG);
	  int lineh = myFM.getHeight();
	  int tickHeight = lineh*2/3;
	  int neww = msg.width(myFM)+margin*2;
	  int newh = msg.height(myFM);
	  int textHeight = newh;
	  int boxHeight = textHeight + tickHeight+margin*2;
	  
	  int leftBound = G.Left(r)+lineh;
	  int topBound = G.Top(r)+lineh;
	  int rightBound = G.Right(r)-lineh;
	  int bottomBound = G.Bottom(r)-lineh;

	  boolean reverseY;
	  int left;
	  // position the left edge of the box so that no edge touches the boundary, considering
	  // the rotation. Normally the box is "above" the target point, but if the target gets
	  // too close to the top, flip it to appear under the target
	  switch(quarterTurns)
	  {	default:
	  	case 0: // normal not rotated
	  			left = Math.min(rightBound-20-neww,Math.max(leftBound+5,x-neww/2));
	  			reverseY = ((y-boxHeight)<=topBound);
	  			break;
	  	case 1: // 90 degrees clockwise
	  			left = x+Math.min(bottomBound-y-20-neww,Math.max(topBound-y+5,-neww/2));
	  			reverseY = x+boxHeight>=rightBound;
	  			break;
	  	case 2:	// 180 degrees
	  			left = x+Math.min(x-neww-leftBound,Math.max(x-rightBound,-neww/2));
	  			reverseY = y+boxHeight>=bottomBound;
	  			break;
	  	case 3:	// 90 degrees counterclockwise
	  			left = x+Math.max(y-bottomBound,Math.min(-neww/2,-neww+y-topBound));
	  			reverseY = (x-boxHeight)<=leftBound;
	  			break;
	  }
	  int ytop = reverseY ? y+tickHeight:y-boxHeight;	  
	  int rightmost = left+neww+10;
	  int lefttick = Math.min(rightmost-20,Math.max(left,x-10));
	  int centertick = lefttick+tickHeight/2;
	  int righttick = lefttick+tickHeight;
	  int ypoint = reverseY? y+5:ytop+boxHeight-5;
	  int ybottom = reverseY ?y+boxHeight:ytop+textHeight+3;
	  int near = reverseY?ytop:ybottom;
	  int far = reverseY?ybottom:ytop;
	  
	  Polygon poly = new Polygon();
	  poly.addPoint(centertick,ypoint);
	  poly.addPoint(lefttick,near);
	  poly.addPoint(left,near);
	  poly.addPoint(left,far);
	  poly.addPoint(rightmost,far);
	  poly.addPoint(rightmost,near);
	  poly.addPoint(righttick,near);
	  poly.addPoint(centertick,ypoint);
	  if(rotation!=0) { G.setRotation(inG, rotation, x,y); } 
	  setColor(inG,Color.black);
	  poly.fillPolygon(inG);
	  setColor(inG,Color.yellow);
	  poly.framePolygon(inG);
	  int l = left+margin;
	  int t = ytop;
	  int w = rightmost-l-margin;
	  int h = textHeight;
	  msg.draw(inG,msg.nLines()==1,l,t,w,h,Color.white,null,false);
	  if(rotation!=0) { G.setRotation(inG, -rotation, x,y); }
	}}
	
	
	/**
     * G.Assert returns true, or throws an Error.  This provides a
     *   convenient place to place a breakpoint for any kind of internally
     *   detected error.  This should be the only "throw ErrorX" in the system.
     *   @param condition a boolean that was evaluated in the caller's context
     *   @param message a message {@link #format} string
     *   @param args... optional args for the format string
     *   @return true, or throws an error. 
     */
    public static boolean Assert(boolean condition, String message,Object... args)
    {	if (!condition)
        {	if(args.length>0) { message = format(message,args); }
        	throw new ErrorX(message);
        }
        return (true);
    }
    /**
     * limited implementation of format, only %s %x and %d are handled,
     * with %0ns %0nx and %0nd  optional to specify field width
     * 
     * @param message
     * @param args
     * @return a String
     */
    public static String format(String message,Object...args)
    {	StringBuilder out = new StringBuilder();
    	int strIdx=0;
    	int lastStrIdx=message.length();
    	for(int lim=args.length,idx=0;
    				idx<lim;
    				)
    	{
    		Object arg = args[idx];
    		boolean decimal = false;
    		int nextStrIdx = message.indexOf('%',strIdx);
    		if(nextStrIdx>=0)
    		{	out.append(message.substring(strIdx,nextStrIdx));
    			int fieldWidth = 0;
    			char padchar = ' ';
    			char next = message.charAt(nextStrIdx+1);
    			
    			if(next=='0') { padchar='0'; }
    			while(next>='0' && next<='9')
				{
					fieldWidth = fieldWidth*10 + next-'0';
					nextStrIdx++;
					next = message.charAt(nextStrIdx+1);
				} ;

    			switch(next)
    			{
    			case '%':	
    				out.append('%');
    				nextStrIdx+=2;
    				break;
     			default:
      				out.append("(%");
      				out.append(next);
      				out.append(")");
    			case 'X':
    			case 'x':
    				{
    				Integer v = G.IntToken(""+arg);
    				String outp = Integer.toHexString(v);
    				int pad = fieldWidth-outp.length();
    				while(pad-- > 0) { out.append(padchar); }
    				if(fieldWidth>0 && fieldWidth<outp.length())
    					{
    					outp = outp.substring(0,Math.max(1,fieldWidth-3))+"..."; 
    					}
    				out.append(outp);
    				idx++;
    				nextStrIdx+=2;
    				}
    				break;
     			case 'd':
    			case 'D':
    				decimal = true;
    			case 's':
    			case 'S':
    			{
    				String outp = ""+arg;
    				int len = outp.length();
    				int pad = fieldWidth-len;
    				while(pad-- > 0) { out.append(padchar); }
    				if(fieldWidth>0)
    				{
    				if(decimal && fieldWidth<len) 
    					{
    						int ind = outp.indexOf('.');
    						if(ind<fieldWidth) { outp = outp.substring(0,fieldWidth); }
    						len = fieldWidth;
    					}
    				if(fieldWidth<len) { outp = outp.substring(0,Math.max(1,fieldWidth-3))+"..."; }
    				}
    				out.append(outp);
    				idx++;
    				nextStrIdx+=2;
    				break;
  				
    			}}
    			strIdx = nextStrIdx;
    					
    		}
    		else {
    			// ran out of string, still more args
    			if(strIdx<lastStrIdx) 
    			{ 
    				out.append(message.substring(strIdx));
    				strIdx = lastStrIdx;
    				
    			}
    			out.append(" + "+arg.toString());
    			idx++;
    		}
    	}
		if(strIdx<lastStrIdx) 
		{ 
			out.append(message.substring(strIdx));
			strIdx = lastStrIdx;
		}
		return(out.toString());
    }
    
    /**
     *  print a short interval time, minutes.seconds milliseconds
     * @param now
     * @return
     */
    public static String shortTime(long now)
    {
     	long ms = now%1000;
    	long seconds = now/1000;
    	long minutes = seconds/60;
    	return(G.format("%02d.%02d %03d",minutes%60,seconds%60,ms));
    }
    // tests for format
    //   public static void main(String args[])
    //   {
    //   	System.out.println(format("first and none"));
    //   	System.out.println(format("first and %% percent"));
    //   	System.out.println(format("first %s one","and"));
    //   	System.out.println(format("first and %d",1));
    //   	System.out.println(format("first and %s"));
    //   	System.out.println(format("first %x and extra","and","so on"));
    //   }
    /**
     * @param list
     * @param c
     * @param max
     * @return  true if the array contains the specified object
     */
    public static boolean arrayContains(Object list[],Object c,int max)
    {	for(int i=0;i<max;i++) { if(list[i]==c) { return(true); }}
    	return(false);
    }
    /**
      * @param list
     * @param c
     * @return true if the object contains the specified object.
     */
    public static boolean arrayContains(Object list[],Object c)
    {	return((list==null)?false : arrayContains(list,c,list.length));
    }
    /** this should be used for generic error conditions.  Error will be caught by event loops
     * and logged appropriately.
     *
     * @param msg
     */
    public static ErrorX Error(String msg,Object...args) 
    {	String message = msg;
    	if(args.length>0) { message = format(message,args); }
    	throw new ErrorX(message);
    }

   
/**
 * sleep a number of milliseconds
 * @param inDel
 */
    public static void doDelay(int inDel)
    {	if(isCodename1() && isEdt()) { G.Error("Can't sleep in edt"); }
        try
        {	// inDel is milliseconds
            Thread.sleep(inDel);
        }
        catch (InterruptedException e)
        {
        }
    }
    
    /** draw a text string, resized downward if necessary to fit the box.
     *
     * @param inG the graphics to draw
     * @param center if true, center the text
     * @param R a rectangle
     * @param color foreground color (or null)
     * @param bg background color (or null)
     * @param str the string to draw
     * @return the text width
     */
    static public int Text(Graphics inG, boolean center, Rectangle R,
        Color color, Color bg, String str)
    {
        return (Text(inG, center, Left(R), Top(R), Width(R), Height(R), color, bg, str));
    }
    /** draw a text string, resized downward if necessary to fit the box.
    *
    * @param inG the graphics to draw
    * @param rotation rotated angle for the text
    * @param center if true, center the text
    * @param R a rectangle
    * @param color foreground color (or null)
    * @param bg background color (or null)
    * @param str the string to draw
    * @return the text width
    */
    static public int Text(Graphics inG, double rotation,boolean center, Rectangle R,
            Color color, Color bg, String str)
        {	int cx = G.centerX(R);
        	int cy = G.centerY(R);
        	G.setRotation(inG, rotation, cx, cy);
            int v = Text(inG, center, Left(R), Top(R), Width(R), Height(R), color, bg, str);
            G.setRotation(inG,-rotation,cx, cy);
            return(v);
        }
    /**
     * draw a text string, resized downward if necessary to fit in the box
     * the string may be multiple lines separated by \n
     * @param inG
     * @param center
     * @param R
     * @param voff
     * @param color
     * @param bg
     * @param str
     * @return the text width
     */
    static public int Text(Graphics inG, boolean center, Rectangle R,int voff,
            Color color, Color bg, String str)
        {
            return (Text(inG, center, Left(R), Top(R)+voff, Width(R), Height(R), color, bg, str));
        }
    /**
     * draw a text string, resized downward if necessary to fit in the box
     * the string may be multiple lines separated by \n
     * @param inG
     * @param center
     * @param R
     * @param voff
     * @param color
     * @param bg
     * @param str
     * @return the text width
     */
    static public int Text(Graphics inG, boolean center, Rectangle R,int voff,
            Color color, Color bg, Text str)
        {
            return (Text(inG, center, Left(R), Top(R)+voff, Width(R), Height(R), color, bg, str));
        }  

    /** draw a text string, resized downward if necessary to fit the box.
     * the string may be multiple lines separated by \n
     * if width<0, center the text at xpos without resizing
     * if height=0, center the text at ypos
     *
     * @param inG the graphics to draw
     * @param center if true, center the text
     * @param inX x location of the left edge
     * @param inY y location of the upper-left corner
     * @param inWidth box width
     * @param inHeight box height
     * @param inColour foreground color (or null)
     * @param bgColor background color (or null)
     * @param inStr the string to draw
     * @return the text width
     */
    static public int Text(Graphics inG, boolean center, int inX, int inY,
        int inWidth, int inHeight, Color inColour, Color bgColor, String inStr)
    {  	return(TextChunk.split(inStr).draw(inG,center,inX,inY,inWidth,inHeight,inColour,bgColor));
    }
    /**
     * draw outlined text.  This is done by drawing the text multiple times using
     * the outline color, then finally using the specified main color.
     * 
     * @param gc the graphics
     * @param center if true, center in the box
     * @param ax the x for the box left
     * @param ay the y for the box top
     * @param inWidth box width
     * @param inHeight box height
     * @param inColour the main color for the text
     * @param outlineColor the outline color for the text
     * @param inStr the text to draw
     * @return the width of the text actually drawn
     */
    static public int drawOutlinedText(Graphics gc, boolean center, int ax, int ay,
            int inWidth, int inHeight, Color inColour, Color outlineColor, String inStr)
    {
    	Text(gc,center,ax-1,ay-1,inWidth,inHeight,outlineColor,null,inStr);
        Text(gc,center,ax+1,ay+1,inWidth,inHeight,outlineColor,null,inStr);
        Text(gc,center,ax+1,ay-1,inWidth,inHeight,outlineColor,null,inStr);
        Text(gc,center,ax-1,ay+1,inWidth,inHeight,outlineColor,null,inStr);
        return 2+Text(gc,center,ax,ay,inWidth,inHeight,inColour,null,inStr);
    }
    /** draw a text string, resized downward if necessary to fit the box.
     * the string may be multiple lines separated by \n
     * if width<0, center the text at xpos without resizing
     * if height=0, center the text at ypos
     *
     * @param inG the graphics to draw
     * @param center if true, center the text
     * @param inX x location of the left edge
     * @param inY y location of the upper-left corner
     * @param inWidth box width
     * @param inHeight box height
     * @param inColour foreground color (or null)
     * @param bgColor background color (or null)
     * @param inStr the string to draw
     * @return the text width
     */
    static public int Text(Graphics inG, boolean center, int inX, int inY,
            int inWidth, int inHeight, Color inColour, Color bgColor, Text inStr)
        {  return(inStr.draw(inG,center,inX,inY,inWidth,inHeight,inColour,bgColor));
        }   
    

    /**
     * split a  string into an array of substrings separated by ch, which is normally 
     * expected to be \n  Leading and trailing "ch" are deleted.
     * @param msg
     * @param ch
     * @return an array of strings
     */
    static public String[] split(String msg,char ch)
    {	return(split(msg,ch,0));
    }
    // recursive split depth first
    static private String[] split(String msg,char ch,int depth)
    {
    	int idx = msg.indexOf(ch);
    	if((idx <= 0) || (idx==msg.length()-1))
    		{ String res[] = new String[depth+1];
    		  res[depth] = (idx<=0) ? msg : msg.substring(0,idx);
    		  return(res);
    		}
    	else
    	{	String [] res = split(msg.substring(idx+1),ch,depth+1);
    		res[depth] = msg.substring(0,idx);
        	return(res);
    	}
    }

/**
 * get the maximum width of an array of strings.
 * @param m
 * @param myFM
 * @return an int
 */
    static public int maxWidth(String []m,FontMetrics myFM)
    {	int val = 0;
    	for(String vv : m) { val = Math.max(myFM.stringWidth(vv),val); }
    	return(val);
    }

    /** convert a long integer time string to our standard form for elapsed time
     *
     * @param inVal
     * @return a string representing GMT
     */
    static public String timeString(long inVal)
    {
        int hours = (int)(inVal / 3600000);
        int parthour = (int)(inVal%3600000);
        int minutes = (parthour / 60000);
        int seconds = (parthour - (minutes * 60000)) / 1000;
        return (concat((hours%24),":",((minutes < 10) ? "0" : ""),
        		minutes ,":", ((seconds < 10) ? "0" : "") , seconds));
    }
    /** convert a long integer time string to our standard form for extra time
    *
    * @param inVal
    * @return a string representing GMT
    */
   static public String briefTimeString(long inVal)
   {	String str = timeString(inVal);
   		int idx =0;
   		char ch;
   		char xch = ':';
   		while(((ch=str.charAt(idx))=='0')||(ch==xch)) { idx++; if(ch==xch){ xch='x'; }}
   		str = str.substring(idx); 
   		return(str);
   }
   

    /** print the elapsed time in a box
     *
     * @param gc
     * @param dest
     * @param timeString
     * @param foreground_color
     * @param table_color
     * @param standardBoldFont
     */
    static public void printTimeC(Graphics gc, Rectangle dest,
        String timeString, Color foreground_color, Color table_color, Font standardBoldFont)
    {
        int inXOffset = Left(dest);
        int inYOffset = Top(dest);
        int inW = Width(dest);
        int inH = Height(dest);

        Font old = getFont(gc);
        setFont(gc,standardBoldFont);
        Text(gc, false, inXOffset + 3, inYOffset, inW, inH, foreground_color,
            table_color, timeString);
        setFont(gc,old);
    }
    /**
     * 
     * @param g
     * @param left
     * @param top
     * @param width
     * @param height
     * @param rx
     * @param ry
     */
   static public void fillRoundRect(Graphics g,int left,int top,int width,int height,int rx,int ry)
   {
   	if(g!=null) { g.fillRoundRect(left,top,width,height,rx,ry); }
   }
   
   /**
    * 
    * @param g
    * @param left
    * @param top
    * @param width
    * @param height
    * @param rx
    * @param ry
    */
   static public void frameRoundRect(Graphics g,int left,int top,int width,int height,int rx,int ry)
   {
   	if(g!=null) { g.drawRoundRect(left,top,width,height,rx,ry); }
   } 
   
   /**
 * fill a rectangle with a rectangle
 * @param g a graphics object or null
 * @param r a rectangle
 */
    static public void fillRect(Graphics g, Rectangle r)
    {
        if(g!=null) { g.fillRect(Left(r), Top(r), Width(r), Height(r)); }
    }

    /** 
     * return the true distance between coordinates
     * @param x
     * @param y
     * @param x1
     * @param y1
     * @return the distance as a double
     */
    static public double distance(int x,int y,int x1,int y1)
    {  int dx = x - x1;
       int dy = y - y1;
       return(Math.sqrt((dx * dx) + (dy * dy)));
    }
    /** 
     * return the true distance between coordinates
     * @param x
     * @param y
     * @param x1
     * @param y1
     * @return the distance as a double
     */
    static public double distance(double x,double y,double x1,double y1)
    {  double dx = x - x1;
       double dy = y - y1;
       return(Math.sqrt((dx * dx) + (dy * dy)));
    }
    static private double intensity(int x, int y, double radius)
    {
        return (Math.sqrt(Math.min(1.0,
                0.6 * (radius - (Math.sqrt((x * x) + (y * y)))))));
    }
    
    static private void drawAASymline(Graphics inG, int fromX, int fromY,
        int centerX, int centerY, double radius, Color fore, Color back,
        boolean filled)
    {
        int br = back.getRed();
        int bg = back.getGreen();
        int bb = back.getBlue();
        int fr = fore.getRed();
        int fg = fore.getGreen();
        int fb = fore.getBlue();
        int dr = fr - br;
        int dg = fg - bg;
        int db = fb - bb;
        int x = -fromX;
        int y = -fromY;

        while (x <= 0)
        {
            double density = 1.0 - intensity(x, y, radius);
            int newr = Math.min(255, (int) (fr - (density * dr)));
            int newg = Math.min(255, (int) (fg - (density * dg)));
            int newb = Math.min(255, (int) (fb - (density * db)));
            setColor(inG,new Color(newr, newg, newb));
            frameRect(inG,centerX + x, centerY - fromY, 1, 1);
            frameRect(inG,centerX - x, centerY - fromY, 1, 1);
            frameRect(inG,centerX + x, centerY + fromY, 1, 1);
            frameRect(inG,centerX - x, centerY + fromY, 1, 1);

            if (density < 0.1)
            {
                break;
            }

            x++;
        }

        setColor(inG,fore);

        if (filled && (x < 0))
        {
            inG.drawRect(centerX + x, centerY - fromY, (x * -2) + 1, 1);
            inG.drawRect(centerX + x, centerY + fromY, (x * -2) + 1, 1);
        }
    }

    /** draw a circle with antialiased edges.
     *
     * @param inG
     * @param centerX duh
     * @param centerY duh
     * @param radius duh
     * @param fg main color for the circle
     * @param bg the color to blend with
     * @param filled true for a filled circle
     */
    static public void DrawAACircle(Graphics inG, int centerX, int centerY,
        int radius, Color fg, Color bg, boolean filled)
    {	if(inG!=null)
    	{
        int x;
        int y;
        int d;

        x = 0;
        y = radius;
        d = 1 - radius;

        while (y > x)
        {
            if (d < 0)
            { // Select E
                d += ((x * 2) + 3);
                x++;
            }
            else
            {
                d += (((x - y) * 2) + 5); // Select SE
                x++;
                y--;
            }

            drawAASymline(inG, x, y, centerX, centerY, radius + 0.55, fg, bg,
                filled);
            drawAASymline(inG, y, x, centerX, centerY, radius + 0.55, fg, bg,
                filled);
        }
    	}
    }
    
    // codename1 breaks when lots of calls to drawAAcircle are done
    // see issue #3388
    static private CachedObject<Image>circleCache = null;
    /** draw an anti aliased circle from a small cache.  Use this for small
     * decorator circles that are drawn many times the same size and color
     * @param g graphics object
     * @param x
     * @param y
     * @param radius
     * @param color
     * @param bgcolor
     * @param filled
     * @return
     */
    static public void cacheAACircle(Graphics g,int X,int Y,int radius,Color color,Color bgcolor,boolean filled)
    {	if(circleCache==null) { circleCache = new CachedObject<Image>(20); }
    	Image found = circleCache.find(radius,color,bgcolor,filled);
    	if(found == null)
    		{
        	Image im = Image.createTransparentImage(radius*2+4,radius*2+4);
        	Graphics gr = im.getGraphics();
        	G.DrawAACircle(gr,radius+2,radius+2,radius,color,bgcolor,filled);
        	circleCache.add(new CachedObject<Image>(im,radius,color,bgcolor,filled));
        	found = im;
    		}
    	G.drawImage(g,found,X-radius-2,Y-radius-2);    	
    }

    /**
     * draw a pseudo 3d rectangle in black white and gray
     * @param g
     * @param inX
     * @param inY
     * @param inW
     * @param inH
     */
    static public void Draw3DRect(Graphics g, int inX, int inY, int inW, int inH)
        {
    	Draw3DRect(g,inX,inY,inW,inH,Color.lightGray,Color.gray);
        }
    /**
     * draw a pseudo 3d rectangle in black white and foreground/background colors
     * @param g
     * @param inX
     * @param inY
     * @param inW
     * @param inH
     * @param background
     * @param foreground
     */
    static public void Draw3DRect(Graphics g, int inX, int inY, int inW, int inH,Color background,Color foreground)
    {
            setColor(g,background);
            fillRect(g,inX, inY, inW, inH);
            setColor(g,Color.black);
            frameRect(g,inX, inY, inW, inH);
            setColor(g,foreground);
            drawLine(g,inX + 1, (inY + inH) - 1, (inX + inW) - 1, (inY + inH) - 1);
            drawLine(g,inX + 2, (inY + inH) - 2, (inX + inW) - 1, (inY + inH) - 2);
            drawLine(g,(inX + inW) - 1, inY + 1, (inX + inW) - 1, (inY + inH) - 1);
            drawLine(g,(inX + inW) - 2, inY + 2, (inX + inW) - 2, (inY + inH) - 1);
            setColor(g,Color.white);
            drawLine(g,inX + 1, (inY + inH) - 1, inX + 1, inY + 1);
            drawLine(g,inX + 2, (inY + inH) - 2, inX + 2, inY + 2);
            drawLine(g,inX + 1, inY + 1, (inX + inW) - 1, inY + 1);
            drawLine(g,inX + 1, inY + 2, (inX + inW) - 2, inY + 2);
        }
    /**
     * draw a square button with black and white highlights.
     *
     **/	
    static public void drawButton(Graphics inG,Rectangle R,Color theColour)
    {
    	drawButton(inG,G.Left(R),G.Top(R),G.Width(R),G.Height(R),theColour);
    }
    /**
     * draw a square button with black and white highlights.
     * @param inG
     * @param theLeft
     * @param theTop
     * @param theWidth
     * @param theHeight
     * @param theColour
     */
    static public void drawButton(Graphics inG, int theLeft, int theTop, int theWidth, int theHeight, Color theColour)
    {
        setColor(inG,theColour);
        fillRect(inG,theLeft, theTop, theWidth, theHeight);
        setColor(inG,Color.white);
        drawLine(inG,theLeft + 1, theTop + 1, (theLeft + theWidth) - 1, theTop + 1);
        drawLine(inG,theLeft + 2, theTop + 2, (theLeft + theWidth) - 2, theTop + 2);
        drawLine(inG,theLeft + 1, theTop + 1, theLeft + 1, (theTop + theHeight) - 1);
        drawLine(inG,theLeft + 2, theTop + 2, theLeft + 2, (theTop + theHeight) - 2);
        setColor(inG,Color.gray);
        drawLine(inG,theLeft + 1, (theTop + theHeight) - 1,(theLeft + theWidth) - 1, (theTop + theHeight) - 1);
        drawLine(inG,theLeft + 2, (theTop + theHeight) - 2,(theLeft + theWidth) - 2, (theTop + theHeight) - 2);
        drawLine(inG,(theLeft + theWidth) - 1, theTop + 1, (theLeft + theWidth) - 1, (theTop + theHeight) - 1);
        drawLine(inG,(theLeft + theWidth) - 2, theTop + 2, (theLeft + theWidth) - 2, (theTop + theHeight) - 2);
        frameRect(inG,theLeft, theTop, theWidth, theHeight);
    }
    

        
/**
 * frame a rectangle with specified color
 * @param g a graphics object or null
 * @param c a color
 * @param left
 * @param top
 * @param w
 * @param h
 */
    static public void frameRect(Graphics g, Color c, int left, int top, int w,
        int h)
    {	
        setColor(g,c);
        frameRect(g,left, top, w-1 , h-1 );
    }
    /**
     * 
     * @param g
     * @param left
     * @param top
     * @param w
     * @param h
     */
    static public void frameRect(Graphics g, int left, int top, int w, int h)
        {	if(g!=null)
        	{
            g.drawRect(left, top, w , h );
        	}
        }
/**
 * frame a rectangle with a color
 * @param g a graphics or null
 * @param c a color
 * @param r
 */
    static public void frameRect(Graphics g, Color c, Rectangle r)
    {	
        setColor(g,c);
        frameRect(g,Left(r), Top(r), Width(r), Height(r));
    }
/**
 * @param x
 * @param y
 * @param left
 * @param top
 * @param w
 * @param h 
 * @return true if a point is inside a specified rectangle
 */
    static public boolean pointInRect(int x, int y, int left, int top, int w,
        int h)
    {
        return ((x >= left) && (y >= top) && (x < (left + w)) &&
        (y < (top + h)));
    }

     /**
      * return 
      * @param p
      * @param left
      * @param top
      * @param w
      * @param h
      * @return true if point is inside the rectangle
      */
    static public boolean pointInRect(Point p, int left, int top, int w, int h)
    {
        return ((p != null) && pointInRect(Left(p),Top(p), left, top, w, h));
    }
/**
 * @param p
 * @param r
 * @return true if the point is inside the rectangle
 */
    static public boolean pointInRect(Point p, Rectangle r)
    {
        return (pointInRect(p, Left(r), Top(r), Width(r), Height(r)));
    }
/**
 * @param x
 * @param y
 * @param r
 * @return true if the x,y is inside the rectangle
 */
    static public boolean pointInRect(int x, int y, Rectangle r)
    {
        return ((r!=null) && pointInRect(x, y, Left(r), Top(r), Width(r), Height(r)));
    }
    /**
     * modify my rectangle to align with the left edge of "other" and have the same size
     * @param my
     * @param top
     * @param other
     */
    public static void AlignLeft(Rectangle my,int top,Rectangle other)
    {
 	   SetRect(my,Left(other),top,Width(other),Height(other));
    }
    /**
     * align a rectangle at a different position but with the same
     * size as another rectangle
     * @param my
     * @param x
     * @param y
     * @param other
     */
    public static void AlignXY(Rectangle my,int x,int y,Rectangle other)
    {	SetRect(my,x,y,G.Width(other),G.Height(other));
    }
    
    /**
     * modify my rectangle to align with the top edge of "other" and have the same size.
     * @param my
     * @param left
     * @param other
     */
    public static void AlignTop(Rectangle my,int left,Rectangle other)
    {
 	   SetRect(my,left,Top(other),Width(other),Height(other));
    }


    /**
     * expand the rectangle bounds to include x,y 
     * @param r
     * @param newx
     * @param newy
     */
    public static void Add(Rectangle r,int newx, int newy) {
        if ((Width(r) | Height(r)) < 0) {
            SetRect(r,newx,newy,0,0);
            return;
        }
        int x1 = Left(r);
        int y1 = Top(r);
        int x2 = Width(r);
        int y2 = Height(r);
        x2 += x1;
        y2 += y1;
        if (x1 > newx) x1 = newx;
        if (y1 > newy) y1 = newy;
        if (x2 < newx) x2 = newx;
        if (y2 < newy) y2 = newy;
        x2 -= x1;
        y2 -= y1;
        if (x2 > Integer.MAX_VALUE) x2 = Integer.MAX_VALUE;
        if (y2 > Integer.MAX_VALUE) y2 = Integer.MAX_VALUE;
        SetRect(r,x1, y1,  x2, y2);
    }
 /**
  * make r the union of r and all the other rectangles
  * @param r
  * @param r2
  */
    public static void union(Rectangle r,Rectangle... rlist)
    {	for(Rectangle r2 : rlist)
    	{int w = G.Width(r2);
    	 int h = G.Height(r2);
    	 if((w>0) && (h>0))
    		 {int l = G.Left(r2);
    		  int t = G.Top(r2);
    		  Add(r,l,t);
    		  Add(r,l+w,t+h);
    		 }
    	}
    }
    /**
     * split the from rectangle into two, with destination rectangle at the right with the specified width
     * @param from
     * @param to
     * @param toWidth
     * @return the to rectangle
     */
    public static Rectangle splitRight(Rectangle from,Rectangle to,int toWidth)
    {
       	if(to==null) { to=new Rectangle(); }
       	int w = Width(from);
    	SetWidth(from,w-toWidth);
    	G.SetRect(to, Right(from), Top(from), toWidth, Height(from));
    	return(to);
    }
    /**
     * split the from rectangle into two, with the destination rectangle at the left with the specified width
     * @param from
     * @param to
     * @param toWidth
     * @return
     */
    public static Rectangle splitLeft(Rectangle from,Rectangle to,int toWidth)
    {
    	if(to==null) { to=new Rectangle(); }
    	int w = Width(from);
    	int fromLeft = Left(from);
    	SetWidth(from,w-toWidth);
    	SetRect(to,fromLeft, Top(from), toWidth, Height(from));
    	SetLeft(from,fromLeft+toWidth);
    	return(to);
    }
    
    /**
     * split the from rectangle into two, with destination rectangle below with the specified height
     * @param from
     * @param to
     * @param toHeight
     * @return the to rectangle
     */
    public static Rectangle splitBottom(Rectangle from,Rectangle to,int toHeight)
    {
    	if(to==null) { to=new Rectangle(); }
    	int h = Height(from);
    	SetHeight(from,h-toHeight);
    	G.SetRect(to, Left(from), G.Bottom(from), Width(from), toHeight);
    	return(to);
    }
    /**
     * split the from rectangle into two, with the destination rectangle at the top with the specified height
     * @param from
     * @param to
     * @param toHeight
     * @return the to rectangle
     */
    public static Rectangle splitTop(Rectangle from,Rectangle to,int toHeight)
    {
    	if(to==null) { to=new Rectangle(); }
    	int h = Height(from);
    	int fromTop = Top(from);
    	SetHeight(from,h-toHeight);
    	SetRect(to,Left(from),fromTop, Width(from),toHeight);
    	SetTop(from,fromTop+toHeight);
    	return(to);
    }
    public static void insetRect(Rectangle target,int n)
    {
    	G.SetRect(target,Left(target)+n, Top(target)+n,Width(target)-n*2,Height(target)-n*2);
    }
    
    /**
     * if the rectangle height is greater than width, return +- PI/2 
     * as the direction to rotate.
     * @param r
     * @return the direction to rotate
     */
    public static double autoRotate(Rectangle r)
    {
    	int w = Width(r);
    	int h = Height(r);
    	if(w<h)
    	{
    		return(((Left(r)>w/2) ? Math.PI : Math.PI)/2);
    	}
    	else { return(0); }
    }
    
 /**
 * handle a round button, draw a highlight if the mouse is over it. 
 * If width<height, text is rotated by pi/2 or -pi/2
 * @param gc
 * @param r
 * @param highlight
 * @param msg
 * @param HighlightColor
 * @param rackBackGroundColor
 * @return true of this button was hit
 */
    static public boolean handleRoundButton(Graphics gc, Rectangle r,
        HitPoint highlight, String msg, Color HighlightColor,
        Color rackBackGroundColor)
    {	return handleRoundButton(gc,0,r,highlight,TextChunk.create(msg),HighlightColor,rackBackGroundColor);
    }

    /**
     * 
     *  draw a button with text, light it up if it's over the mouse point "p"
     * if it is lighted, note it as the hitObject
     * If width<height, text is rotated by pi/2 or -pi/2
     *
    * @param inG
     * @param r
     * @param highlight
     * @param text
     * @param HighlightColor
     * @param BackgroundColor
     * @return true of this button was hit
     */
     static public boolean handleSquareButton(Graphics inG, Rectangle r,
        HitPoint highlight, String text, Color HighlightColor,  Color BackgroundColor)
    {
    	return(handleSquareButton(inG,0,r,highlight,TextChunk.create(text),HighlightColor,BackgroundColor));
    }
/**
 *  draw a button with text, light it up if it's over the mouse point "p"
 * if it is lighted, note it as the hitObject
 * 
 * @param inG
 * @param r
 * @param highlight
 * @param text
 * @param HighlightColor
 * @param BackgroundColor
 * @return true if the button was hit
 */
     static public boolean handleSquareButton(Graphics inG, Rectangle r,
    	        Point highlight, Text text, Color HighlightColor,  Color BackgroundColor)
     {
        boolean inbutton = (highlight != null) &&
            r.contains(Left(highlight), Top(highlight));

        if (inG != null)
        {
            G.drawButton(inG, r, inbutton ? HighlightColor : BackgroundColor);
            G.Text(inG, true, Left(r) + 2, Top(r) + 2, Width(r) - 4, Height(r) - 4,
                Color.black, null, text);
        }

        return (inbutton);
    }
/**
 * draw a button with text, light it up if it's over the mouse point "p"
 * if it is lighted, note it as the hitObject
 * @param inG
 * @param rotation
 * @param r
 * @param highlight
 * @param text
 * @param HighlightColor
 * @param BackgroundColor
 * @return true if the button was hit
 */
     static public boolean handleRoundButton(Graphics inG,double rotation,Rectangle r,
    		 HitPoint highlight, String text, Color HighlightColor, Color BackgroundColor)
     {
    	 return(handleRoundButton(inG,rotation,r,highlight,TextChunk.create(text),HighlightColor,BackgroundColor));
     }
/**
 *  * draw a button with text, light it up if it's over the mouse point "p"
 * if it is lighted, note it as the hitObject
 * @param inG
 * @param rotation
 * @param r
 * @param highlight
 * @param text
 * @param HighlightColor
 * @param BackgroundColor
 * @return true if the button was hit
 */
     static public boolean handleSquareButton(Graphics inG,double rotation,Rectangle r,
    		 HitPoint highlight, String text, Color HighlightColor, Color BackgroundColor)
     {
    	 return(handleSquareButton(inG,rotation,r,highlight,TextChunk.create(text),HighlightColor,BackgroundColor));
     }
     /**
      * draw a square button, rotating the rectangle and text
      * @param inG
      * @param rotation
      * @param r
      * @param highlight
      * @param text
      * @param HighlightColor
      * @param BackgroundColor
      * @return true if the button was hit
      */
     static public boolean handleSquareButton(Graphics inG,double rotation,Rectangle r,
    		 HitPoint highlight, Text text, Color HighlightColor, Color BackgroundColor)
     {	Rectangle cr = r ;
     	int cx = G.centerX(r);
		int cy = G.centerY(r);
		double rotation2 = rotation+autoRotate(r);
		if(rotation2!=0)
     		{
     		 G.setRotation(inG,rotation2, cx, cy);
     		 cr = G.copy(null,r);
     		 G.setRotation(cr,rotation2,cx,cy);
     		 G.setRotation(highlight, rotation2, cx, cy);
     		}
     	boolean v = handleSquareButton(inG,cr,highlight,text,HighlightColor,BackgroundColor);
     	if(rotation2!=0)
     		{ G.setRotation(inG, -rotation2, cx, cy); 
     		  G.setRotation(highlight, -rotation2, cx, cy);
     		} 
     	return(v);
     }
     /**
      * draw round edged button, rotating the rectangle and text
      *  
      * @param inG
      * @param rotation
      * @param r rectangle to display in
      * @param highlight the mouse location
      * @param text	the contents of the button
      * @param HighlightColor color for "mouse present"
      * @param BackgroundColor color for "mouse absent"
      * @return true of the button was hit
      */
     static public boolean handleRoundButton(Graphics inG,double rotation,Rectangle r,
    		 HitPoint highlight, Text text, Color HighlightColor, Color BackgroundColor)
     {	int cx = G.centerX(r);
     	int cy = G.centerY(r);
     	Rectangle cr = r;
     	double rotation2 = rotation + autoRotate(r);
     	if(rotation2!=0)
     	{
     		cr = G.copy(null,r);
     		G.setRotation(highlight,rotation2,cx,cy);
     		G.setRotation(cr,rotation2,cx,cy);
     		G.setRotation(inG,rotation2, cx, cy);
     	}
     	boolean v = handleRoundButton(inG,cr,highlight,text,HighlightColor,BackgroundColor);
     	if(rotation2!=0) 
     		{ G.setRotation(inG, -rotation2, cx, cy);   
     		  G.setRotation(highlight,-rotation2,cx,cy);
     		}
     	return(v);
     }
     /**
      * draw round edged button, text as specified
      * @param gc
      * @param r rectangle to display in
      * @param highlight the mouse location
      * @param text	the contents of the button
      * @param HighlightColor color for "mouse present"
      * @param BackgroundColor color for "mouse absent"
      * @return true of the button was hit
      */
     static public boolean handleRoundButton(Graphics gc,Rectangle r,
    		 Point highlight, Text text, Color HighlightColor, Color BackgroundColor)
     {
         boolean inbutton = (highlight != null) && r.contains(Left(highlight), Top(highlight));

         if (gc != null)
	        {	Color cl = inbutton ? HighlightColor : BackgroundColor;
	        	int bevel = Height(r)/4;

	           if(cl!=null)
	            	{setColor(gc,cl);
	            	 gc.fillRoundRect(Left(r), Top(r), Width(r)-1, Height(r)-1, bevel, bevel);
	            	}
	            setColor(gc,Color.black);
	            gc.drawRoundRect(Left(r),Top(r),Width(r)-1,Height(r)-1,bevel,bevel);
	            G.Text(gc, true, Left(r)+1, Top(r)+1, Width(r)-2, Height(r)-2, Color.black, null, text);
	        }

         return (inbutton);
     }
     
     /**
      * @param x
      * @param y
      * @param x2
      * @param y2
      * @return the distance squared
      */
    static final public int distanceSQ(int x,int y,int x2,int y2)
    {   int dx = x - x2;
    	int dy = y - y2;
    	return((dx * dx) + (dy * dy));
    }

    /**
     * 
     * @param loc
     * @param x
     * @param y
     * @param rad
     * @return true if point inside a circle 
     */
     static public boolean pointInside(Point loc, int x, int y, int rad)
    {
        return ((loc != null) && (distanceSQ(x, y, Left(loc), Top(loc)) < rad*rad));
    }
     /**
      * 
      * @param loc
      * @param x
      * @param y
      * @param rad
      * @return true if point inside a square
      */
     static public boolean pointInsideSquare(Point loc, int x, int y, int rad)
    {	if(loc!=null)
		{
    	int px = Left(loc);
		int py = Top(loc);
        return ( (x>=px-rad)
        		&& (y>=py-rad)
        		&& (x<px+rad)
        		&& (y<py+rad));
		}
    	return(false);
    }
     /**
      * point inside a square area, wid and hgt are radii from the center specified by centerX,centerY
      * @param loc
      * @param centerX
      * @param centerY
      * @param wid
      * @param hgt
      * @return true if the point is inside the specified rectangle
      */
     static public boolean pointNearCenter(Point loc, int centerX, int centerY, int wid,int hgt)
    {	return ((loc != null) 
        		&& (centerX>=Left(loc)-wid)
        		&& (centerY>=Top(loc)-hgt)
        		&& (centerX<Left(loc)+wid)
        		&& (centerY<Top(loc)+hgt));

    }

     /**
      * point inside a rectangle
      * @param loc
      * @param r
      * @return true if the point is inside the specified rectangle
      */
     static public boolean pointInsideRectangle(Point loc, Rectangle r)
    {	int w = (Width(r)+1)/2;
    	int h = (Height(r)+1)/2;
        return (pointNearCenter(loc,Left(r)+w,Top(r)+h,w,h));
    }
     
/**
 * draw a blob with a contrasting center color, used for mouse position
 * @param g
 * @param X
 * @param Y
 * @param inCol
 * @param cCol
 */
    static public void drawLargeSpot(Graphics g, int X, int Y, Color inCol,
        Color cCol,int size)
    {	int sz2 = size/2;
    	int sz4 = size/4;
    	int sz8 = size/8;
        setColor(g,inCol);
        fillOval(g,X - sz2, Y - sz2, size,size);

        setColor(g,cCol);
        fillOval(g,X - sz8, Y - sz8, sz4, sz4);
    }


/**
 * remove quotes from a string that might have been gratuitously quoted.
 * @param str
 * @return a string
 */
    static public String trimQuotes(String str)
    {
        int end = str.length() - 1;

        if ((str.length() >= 2) && (str.charAt(0) == '\"') &&
                (str.charAt(end) == '\"'))
        {
            str = str.substring(1, end);
        }

        return (str);
    }
    /** assure that a string IS quoted with explicit quotes */
    static public String quote(String str)
    {
    	return("\""+trimQuotes(str)+"\"");
    }
    /** capitalize the string */
    static public String Capitalize(String str)
    {
    	return(str.substring(0,1).toUpperCase()+str.substring(1).toLowerCase());
    }
    static public String nextToken(StringTokenizer s)
    {	String str;
    	do { str = s.nextToken(); } while(" ".equals(str));
    	return(str);
    }
    
    /**
     * collect the rest of the tokens in a StringTokenizer into a string.  Returns "" if there
     * are no tokens remaining.
     * @param s
     * @return a String
     */
     public static String restof(StringTokenizer s)
    {	StringBuffer empty = null;
        while (s.hasMoreTokens())
        {   if(empty==null) { empty = new StringBuffer(); } else { empty.append(" "); }
        	empty.append(nextToken(s));
        }
        return((empty==null)?"":empty.toString());
    }
     /**
      * convert a string into an double.
      * @param msg
      * @return an integer
      */
         static public double DoubleToken(String msg)
         {
             return (Double.parseDouble(msg));
         }
     /** 
      * convert the next token into an double
      * @param msg
      * @return an integer
      */
         static public double DoubleToken(StringTokenizer msg)
         {
             return (DoubleToken(nextToken(msg)));
         }
/**
 * convert a string into an integer.
 * @param msg
 * @return an integer
 */
    static public int IntToken(String msg)
    {	// accept decimal point after a number
    	return (Integer.parseInt(msg.endsWith(".") ? msg.substring(0, msg.length()-1) : msg,10));
    }
/** 
 * convert the next token into an integer
 * @param msg
 * @return an integer
 */
    static public int IntToken(StringTokenizer msg)
    {
        return (IntToken(nextToken(msg)));
    }
/**
 * convert the next token into a char
 * @param msg
 * @return a char
 */
    static public char CharToken(StringTokenizer msg)
    {
        return (nextToken(msg).charAt(0));
    }

    /**
     * convert the next token into a boolean
     * @param msg
     * @return a boolean
     */
    static public boolean BoolToken(StringTokenizer msg)
    {	return(Boolean.parseBoolean(nextToken(msg)));
    }
    
    /**
     * 
     * @param msg
     * @return true or false
     */
    static public boolean BoolToken(String msg)
    {
    	return(Boolean.parseBoolean(msg));
    }
    /**
     * convert the next token into a long
     * @param s
     * @return a long int
     */
    public static final long LongToken(StringTokenizer s)
    {
        return (Long.parseLong(nextToken(s),10));
    }

    /**
     * convert the string into a long
     * @param s
     * @return a long int
     */
     public static final long LongToken(String s)
    {
    	return (Long.parseLong(s,10));
    }
    /** draw an animated circle with an arrow, to indicate life in the connection
     * @param gc the graphics object
     * @param dest the destination rectangle
     * @param last the tick value for time of this display
     * @param progress step counter, which becomes the angle of display arrow
     */

   public static void draw_anim(Graphics gc,Rectangle dest,int size0,long last,int progress)
    {
        int inXOffset = G.centerX(dest);
        int inYOffset = G.centerY(dest);
        long now = G.Date();
        int size = size0&~1;		// make size even
        if (last == 0)
        {
            last = now;
        }

        float dif = (float) Math.min(1.0, (now - last) / (1000 * 60.0));

        if (dif >= 0.0f)
        {
            int anim_y = inYOffset;
            int anim_x = inXOffset;
            int sz2 = size/2;
            double pos = ((-2 * Math.PI) / 16) * (progress % 16);
            double angx = Math.sin(pos);
            double angy = Math.cos(pos);
            
            G.setColor(gc,Color.blue);
            Color newColor = new Color(dif, (float) Math.min(1.0, 2.0f - (2 * dif)),0.0f);
            G.setColor(gc,newColor);
            G.fillOval(gc,anim_x - sz2, anim_y -sz2, size,size);
            G.setColor(gc,Color.black);
            G.frameOval(gc,anim_x - sz2, anim_y -sz2, size,size);
            int dx = (int)Math.round((sz2+2) * angx);
            int dy = (int)Math.round((sz2+2) * angy);
            G.drawLine(gc,anim_x-dx,anim_y-dy,
                anim_x + dx, 
                anim_y + dy);
       }
    } 
   /**
    * draw a polygon with a border and fill, and with text drawing in the center
    * 
    * @param inG
    * @param inX
    * @param inY
    * @param inPoly
    * @param fillColour
    * @param trimColour
    * @param inText
    * @param textColour
    */
	public static void myDrawPolygon(Graphics inG, int inX, int inY, Polygon inPoly, Color fillColour, Color trimColour, String inText, Color textColour) 
	{
	    G.translate(inG,inX,inY);
	    setColor(inG,fillColour);
	    inPoly.fillPolygon(inG);
	    setColor(inG,trimColour);
	    inPoly.framePolygon(inG);
	    if (inText != null) {
	       Rectangle b = inPoly.getBounds();
	       int w = G.Width(b) - 4;
	       Text(inG,true,-w/2,-G.Height(b)/2,w,G.Height(b),textColour,null,inText);
	    }
	    G.translate(inG,-inX,-inY);
	  }
    /** call this to pre-composite two rgb images loaded from source files.
     * @param im the foreground image to be composited
     * @param mask the mask (with black for parts to keep from the foreground)
     *
     * @return the composited image
     */
    public static Image compositeSelf(Image im, Image mask)
    {	Image newIm = new Image(im.getName());
    	newIm.compositeSelf(mask,0,im,0);
    	return(newIm);
    }
    /**
     * composite a color with a component of a mask, resulting in a new image
     * This allows 3 masks to be packed into one image.
     * to be concealed in one mask image.
     * @param mask
     * @param shift
     * @param bgcolor
     * @return an Image
     */
    public static Image compositeComponent(Image mask,int shift,int bgcolor)
    {	Image newIm = new Image(mask.getName());
    	newIm.compositeSelf(mask,shift,null,bgcolor);
    	return(newIm);
    }

    /**
    * composite each of the masks against a background color, using {@link G#compositeComponent compositeComponent}
     * @param masks an array of mask images
     * @param shift selects the component of the mask to be composited
     * @param bgcolor the color to composite with
    * @return and array of new images
    */
    public static Image[] CompositeMasks(Image []masks,int shift,int bgcolor)
        {	Image res[]=new Image[masks.length];
        	for(int i=0;i<res.length;i++)
        	{	res[i]=G.compositeComponent(masks[i],shift,bgcolor);
        	}
        	return(res);
        }

    /** Cheap pseudo random, intended to jitter the position
     * of stones a little.  Returned as -m/2 to m/2
     * @param x
     * @param y
     * @param m
     * @return the value
     */
    public static int CPR(int x,int y,int m)
    {	//x*prime1+y*prime2 mod prime3
    	return(((x*9803+y*10211)%9679)%Math.max(1,m)-m/2);
    }
    
    private static final boolean HARDWAY = true;
	/** combine the current clipping rectangle with a new left-top-w-h.  This
	 * should be used to clip to a subrectangle of the current master rectangle
	 * @param gc	the current gc or null
	 * @param left
	 * @param top
	 * @param w
	 * @param h
	 * @return the original clipping rectangle, or null
	 */
    public static Rectangle combinedClip(Graphics gc,int left,int top,int w,int h)
    {	Rectangle r =null;
    	if(gc!=null)
    		{ 
    		r = getClipBounds(gc);
    		if(HARDWAY)
    		{	
    			if(r!=null)
		    	{
    			int lr = Left(r);
    			int tr = Top(r);
    			if(left<lr) { w = Math.max(0,w+(left-lr)); left = lr; }
	    		if(top<tr) { h = Math.max(0,h+(top-tr)); top = tr; }
	    		int rr = Right(r);
	    		int br = Bottom(r);
	    		if((left+w)>rr) { w = rr-left; }
	    		if((top+h)>br) { h = br-top; }
		    	}
    			// ios behaves badly with negative width or height
       			gc.setClip(left,top,Math.max(0, w),Math.max(0, h));
    			
     		}
    		else
    		{
    		// ios behaves badly with negative width or height
	    	gc.clipRect(left,top,Math.max(0, w),Math.max(0, h));	// clip bounds are to the included pixel
    		}
    		}
    	return(r);
    }
    /**
     * combine the current clipping rectangle with the new one. This
	 * should be used to clip to a sub rectangle of the current master rectangle
	 * @param gc	the current gc or null
     * @param r
     * @return the original clipping rectangle, or null
     */
    public static Rectangle combinedClip(Graphics gc,Rectangle r)
    {
    	return(combinedClip(gc,G.Left(r),G.Top(r),G.Width(r),G.Height(r)));
    }
    public static Rectangle setClip(Graphics gc,int left,int top,int w,int h)
    {	Rectangle r = getClipBounds(gc);
    	// IOS behaves badly with negative width or height
    	if(gc!=null) { gc.setClip(left,top,Math.max(0, w),Math.max(0, h)); }
    	return(r);
    }
    /**
     * @param c1
    * @param c2
    * @return true if two integer arrays contain the same integers
    */
   static public boolean sameArrayContents(int c1[],int c2[])
	{	int len = c1.length;
		if(len==c2.length)
		{	for(int i=0;i<len;i++) { if(c1[i]!=c2[i]) { return(false); }}
			return(true);
		}
		return(false);
	}
   /**
    * @param c1
   * @param c2
   * @return true if two integer arrays contain the same integers
   */
  static public boolean sameArrayContents(long c1[],long c2[])
	{	int len = c1.length;
		if(len==c2.length)
		{	for(int i=0;i<len;i++) { if(c1[i]!=c2[i]) { return(false); }}
			return(true);
		}
		return(false);
	}
   /**
    * @param c1
   * @param c2
   * @return true if two byte arrays contain the same integers
   */
  static public boolean sameArrayContents(byte c1[],byte c2[])
	{	int len = c1.length;
		if(len==c2.length)
		{	for(int i=0;i<len;i++) { if(c1[i]!=c2[i]) { return(false); }}
			return(true);
		}
		return(false);
	}
   /**
    * @param c1
    * @param c2
    * @return true if two boolean arrays contain the same sequence of booleans
    */
   static public boolean sameArrayContents(boolean c1[],boolean c2[])
	{	int len = c1.length;
		if(len==c2.length)
		{	for(int i=0;i<len;i++) { if(c1[i]!=c2[i]) { return(false); }}
			return(true);
		}
		return(false);
	}
   static public boolean sameArrayContents(char c1[],char c2[])
	{	int len = c1.length;
		if(len==c2.length)
		{	for(int i=0;i<len;i++) { if(c1[i]!=c2[i]) { return(false); }}
			return(true);
		}
		return(false);
	}
   
   static public boolean sameArrayContents(double c1[],double c2[])
	{	int len = c1.length;
		if(len==c2.length)
		{	for(int i=0;i<len;i++) 
				{ if(c1[i]!=c2[i])
					{ return(false); 
					}
				}
			return(true);
		}
		return(false);
	}
   /**
    * @param c1
    * @param c2
    * @return true if two boolean arrays contain the same sequence of Objects
    */
   static public boolean sameArrayContents(Object c1[],Object c2[])
	{	int len = c1.length;
		if(len==c2.length)
		{	for(int i=0;i<len;i++) { if(c1[i]!=c2[i]) { return(false); }}
			return(true);
		}
		return(false);
	}
   /**
    * copy the contents of one integer array into another.  If the
    * destination is null, create a copy of the source.
    * @param c1 the destination array
    * @param c2 the source array
    * @return c1 or the new array
    */
   static public int[] copy(int c1[],int c2[])
   {	if(c2!=null)
	    {int len = c2.length;
	     if(c1==null) { c1 = new int[len]; }
	     else { G.Assert(len==c1.length,"same length"); }
   	     for(int i=0;i<len;i++) { c1[i]=c2[i]; }
	    }
   		return(c1);
   }
   /**
    * copy the contents of one integer array into another, if the destination
    * is null, create a copy of the source.
    * @param c1 the destination array
    * @param c2 the source array
    * @return c1 or the new array
    */
   static public long[] copy(long c1[],long c2[])
   {	if(c2!=null)
	    {int len = c2.length;
	    if(c1==null) { c1 = new long[len]; }
	    else { G.Assert(len==c1.length,"same length");}
   	    for(int i=0;i<len;i++) { c1[i]=c2[i]; }
	    }
   	return(c1);
   }
   
   /**
    * copy the contents of one double array into another, if the 
    * destination is null, create a copy of the source.
    * @param c1 the destination array
    * @param c2 the source array
    * @return c1 or the new array
    */
   static public double[] copy(double c1[],double c2[])
   {	if(c2!=null)
	    {int len = c2.length;
	     if(c1==null) { c1 = new double[len]; }
	     else { G.Assert(len==c1.length,"same length"); }
   	     for(int i=0;i<len;i++) { c1[i]=c2[i]; }
	    }
   		return(c1);
   }
   
   /**
    * copy the contents of one integer array into another
    * @param c1 the destination array
    * @param c2 the source array
    */
   static public char[] copy(char c1[],char c2[])
   {	if(c2!=null)
	   	{ int len = c2.length;
	   	if(c1==null) { c1 = new char[len]; }
	   	else { G.Assert(len==c1.length,"same length"); }
   	    for(int i=0;i<len;i++) { c1[i]=c2[i]; }
	   	}
   		return(c1);
   }
   /**
    * copy the contents of one array of objects to another
    * @param c1 the destination array
    * @param c2 the source array
    */
   static public void copy(Object c1[],Object c2[])
   {	int len = c1.length;
   		G.Assert(len==c2.length,"same length");
   	    for(int i=0;i<len;i++) 
   	    { Object s = c2[i];
   	      // limits to java type system.  Object[][] gets here too, and end up copying
   	      // the structure.  Trying to cast Object[][] to Object[] fails because arrays
   	      // are not the type of their contents.  The best we can do is scream.
   	      Assert(s==null || !s.getClass().isArray(),"can't be an array[][]");
   	      c1[i]=c2[i]; 
   	    }
   }
   /**
    * copy an array of arrays of integers
    * @param c1
    * @param c2
    */
   static public void copy(int [][]c1,int [][]c2)
   {
	   int len = c1.length;
	   G.Assert(len==c2.length,"same length");
	   for(int i=0;i<len;i++) { copy(c1[i],c2[i]); }
   }
   /**
    * create a copy of an integer array
    * @param c1
    * @return a new array
    */
   static public int[]copy(int c1[])
   {	int val[] = null;
	    if(c1!=null)
	    {
	    	val = new int[c1.length];
	    	copy(val,c1);
	    }
	    return(val);
   }
   /**
    * create a copy of an double array
    * @param c1
    * @return a new array
    */
   static public double []copy(double c1[])
   {	double val[] = null;
	    if(c1!=null)
	    {
	    	val = new double[c1.length];
	    	copy(val,c1);
	    }
	    return(val);
   }
   /**
    * copy a rectangle. to can be null, 
    * @param to
    * @param from
    * @returns the to rectangle
    */
   static public Rectangle copy(Rectangle to,Rectangle from)
   {  if(to==null) { to = new Rectangle(); }
	  SetRect(to,Left(from),Top(from),Width(from),Height(from));
	  return(to);
   }
   /**
    * set each cell of a boolean array to a fixed value
    */
   static public void setValue(boolean c1[],boolean v)
   {
	   for(int lim=c1.length-1; lim>=0; lim--) { c1[lim]=v; }
   }
   /**
    * set each cell of an array to a fixed value
    */
   static public void setValue(int c1[],int v)
   {
	   for(int lim=c1.length-1; lim>=0; lim--) { c1[lim]=v; }
   }
   /**
    * set each cell of an array to a fixed value
    */
   static public void setValue(Object c1[],Object v)
   {
	   for(int lim=c1.length-1; lim>=0; lim--) { c1[lim]=v; }	   
   }
   static public void setValue(Object c1[][],Object v)
   {
	   for(Object cv[] : c1) { setValue(cv,v); }	   
   }

   /**
    * set each cell of an array to a fixed value
    * @param speed
    * @param d
    */
   public static void setValue(double[] speed, double d) {
		for(int lim=speed.length-1; lim>=0; lim--) { speed[lim] = d; }
	}
   /**
    * copy the contents of one boolean array into another
    * @param c1 the destination array
    * @param c2 the source array
    */
   static public void copy(boolean c1[],boolean c2[])
   {	int len = c1.length;
   		G.Assert(len==c2.length,"same length");
   	    for(int i=0;i<len;i++) { c1[i]=c2[i]; }
   }

   static public void drawLine(Graphics gc,int xpos,int ypos,int nxpos,int nypos)
   {
	   if(gc!=null) { gc.drawLine(xpos,ypos,nxpos,nypos); }
   }
   /**
    * utility to allocate an array length n containing integers 0-n-1
    * @param n
    * @return an array of integers
    */
   static public int[]intArray(int n)
   {
	   int ar[] = new int[n];
	   for(int i=0;i<n;i++) { ar[i]=i; }
	   return(ar);
   }
    /**
     * interpolate a fraction 0-1 between two values
     * @param frac
     * @param from
     * @param to
     * @return a double interpolated from from to to
     */
    static public double interpolateD(double frac,double from,double to)
    {	return((from+(to-from)*frac));
    }
/**
 * interpolate a fraction 0-1.0 between two values
 * @param frac
 * @param from
 * @param to
 * @return an integer interpolated from from to to
 */
    static public int interpolate(double frac,int from,int to)
    {	
    return((int)(from+(to-from)*frac));}
    

    
    /**
     * small integer factorial
     * @param a
     * @return the factorial, accurately if it's an integer
     */
	 public static int factorial(int a) { return((a==0)?1:a*factorial(a-1)); }
	 /**
	  * small integer binomial coeffecient
	  * @param n
	  * @param k
	  * @return the factorial
	  */
	 public static int binomialCoefficient(int n, int k) {
	      return (factorial(n)) / (factorial(k) * factorial((n - k)));
	   }
	 /** small integer permutatons 
	  * @param n
	  * @param k
	  * @return the number of permutations
	  */
	 public static int permutations(int n, int k) {
	      return (factorial(n)) /  factorial((n - k));
	   }
	 

/* base64 encoding based on a stackOverflow post */
	 


    /**
     * convert an array of ImageNameProvider to the names.  This is used
     * to create the list of images from an enum
     * 
     */
    static public String[] getNames(NameProvider[]a)
    {
    	String res[] = new String[a.length];
    	for(int lim=a.length-1; lim>=0; lim--) { res[lim]=a[lim].getName(); }
    	return(res);
    }
    
    @SuppressWarnings("deprecation")
	private static InspectorInterface getInspector()
    {
    	try { 
    		return((InspectorInterface)(Class.forName(InspectorInterface.InspectorClass).newInstance())); 
    		}
    	catch (Throwable err) { throw new ErrorX(err); }
    }
    /** invoke an inspector for some object */
    public static void inspect(Object o)
    {
    	getInspector().view(o);
    }
    /** invoke an inspector for some object, and suspend the current thread */
    public static void inspectWait(Object o)
    {
    	getInspector().viewWait(o);
    }
    
	
	public static Rectangle clone(Rectangle r)
	{
		return(new Rectangle(Left(r),Top(r),Width(r),Height(r)));
	}

	/**
	 * use this when comparing string for EQ to avoid complaints from bug finder
	 * 
	 * @param a
	 * @param b
	 * @return true if a and b are the same object
	 */
	public static boolean eq(Object a,Object b) { return(a==b); }

	/**
	 * 
	 * @param x
	 * @return +1 -1 or 0 depending on x
	 */
	public static int signum(int x) { return(x>0 ? 1 : x<0 ? -1 : 0); }
	public static int signum(double x) { return(x>0 ? 1 : x<0 ? -1 : 0); }

/**
 * 
 * @param ch
 * @return true if this char is a letter or a digit
 */
	public static boolean isLetterOrDigit(char ch)
	{
		return(Character.isUpperCase(ch) || Character.isLowerCase(ch) || Character.isDigit(ch));
	}

	static public void Rotate(int[]ipix,int []opix,int w,int h,double angle,int fillColor)
	{
	     double sina = Math.sin(angle);
	     double cosa = Math.cos(angle);
	     int h1 = h-1;
	     int w1 = w-1;
	     for(int dx=0,centerx=w/2;dx<w;dx++) 
	     	{ for(int dy=0,centery=h/2;dy<h;dy++) 
	     	{
	      	 int sidxx = (int)(cosa*(dx-centerx)-sina*(dy-centery))+centerx;
	    	 int sidyy = (int)(sina*(dx-centerx)+cosa*(dy-centery))+centery;
	    	 // consider the actual border pixel to be absent, and use the fill color instead
	    	 // this avoids messy edges from jpegs or scaled images.
	    	 boolean inbounds = (sidxx>0) && (sidxx<w1) && (sidyy>0) && (sidyy<h1);
	     	 opix[dx+w*dy] = inbounds
	     	 	? ipix[sidxx+sidyy*w] 
	     	    : fillColor;  	// outside value of black/transparent
	      }}
	}
	/**
	 * standardize font sizes based on the screen dots per inch.  Literal
	 * sizes in the code are are for a 96 dpi screen, where 12 point is a good
	 * default.  On retina screens that has to be increased a lot.
	 * @param sz
	 * @return the adjusted font size
	 */
	public static int standardizeFontSize(double sz)
	{	
		return((int)(getDisplayScale()*sz));
	}
	
	public static int standardDisplayDensity()
	{
		if(isAndroid()) { return(160); }
		return(96);
	}

	/**
	 * get the standard scale factor to the nominal 96ppi display
	 * @return a double
	 */
    public static double getDisplayScale()
    {	int ppi = getPPI();
    	int sdd = standardDisplayDensity();
    	double sc = Math.max(1, dpiMultiplier*ppi/sdd);
    	return(sc);
    }
    public static double dpiMultiplier = 1.0;
	/**
	 * returns the number of trailing zeros in an integer
	 * @param i
	 * @return an int
	 */
	// cribbed from Integer
    public static int numberOfTrailingZeros(int i) {
        // HD, Figure 5-14
        int y;
        if (i == 0) return 32;
        int n = 31;
        y = i <<16; if (y != 0) { n = n -16; i = y; }
        y = i << 8; if (y != 0) { n = n - 8; i = y; }
        y = i << 4; if (y != 0) { n = n - 4; i = y; }
        y = i << 2; if (y != 0) { n = n - 2; i = y; }
        return n - ((i << 1) >>> 31);
    }
    /** number of trailing zeros of a long */
    public static int numberOfTrailingZeros(long i) {
        // HD, Figure 5-14
        int x, y;
        if (i == 0) return 64;
        int n = 63;
        y = (int)i; if (y != 0) { n = n -32; x = y; } else x = (int)(i>>>32);
        y = x <<16; if (y != 0) { n = n -16; x = y; }
        y = x << 8; if (y != 0) { n = n - 8; x = y; }
        y = x << 4; if (y != 0) { n = n - 4; x = y; }
        y = x << 2; if (y != 0) { n = n - 2; x = y; }
        return n - ((x << 1) >>> 31);
    }
    

	public static final String Ios = "Ios";
	public static final String Android = "Android";
	static public String getOS() { 
	String prop = System.getProperty(G.OS_NAME);
	if(prop==null || isCodename1()) { prop=getPlatformName(); }
	return(prop); 
	}
	static public boolean isAndroid() { return(getOS().equals(Android)); }
	static public boolean isUnix()
	{	String osName = getOS().toLowerCase();
		return ((osName.indexOf("solaris") != -1) ||
	               (osName.indexOf("sunos") != -1) ||
	               (osName.indexOf("nux") != -1) || 
	               (osName.indexOf("nix") != -1));
	}
	static public boolean isIOS()
		{ boolean val = getOS().equals(Ios);
		  return(val);
		}
	
	
	public static boolean isResourceName(String name,boolean doc)
	    {	String lcname =  name.toLowerCase();
	    	return(!(doc 
	    			|| lcname.startsWith("http:") 
	    			|| lcname.startsWith("https:") 
	    			|| lcname.startsWith("file:")));
	    }

	//
	// present a messagebox
	//
	public static void infoBox(String caption,String infoMessage)
	{	G.print(caption+":"+infoMessage);
	    JOptionPane.showMessageDialog(null, infoMessage, caption, JOptionPane.INFORMATION_MESSAGE);
	}
	
	public static String optionBox(String caption, String infoMessage, String... options)
	{
		int n = JOptionPane.showOptionDialog(null,infoMessage,caption,
				  JOptionPane.INFORMATION_MESSAGE,
				  JOptionPane.INFORMATION_MESSAGE,
				  null,
				  options,
				  options[0]
				 );
		return( (n>0&&n<options.length) ? options[n] : null);
	}
	// if no canvas, put a wait loop in here.
    public static void waitAWhile(Object client,long millis)
    {
    	if(millis>=0)
    	{synchronized(client) {
	        try
	        {	
	        client.wait(millis);
	        }
	        catch (InterruptedException e)  { // pro forma catch
	        		}
	        }
    	}
    }
    public static void wake(Object client)
    	{ 
    	  if(client!=null) 
    		{ 	
    			synchronized(client) 
    			{ 
    			  client.notifyAll(); 
    			}
    		} 
    	}
    

/**
    * Returns the number of zero bits preceding the highest-order
    * ("leftmost") one-bit in the two's complement binary representation
    * of the specified {@code long} value.  Returns 64 if the
    * specified value has no one-bits in its two's complement representation,
    * in other words if it is equal to zero.
    *
    * <p>Note that this method is closely related to the logarithm base 2.
    * For all positive {@code long} values x:
    * <ul>
    * <li>floor(log<sub>2</sub>(x)) = {@code 63 - numberOfLeadingZeros(x)}
    * <li>ceil(log<sub>2</sub>(x)) = {@code 64 - numberOfLeadingZeros(x - 1)}
    * </ul>
    *
    * @param i the value whose number of leading zeros is to be computed
    * @return the number of zero bits preceding the highest-order
    *     ("leftmost") one-bit in the two's complement binary representation
    *     of the specified {@code long} value, or 64 if the value
    *     is equal to zero.
    * @since 1.5
    */
   public static int numberOfLeadingZeros(long i) {
       // HD, Figure 5-6
        if (i == 0)
           return 64;
       int n = 1;
       int x = (int)(i >>> 32);
       if (x == 0) { n += 32; x = (int)i; }
       if (x >>> 16 == 0) { n += 16; x <<= 16; }
       if (x >>> 24 == 0) { n +=  8; x <<=  8; }
       if (x >>> 28 == 0) { n +=  4; x <<=  4; }
       if (x >>> 30 == 0) { n +=  2; x <<=  2; }
       n -= x >>> 31;
       return n;
   }
   /**
    * All possible chars for representing a number as a String
    */
   public final static char[] IntegerDigits = {
       '0' , '1' , '2' , '3' , '4' , '5' ,
       '6' , '7' , '8' , '9' , 'a' , 'b' ,
       'c' , 'd' , 'e' , 'f' , 'g' , 'h' ,
       'i' , 'j' , 'k' , 'l' , 'm' , 'n' ,
       'o' , 'p' , 'q' , 'r' , 's' , 't' ,
       'u' , 'v' , 'w' , 'x' , 'y' , 'z'
   };
   /**
    * Format a long (treated as unsigned) into a character buffer.
    * @param val the unsigned long to format
    * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
    * @param buf the character buffer to write to
    * @param offset the offset in the destination buffer to start at
    * @param len the number of characters to write
    * @return the lowest character location used
    */
    static int formatUnsignedLong(long val, int shift, char[] buf, int offset, int len) {
       int charPos = len;
       int radix = 1 << shift;
       int mask = radix - 1;
       do {
           buf[offset + --charPos] = IntegerDigits[((int) val) & mask];
           val >>>= shift;
       } while (val != 0 && charPos > 0);

       return charPos;
   }
   static final int LongSIZE = 64;
   /**
    * Format a long (treated as unsigned) into a String.
    * @param val the value to format
    * @param shift the log2 of the base to format in (4 for hex, 3 for octal, 1 for binary)
    */
   static String toUnsignedString0(long val, int shift) {
       // assert shift > 0 && shift <=5 : "Illegal shift value";
       int mag = LongSIZE - numberOfLeadingZeros(val);
       int chars = Math.max(((mag + (shift - 1)) / shift), 1);
       char[] buf = new char[chars];

       formatUnsignedLong(val, shift, buf, 0, chars);
       return new String(buf);
   }
   /**
    * Returns a string representation of the {@code long}
    * argument as an unsigned integer in base&nbsp;16.
    */
   public static String toHexString(long i) {
       return toUnsignedString0(i, 4);
   }
public static void set(Calendar cal, int year, int mon, int day, int hrs,
		int min, int sec) {
	Error("Not implemented");
	
}
/**
 * reverse the low order 16 bits of the parameter.  This is cribbed
 * from Integer.reverse.
 * @param i the integer to be reversed
 * @return a short
 */
static public short reverse(int i)
{	
    // HD, Figure 7-1
    i = (i & 0x55555555) << 1 | (i >>> 1) & 0x55555555;
    i = (i & 0x33333333) << 2 | (i >>> 2) & 0x33333333;
    i = (i & 0x0f0f0f0f) << 4 | (i >>> 4) & 0x0f0f0f0f;
    i = (i << 24) | ((i & 0xff00) << 8) |
        ((i >>> 8) & 0xff00) | (i >>> 24);
    return ((short)(i>>16));
}
/**
 * return the smallest recommended feature size, in pixels.  This is 
 * to be used to configure touch screens, where fat fingers can't point
 * at anything too small.
 * @return smallest recommended feature size, in pixels
 */
public static int minimumFeatureSize()
{
	return(getPPI()/3);
}

static boolean isTouch = false;
/**
 * allows an override that this is a touch interface even if we think we should have a mouse
 * @param d
 */
public static void setTouchInterface(boolean d) { isTouch = d; } 
/**
 * return true of this is known to be a touch capable device
 * 
 * @return a boolean
 */
public static boolean isTouchInterface()
{
	return (isTouch || isPlatformTouchInterface());
}

static private String errorContext=null;
/**
 * this allows setting a string as the "context" for operations that are known
 * to be likely to cause an error report.  It's a way of getting a little extra
 * information into the report.  These should be matched by setErrorContext(null);
 * @param str
 * @return the old error context
 */
static public String setErrorContext(String str)
{	String oldC = errorContext;
	errorContext = str;
	return(oldC);
}
static ErrorReporter errorReporter = null;
static public ErrorReporter setErrorReporter(ErrorReporter e)
{
	ErrorReporter old = errorReporter;
	errorReporter = e;
	return(old);
}

static public String getErrorContext() 
{ 	String msg = errorContext;
	if(errorReporter!=null)
	{
		msg +="\nfrom: "+errorReporter+"\n";
		msg += errorReporter.getErrorReport();
	}
	return(msg); 
}
/**
 * set the x,y translation of the graphics
 * 
 * @param gc
 * @param x
 * @param y
 */
static public void translate(Graphics gc,int x,int y)
{	if(gc!=null) { gc.translate(x,y); }
}

static public void translate(HitPoint p,int x,int y)
{
	if(p!=null)
	{
		SetLeft(p,G.Left(p)+x);
		SetTop(p,G.Top(p)+y);
		G.translate(p.spriteRect,x,y);
	}
}
static public void translate(Rectangle r,int x,int y)
{
	if(r!=null) { 
		G.SetLeft(r, G.Left(r)+x);
		G.SetTop(r, G.Top(r)+y);
	}
}

private static int fact(int n)
{
    return(n==0 ? 1 : n*fact(n-1));
}
private static double speed = 0.0;
public static double cpuTest()
{	long now = G.Date();
    for(int j=0;j<1000000;j++) { fact(20); }
	long later = G.Date();
   	return(28.80/(later-now+1));	// 1.0 based on the codename1 simulator running on my machine 1/2016
} 
/**
 * return the apparent cpu speed, where 1.0 is a normalized "standard" pc.  Other than the 
 * reference to an arbitrary standard, this number has no intrinsic meaning.
 * @return a double representing cpu speed
 */
public static double cpuSpeed()
{	if(speed<=0) { speed = cpuTest(); }
	return(speed);
}

static Random random = new Random();
static int maxDelay = 0;
public static void randomDelay() 
{ 	if(maxDelay>0)
	{
	int n = random.nextInt(maxDelay);
	long later = G.Date()+n;
	while(G.Date()<later) { Thread.yield(); }
}
}

private static RootAppletProtocol theRoot = null;
public static final void setRoot(RootAppletProtocol r) { theRoot = r; }
public static final RootAppletProtocol getRoot() { return(theRoot); }

private static InternationalStrings translations = null;
public static final InternationalStrings getTranslations()
{	if(translations==null) 
		{ translations =(InternationalStrings)MakeInstance(Config.DefaultLanguage);
		}
	return(translations);
}
public static final void setTranslations(InternationalStrings s)
{
	translations = s;
}
public static URL getUrl(String fr) 
{	
	try {
		return(new URL(fr));
	} catch (MalformedURLException e) {
		print("Malformed url "+e);
		return(null);
	}
}

public static URL getUrl(String name, boolean doc)
{	URL cname = getResourceUrl(name, doc); 
	if(cname==null)
	{	if(name.indexOf(':')>0) { return(G.getUrl(name)); }	// already has full specification
		URL base = doc ? getDocumentBase() : getCodeBase();

        try
        {
            return((base==null) 
                	? new URL(name)		// this should be equivalent to the two argument form
                						// but we'll see if this cures the log complaints about
                						// the two arg form with null as the first arg
                	: new URL(base,name));
        }
        catch (MalformedURLException err)
        {
        	throw Error( "couldn't get URL(" + base + "," + name + ")" + err);
        }
	}
    return (cname);
}

public static URL getUrl(URL u,String fr)
{
	try {
		return(new URL(u,fr));
	} catch (MalformedURLException e) {
		print("Malformed url "+e);
		return(null);
	}
}


/**
 * get a nicely formatted list of all public (available to applets) java system properties.
 * @return a string
 */
static public String getSystemProperties()
{
    if(G.speedString==null)
    {
    	int speed = ((int)(cpuSpeed()*1000));
    	G.speedString = " cpu="+ ((speed<100) 
    				? (""+(speed/10)+"."+(speed%10))
    				: (""+(speed/10)))+"%";
    }
    String ss = G.concat("[Java",
    		G.speedString,
    		" screen=",	G.getScreenSize(),
    		" ppi=",G.getPPI(),
    		" deviceDPI=",G.getRealScreenDPI(),
    		" scale =",G.getDisplayScale(),
    		" ",
    		(G.isCodename1() 
				? G.concat("Codename1 " , (G.isSimulator()?"sim " : " "), Platform.getAppVersion())
				: G.idString));
    for (int i = 0; i < G.publicSystemProperties.length; i++)
    {	String propname = G.publicSystemProperties[i];
    	String prop = (System.getProperty(propname));
    	if(prop==null)
    	{	if(G.OS_NAME.equals(propname))
    		{
    		prop = G.getPlatformName();
    		}
     	}
    	if(prop!=null) {  ss += " "+prop; }
    }

    return( ss + "]");
}

public static String speedString = null;
public static void setIdString(String str) { G.idString = str; }

public static String idString = "";
public static final String[] publicSystemProperties = 
{
    G.JAVA_VERSION, //    Java version number
    G.JAVA_VENDOR, //    Java vendor-specific string
    G.JAVA_VENDOR_URL, //    Java vendor URL
    G.JAVA_CLASS_VERSION, //    Java class version number
    G.OS_NAME, //    Operating system name
    G.OS_ARCH, //    Operating system architecture
    G.OS_VERSION
};

public static final String OS_VERSION = "os.version";
public static final String OS_ARCH = "os.arch";
public static final String OS_NAME = "os.name";
public static final String JAVA_CLASS_VERSION = "java.class.version";
public static final String JAVA_VENDOR_URL = "java.vendor.url";
public static final String JAVA_VENDOR = "java.vendor";
public static final String JAVA_VERSION = "java.version";

private static ExtendedHashtable globals = new ExtendedHashtable(true);
// constants expected to be used with globals
public static final String LOWMEMORY = "lowmemory";

public static ExtendedHashtable getGlobals() { return(globals); }
public static void setGlobals(ExtendedHashtable e) { globals = e; }
public static boolean debug() { return(globals.getBoolean(DEBUG,false)); }
private static boolean once = false;
public static void setDebugOnce() { once = true; }
public static boolean debugOnce() { boolean o = once; once = false; return(o); }

public static void putGlobal(String p,Object v) 
{ globals.put(p, v);
//G.print("put "+p+" "+v);
}
public static Object getGlobal(String p) { return(globals.get(p)); }
public static boolean getBoolean(String m,boolean def)
{	return globals.getBoolean(m,def); 
}
public static int getInt(String m,int def)
{
	return globals.getInt(m,def);
}
public static int getInt(String m,int def,int min,int max)
{
	return globals.getInt(m,def,min,max);
}
public static String getString(String m,String def)
{
	return globals.getString(m,def);
}
public static double getDouble(String m,double def)
{
	return(globals.getDouble(m,def));
}
/**
 * 
 * @return get the host base for loading jar files 
 */
public static URL getCodeBase()
{
	String g = globals.getString(CODEBASE,"/");
	URL u = getUrl(g.indexOf(":")>0 ? g : Http.getDefaultProtocol()+"//"+globals.getString(SERVERNAME)+g);
	return(u);
}
/**
 * get the host base for other files
 * 
 * @return
 */
public static URL getDocumentBase()
{
	String g = globals.getString(DOCUMENTBASE,"/");	
	URL u = getUrl(g.indexOf(":")>0? g :Http.getDefaultProtocol()+"//"+globals.getString(SERVERNAME)+g);
	return(u);
}
/**
 * this is an ad-hoc function to generate class names for classes that will be instantiated.
 * @param classname
 * @return a replacement class name string
 */
public static String expandClassName(String classname)
{
    String firstpart = classname.substring(0, 2);
    String prefix = "";

    //System.out.println("In: "+classname);
    if ("L:".equals(firstpart))
    {
        prefix = Config.LOBBYCLASSBASE;
        classname = classname.substring(2);
        if("Game".equals(classname)) 
        { // compatibility hack
          prefix = Config.GAMECLASSBASE;
          classname = "game.Game";
        }
    }
    else if ("G:".equals(firstpart))
    {
       prefix = Config.GAMECLASSBASE;
       classname = classname.substring(2);
    }

    while ('-' == (classname.charAt(0)))
    {
        int idx = prefix.lastIndexOf('.');
        prefix = prefix.substring(0, idx);
        classname = classname.substring(1);
    }

    if (prefix.length() > 0)
    {
        classname = prefix + "." + classname;
    }

    //System.out.println("Out: "+classname);
    return (classname);
}


    private static void appendCh(StringBuilder b,int ch)
    {
    	if(ch>=10) { appendCh(b,ch/10); };
    	b.append((char)((char)('0'+ch%10)));
    }
    /**
     * a simple http-safe encoding for strings that may contain unexpected characters
     * decode with {@link #decodeAlphaNumeric}
     * @param s
     * @return the encoded string
     */
    public static String encodeAlphaNumeric(String s)
    {	if(s==null) { return(null); }
    	StringBuilder out = new StringBuilder();
    	for(int i=0;i<s.length();i++)
    	{	char ch = s.charAt(i);
    		if(isLetterOrDigit((char)ch)) { out.append(ch); }
    		else 
    		{ out.append('%');
    		  appendCh(out,ch);
    		  out.append('%');
    		}
    	}
    	return(out.toString());
    }
    /**
     * decode a string that was encoded by {@link #encodeAlphaNumeric}
     * @param s
     * @return the decoded string
     */
    public static String decodeAlphaNumeric(String s)
    {
    	StringBuilder out = new StringBuilder();
    	for(int i=0;i<s.length();i++)
    	{	int ch = s.charAt(i);
    		if(ch=='%') 
    		{	char nextCh;
    			ch = 0;
    			while((nextCh=s.charAt(++i))!='%') { ch = ch*10+(nextCh-'0'); }
    		}
    		out.append((char)ch);
    	}
    	return(out.toString());
    }
    static boolean LEGACY_CONSOLE = false;
    /**
     * create a simple console window that will be the target of {@link #print}
     */
	static public void createConsole()
	{	
		if(LEGACY_CONSOLE)
		{
			XFrame f = new XFrame("Console");
			TextArea ta = new TextArea();
			f.add(ta);
			ta.setEditable(false);
			setPrinter(TextPrintStream.getPrinter(new Utf8OutputStream(),ta));
			print("Legacy Debug Log stream");
			ta.setVisible(true);
			f.setVisible(true);	
		}
		else
		{
			TextDisplayFrame f = new TextDisplayFrame("Console");
		setPrinter(f.getPrinter());
		print("Debug Log stream");
		f.setVisible(true);	
	}

	}
    /** this is the hash checksum used by the server */
    public static int hashChecksum(String str,int n)
    {   int hash = 5381;
    	int c;
    	for (int i=0; i<n;i++)
    	{
    		c = str.charAt(i);
    		hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    	}
    	return hash;
    }
    /**
     * return a date/time string in a format suitable to be part of a file name.
     * @param stime
     * @return a string for the date
     */
    public static String DateString(BSDate stime)
    {
    	GregorianCalendar xtime = new GregorianCalendar();
        xtime.setTimeZone(TimeZone.getTimeZone("GMT"));
        xtime.setTime(stime);

        int year = xtime.get(Calendar.YEAR);
        int month = 1 + xtime.get(Calendar.MONTH);
        int day = xtime.get(Calendar.DAY_OF_MONTH);
        int hrs = xtime.get(Calendar.HOUR_OF_DAY);
        int mins = xtime.get(Calendar.MINUTE);

        return (year + "-" + ((month < 10) ? "0" : "") + month + "-" +
        ((day < 10) ? "0" : "") + day + "-" + ((hrs < 10) ? "0" : "") + hrs +
        ((mins < 10) ? "0" : "") + mins);
    }
    static private char ucodeToChar(int n)
    {
    	switch(n)
    	{
    	// god only knows why these few characters are exceptions to the 1:1 translation
    	case 0x92:	return '';	// \u0092
    	case 0x93:	return '';	// \u0093
    	case 0x94: 	return '';	// \u0094
    	default: return((char)n);
    	}
    }

    /**
     * decode strings with embedded encode with \uaaaa .  This is the way boardspace strings are
     * encoded in the database.
     * @param str
     * @return
     */
    public static String utfDecode(String str)
    {		if(str!=null)
    		{int nchars = str.length();
    		int idx = 0;
    		StringBuffer out = new StringBuffer();
    		while(idx<nchars)
    		{	char ch = str.charAt(idx++);
    			if((ch!='\\') || (idx==nchars) || (str.charAt(idx)!='u')) { out.append(ch); }
    			else 
    			{ idx++;	// got \\u
    			  int lim = Math.min(idx+4,nchars);
    			  int v = Integer.parseInt(str.substring(idx,lim),16);
    			  idx = lim;
    			  out.append(ucodeToChar(v));
    			}}
    	return(out.toString());
    		}
    	return(null);
    }

    public static Font getFont(Graphics g) { return((g!=null) ? g.getFont() : null); }
    
 	static public String getHostName()
    {
    	if(installerPackage!=null && installerPackage.isSupported())
    	{
    		return(installerPackage.getHostName());
    	}
    	return(null);
    }
 	/**
	 * rotate hitpoint H around pivot point cx,cy.  Auxiliary rectangle spriteRect is
	 * also rotated.  This only works as intended for 90 degree rotations. 
	 * @param h
	 * @param ang
	 * @param cx
	 * @param cy
	 */
    public static void setRotation(HitPoint h,double ang,int cx,int cy)
    {	
    	if((h!=null))
    	{	  h.setRotation(ang,cx,cy); 
        }
    }
    /**
     *  translate an angle which should be near a multiple of PI/2 (1/4 turn) to the number
     * of quater turns clockwise, range 0-3
     * @param ang
     * @return 0-3
     */
    //
    public static int rotationQuarterTurns(double ang)
    {	double ma = ((ang*2)+Math.PI/8)/Math.PI;	// 0 to 8, or 0 to -8 
    	int ma1 =((int)ma)%4;
    	return(ma<0?3+ma1:ma1);
    }
    /* test code
    static {
    	for(double ang = -Math.PI*2; ang<Math.PI*2; ang+= Math.PI/2)
    	{
    	System.out.println("ang +e "+ang+" = "+rotationQuarterTurns(ang+0.1));
    	System.out.println("ang -e  "+ang+" = "+rotationQuarterTurns(ang-0.1));
    	}
    }
    */
    public static void setRotation(Rectangle r,double ang)
    {
    	setRotation(r,ang,G.centerX(r),G.centerY(r));
    }
    /*
     * set the rotation for a rectangle to an angle which is a multiple of PI/2.  This rotates
     * the whole rectangle around cx,cy and leaves it with the new origin correctly placed.
     */
    public static void setRotation(Rectangle r,double ang,int cx,int cy)
    {
    	if((r!=null) && (ang!=0))
    	{
    		double cosa = Math.cos(ang);
    		double sina = Math.sin(ang);   		
    		int rot = rotationQuarterTurns(ang);
    		int dx = 0;
    		int dy = 0;
    		boolean swap = false;
    		switch(rot)
    		{
    			case 1:	// angle near pi/2
    				dx = G.Left(r)-cx;
    				dy = G.Bottom(r)-cy;
    				swap = true;
    				break;
    			case 2:
    				dx = G.Right(r)-cx;
    				dy = G.Bottom(r)-cy;
    				break;
    			case 3:
    				dx = G.Right(r)-cx;
    				dy = G.Top(r)-cy;
    				swap = true;
    				break;
    			case 0:
    				dx = G.Left(r)-cx;
    				dy = G.Top(r)-dy;
    				break;
    		}
    		SetLeft(r,(int)(cx+cosa*dx-sina*dy));
    		SetTop(r,(int)(cy+sina*dx+cosa*dy));
    		if(swap)
    		{
    			int w = G.Width(r);
    			int h = G.Height(r);
    			G.SetWidth(r,h);
    			G.SetHeight(r, w);
    		}
    	}
    }

    /**
     * find the new x from rotating x,y around cx,cy
     * @param x
     * @param y
     * @param ang
     * @param cx
     * @param cy
     * @return the rotated x coordinate
     */
    public static int rotateX(int x,int y,double ang,int cx,int cy)
    {
		double cosa = Math.cos(ang);
		double sina = Math.sin(ang);
		int dx = x-cx;
		int dy = y-cy;
		return((int)(cx+cosa*dx-sina*dy));
    }
    /**
     * find the new y from rotating x,y around cx,cy
     * @param x
     * @param y
     * @param ang
     * @param cx
     * @param cy
     * @return the rotated y coordinate
     */
    public static int rotateY(int x,int y,double ang,int cx,int cy)
    {
		double cosa = Math.cos(ang);
		double sina = Math.sin(ang);
		int dx = x-cx;
		int dy = y-cy;
		return((int)(cy+sina*dx+cosa*dy));
    }
    public static int indexOf(Object[]ar,Object t)
    {
    	for(int lim=ar.length-1; lim>=0; lim--) { if(ar[lim]==t) { return(lim); }}
    	return(-1);
    }
    public static void show(Component window, MenuInterface menu, int x, int y) throws AccessControlException
	{
		NativeMenuInterface nativeMenu = menu.getNativeMenu();
		try {
		nativeMenu.show(window,x,y);
		} catch(Throwable err)
		{	// these occur, rarely, due to some java screwup
			G.print("Show failed for ",nativeMenu," ",err);
			nativeMenu.hide(window);
		}
	}
	public static boolean isApproximatelySquare(Rectangle r)
    {	return(r!=null && Math.abs( 1-((double)Width(r)/Height(r)))<0.1);
    }
    
    public static int[]parseColorMap(String value)
    {
   	String ints[] = G.split(value, ',');
    	int map[] = new int[ints.length];
    	for(int i=0;i<ints.length; i++) { map[i]=G.IntToken(ints[i]); }
    	return(map);
    }

        /**
         * fill a rectangle centered on x,y with color c
         * @param f
         * @param c
         * @param x
         * @param y
         * @param s
         */
        static public void fillRect(Graphics f,Color c,int x,int y,int s)
        {	setColor(f,c);
        	fillRect(f,x-s/2,y-s/2,s,s);
        }
        /**
         * fill a rectangle with a specified color
         * @param g
         * @param c
         * @param r
         */
        static public void fillRect(Graphics g, Color c,Rectangle r)
        {	setColor(g,c);
            fillRect(g,Left(r), Top(r), Width(r), Height(r)); 
        }
        /**
         * fill a rectangle with a color
         * @param g
         * @param c
         * @param left
         * @param top
         * @param width
         * @param height
         */
	    static public void fillRect(Graphics g,Color c,int left,int top,int width,int height)
	    {
	    	setColor(g,c);
	    	fillRect(g,left,top,width,height);
	    }
	    public static int defaultFontSize = Default.getInt(Default.fontsize);
	    public static void setDefaultFontSize(int n)
	    {	defaultFontSize = Math.max(6, n);
	    	Default.setInt(Default.fontsize,defaultFontSize);
	    }
	    /**
	     * append all strings to a stringbuilder, so the syntax is approximately
	     * as compact - instead of s+= x+y+z; use G.append(s,x,y,z); 
	     * @param val
	     * @param strings
	     */
		public static void append(StringBuilder val, Object...strings)
		{	for(Object s : strings) { val.append(s.toString()); }
		}
		/** concatenate the strings 
		 * 
		 */
		public static String concat(Object...strings)
		{	StringBuilder b = new StringBuilder();
			
			for(Object s : strings)	{ append(b,s.toString()); }
			return(b.toString());
		}
		/*
		 * rotate all objects being drawn inside a rectangle, nominally a board rectangle.
		 * the hitpoint "select" is also rotated in the board centered coordinate system,
		 * and cells drawn in the new context will have their current_center_x and current_center_y
		 * rotated in to true coordinates.  The next effect will be that after leaving the board-drawing
		 * context, residual drawing such as sprites and animations will only see true x,y coordinates.
		 */
		public static void setRotatedContext(Graphics gc,Rectangle rect,HitPoint select,double rotation)
		{	if(rotation!=0)
			{
			if(gc!=null)
			{
				gc.setRotatedContext(rect,select,rotation);
		}
			else if(select!=null)
			{
				select.setRotatedContext(rotation,G.centerX(rect),G.centerY(rect));
			}}
		}
		/**
		 * rotate items to be painted near the mouse.  This is done in
		 * a context where "select" is an unrotated point in x,y but the
		 * item being drawn should be rotated.
		 *
		 * @param gc
		 * @param select
		 * @param rotation
		 */
		public static void setRotatedContext(Graphics gc,HitPoint select,double rotation)
		{	if(rotation!=0)
			{
			if(gc!=null && select!=null)
			{
				gc.setRotatedContext(select, rotation);
			}
			else if(select!=null)
			{
				select.setRotatedContext(rotation);
			}}
		}
		/**
		 * reverse the effect of setRotatedContext
		 * @param gc
		 * @param select
		 */
		public static void unsetRotatedContext(Graphics gc,HitPoint select)
		{	if(gc!=null) { gc.unsetRotatedContext(); }
			else if(select!=null) { select.unsetRotatedContext(); }
		}

}
 	
