package lib;

import java.awt.Color;
import java.awt.Container;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.security.AccessControlException;
import java.util.Hashtable;
import java.util.StringTokenizer;

import bridge.Utf8OutputStream;
import lib.TextContainer.Op;
import online.common.CanvasProtocol;
import online.common.LFrameProtocol;
import online.common.OnlineConstants;
import online.common.exCanvas;
import online.common.exHashtable;

/* plug-in replacement for commonChatWindow that will not use real windows */

public class ChatWidget 
	implements ChatInterface,OnlineConstants,NullLayoutProtocol,
	SimpleObserver,ActionListener,MenuParentInterface,FocusListener
{
	enum ChatId implements CellId
	{	InputField,
		NameField,
		ShortNameField,
		SendButton,
		Messages,
		MessageLabel;
		
	@Override
	public String shortName() {
		return(name());
	}};
	Keyboard keyboard = null;
	boolean useKeyboard = G.isCodename1();
	boolean hasFocus = false;
	int flipInterval = 500;
	void changeFocus(boolean has,ChatId id)
	{	hasFocus = has;
		inputField.setFocus(has && id==ChatId.InputField,flipInterval);
		nameField.setFocus(has && id==ChatId.NameField,flipInterval);
		shortNameField.setFocus(has && id==ChatId.ShortNameField,flipInterval);
	}
	private boolean embedded=false;
	public boolean embedded() { return(embedded); }
	
    static private final String MESSAGEPROMPT = "Message:";
	static private final String MESSAGETOPROMPT = "MessageTo:";
    static private final String InitMessage = "Type your message here.";
	public boolean isWindow() { return(false); }	// we're free of the window system
    private InternationalStrings s = null;
    private ExtendedHashtable sharedInfo = null;
    private int floodStrings = 0;
    private int prevStringCount = 0;
    private long knockTimer=0;
    public LFrameProtocol theFrame = null;
    private Font basicFont;
    static private final String Spaces = "     ";
    private int MAXLENGTH = 10000;
    private int MINTEXTHEIGHT = 30;
	public Color buttonColor = new Color(0.8f,0.8f,0.8f);
	private Color reddishColor = new Color(1.0f,0.7f,0.7f);

	private boolean hasUnseenContent = false;
	public boolean hasUnseenContent() {		return hasUnseenContent;	}
	public void setHasUnseenContent(boolean v) { hasUnseenContent = v; }
	
	private int x=0,y=0,w=1,h=1;
	public int getX() {	return x; }
	public int getY() { return y; }
	public Rectangle getBounds() {	return new Rectangle(x,y,w,h); }
	public void setBounds(int i, int j, int width, int height) 
	{	
		x = i;
		y = j;
		w = width;
		h = height;
		setLocalBounds(x,y,w,h);
		setVisible(h>0 && w>0);
	}
	
	
	private boolean visible = false;
	public boolean isVisible() { return visible; }
	public void setVisible(boolean b) { visible = b; }
	
	public Color backgroundColor = Color.white;
	public Color foregroundColor = Color.black;

    public void setForegroundColor(Color c)
    {	foregroundColor = c;
    	messages.setForeground(foregroundColor);
    	inputField.setForeground(foregroundColor);
    }
    public void setButtonColor(Color c)
    {	buttonColor = c;
   		messageLabel.setBackground(buttonColor);
    	sendButton.setBackground(buttonColor);
    }
	public void setBackgroundColor(Color chatCol) { backgroundColor = chatCol; }
	
    TextContainer nameField = new TextContainer(ChatId.NameField);
    TextContainer shortNameField = new TextContainer(ChatId.ShortNameField);
	public String nameField() {	return nameField.getText(); }
	public void setNameField(String sf) { nameField.setText(sf); nameField.setVisible(sf!=null);	}
	public String shortNameField() { return shortNameField.getText(); }
	public void setShortNameField(String string) { shortNameField.setText(string);	shortNameField.setVisible(string!=null);}
	
	private ConnectionManager theConn=null;
	public void setConn(ConnectionManager myNetConn) 
	{ theConn = myNetConn;	
	  inputField.setText(s.get(InitMessage));
	  inputField.clearBeforeAppend = true;
 	}
	

	// the main text area
	TextContainer messages = new TextContainer(ChatId.Messages);
    
    // note on standard java, jbutton renders unicode
    // names correctly, button does not.
    public TextContainer messageLabel = new TextContainer(ChatId.MessageLabel);
    public TextContainer sendButton = new TextContainer(ChatId.SendButton);

	int stringCount = 0;
	
    public void addAMessage(String inStr) { addAMessage(inStr,true); }
    
    public void setMessage(String str)
    {
        messages.setText((str == null) ? "" : str);
        //messages.setEditable(true);
    }

    public void addAMessage(String inStr,boolean see)
    {
        FontMetrics myFM = G.getFontMetrics(basicFont);

        int mw = messages.getWidth();
        int useWidth = mw - 15;

        if (useWidth < 400)
        {
            useWidth = 400;
        }

        AddMessage(s.lineSplit(inStr, myFM, useWidth, Spaces),see);
    }

    // 3/18/2003 added "synchronized" despite misgivings that I may have
    // previously removed it. Humber presented a message log that clearly
    // indicated two message streams had been interleaved, and this is the
    // only way that could have happened.
    public void AddMessage(String newstr,boolean see)
    {
        stringCount++;
        AddMessageInternal(newstr,see);
    }
    private synchronized void AddMessageInternal(String newstr,boolean see)
    {
        try
        {
            if (newstr != null)
            {
            	messages.append(newstr);
               
                String newText = messages.getText();
                
                if (newText.length() > MAXLENGTH)
                    {
                        newText = (newText.substring(MAXLENGTH / 3));
                        // note; there is a deep seated problem with setText on linux
                        // calling setText triggers massive validation of the window hierarchy,
                        // which tends to cause thread lockups.  The best medicine is to avoid
                        // setText.
                        messages.setText(newText);
                     }
             
                messages.setCaretPosition(newText.length()-1);
                if(see) 
                	{hasUnseenContent |= !isVisible();
                	}
             }
        }
    	catch (ThreadDeath err) { throw err;}
        catch (Throwable e)
        {
            G.print("chat addmessage : " + e);
        }
    }
	public String getMessages() {
		return messages.getText();
	}
	public void clearMessages(boolean b) {
		messages.setText("");
		messages.setEditable(canvas,b);
	}

	private TextContainer inputField = new TextContainer(ChatId.InputField);
	private boolean hideInputField = false;
	public void setHideInputField(boolean b) { hideInputField = b; }

	UserBank users = new UserBank();

	private synchronized SimpleUser getUser(int inNum)
    {	return(users.getUser(inNum));
    }
	public String getUserName(int inNum)
	{	SimpleUser u = getUser(inNum);
		return((u==null)?null:u.name());
	}
	public synchronized void removeUser(int inNum)
	{	users.removeUser(inNum);
	}
	public void setMyUser(int inNum,String name)
	{	users.setMyUser(inNum,name);
	}
	public synchronized SimpleUser setUser(int inNum, String inName)
	{	return(users.setUser(inNum, inName));
	}
	
    public boolean isSpectator = true;
	public void setSpectator(boolean b) { isSpectator = b; }

	public boolean muted = false;
	public void setMuted(boolean b) { muted = b; }
	
	public int eventcount = 0;
    public boolean resetEventCount()
    {
        boolean b = eventcount > 0;
        eventcount = 0;

        return (b);
    }
  
    /* constructor */
    public ChatWidget (LFrameProtocol frame,ExtendedHashtable shared,boolean emb)
    {	
        //sharedInfo = info;
    	embedded = emb;
    	sharedInfo = shared;
        s = G.getTranslations();
        theFrame = frame;
        basicFont = G.getFont(s.get("fontfamily"), G.Style.Plain, G.standardizeFontSize(12));
        setUser(NEWSCHANNEL, s.get("News"));
        setUser(LOBBYCHANNEL, s.get("Lobby"));
        setUser(ERRORCHANNEL, s.get("Error"));
        setUser(GAMECHANNEL, s.get(GameChannel));
        setUser(BLANKCHANNEL, "");
        setUser(HINTCHANNEL, s.get(HintChannel));
        setUser(LOGCHANNEL,"Log");

        sendButton.setText(s.get("Send"));
        sendButton.setBackground(buttonColor);
        sendButton.setFont(basicFont);
        sendButton.setForeground(Color.black);
        sendButton.renderAsButton = true;
        
        messageLabel.setText(s.get(MESSAGEPROMPT));
        messageLabel.setFont(basicFont); /* basicFont */
        messageLabel.setBackground(buttonColor);
        messageLabel.renderAsButton = true;
        
        inputField.singleLine = true;
        inputField.setFont(basicFont);
        nameField.singleLine = true;
        nameField.setFont(basicFont);
       
        shortNameField.singleLine = true;
        shortNameField.setFont(basicFont);
        messages.setFont(basicFont);
        inputField.addObserver(this);
        
    }

    public void postMessage(int userNum, String command, String theMessage)
    {	SimpleUser u = getUser(userNum);
    	String name = command.equals(KEYWORD_LOBBY_CHAT)
    			? s.get("Lobby")
    			: (u==null)
    						? s.get("User ") + userNum
    						: u.name();
    	
       if(KEYWORD_PPCHAT.equals(command) 
       		|| KEYWORD_PSCHAT.equals(command))
       {	name = s.get("From #1",name);
       }
       postMessageWithName(name,userNum<LASTUCHANNEL,command,theMessage,userNum!=HINTCHANNEL);
    }
    public void postMessageWithName(String name,boolean fromRealUser,String command,String theMessage,boolean see)
    {
        boolean itsme = false;
    	// guess if our name is mentioned and maybe knock knock instead of ding ding
        SimpleUser my = users.getMyUser();
    	if((my!=null) && fromRealUser)
    		{
    		 String myName = my.name();
    		 StringTokenizer tok = new StringTokenizer(theMessage);
        	while (tok.hasMoreTokens())
        	{ String atok = tok.nextToken();
        	  if(myName.equalsIgnoreCase(atok)) 
        	  { long now = G.Date();;
    	  	    if((now-knockTimer)>KNOCKINTERVAL) 
    	  	    	{ itsme=true; }
    	  	    knockTimer = now;
        	  }
        	}}
    	//System.out.println("c "+command+" "+theMessage);
        // translate message is asked
        if (command.equals(KEYWORD_TMCHAT))
        {	
        	theMessage = s.getS(theMessage);
        }
        
        if ((theFrame == null) || (theFrame.doSound()) || itsme)
        {	
            if (command.endsWith(KEYWORD_CHAT))
            {
                String clipname = null;
                int clipTime = 500;	// 1/2 second
                //System.out.println(this + " root " + theRoot);
                if (command.equals(KEYWORD_CCHAT))
                {
                    clipname = challengeSoundName;
                    clipTime = 2000;	// 2 seconds
                }
                else if (KEYWORD_PPCHAT.equals(command) 
                		|| KEYWORD_PSCHAT.equals(command))
                {
                    clipname = itsme ? knockSoundName : gameSoundName;
                }
                else if (command.equals(KEYWORD_QCHAT))
                {
                    /* no clip */
				}
                else
                {	
                    clipname = itsme ? knockSoundName
                    		: (fromRealUser ? chatSoundName : lobbySoundName );
                    
                }

                if (clipname != null)
                {
                	SoundManager.playASoundClip(clipname,clipTime);	
                }
            }
            else if (command.equals(KEYWORD_GOODHINT))
            {
            	SoundManager.playASoundClip(goodHintSoundName);
            }
            else if (command.equals(KEYWORD_BADHINT))
            {
            	SoundManager.playASoundClip(badHintSoundName);
            }
        }

        addAMessage(name + ("".equals(name) ? "" : ": ") + theMessage,see);
    }

	public void PostNews(String showNews)
    {
        try
        {
            URL newsu = G.getUrl(showNews, true);
            InputStream fs = newsu.openStream();
            if(fs!=null)
            {
            try 
            {
            BufferedReader fsb = new BufferedReader(new InputStreamReader(fs));
            do {
            	String ss = G.unicodeDecode(fsb.readLine());
            	if(ss==null) { break; }
                postMessage(NEWSCHANNEL, KEYWORD_QCHAT, ss);
            }  while (true);
            fsb.close();
            }
            finally
            {
            fs.close();
            setHasUnseenContent(false);
            }
            }}
        catch (SecurityException err)
        { // pro forma catch
        }
        catch (IOException err)
        {
             /* System.out.println("news: " + err); */
        }
    }
	
    public ShellProtocol getPrintStream()
    {	return(new TextPrintStream(new Utf8OutputStream(),messages));
    }
    
    private String prevstr[]={"","",""};
    public String whatISaid()
    {	int len = prevstr.length;
    	String val="";
    	String sep="";
    	for(int i=0;i<len;i++)
    	{	val += sep+prevstr[i];
    		sep = " / ";
    	}
    	return(val);
    }

    public void doNullLayout()
    {
   	 setLocalBounds(x,y,w,h);
    }

    public void setLocalBounds(int l,int t,int inWidth,int inHeight)
    {	
        //System.out.println("layout " + inWidth+"x"+inHeight);	
        FontMetrics myFM = G.getFontMetrics(basicFont);
        int messageTop = t;
        int textHeight = (int)(myFM.getHeight()*1.6);
        if (textHeight < MINTEXTHEIGHT)
        {
            textHeight = MINTEXTHEIGHT;
        }


        if ((nameField!=null) && nameField.isVisible())
        {
        	shortNameField.setBounds(x, y, inWidth / 4, textHeight);
        	nameField.setBounds(x+inWidth / 4, y,
                inWidth - (inWidth / 4), textHeight);
            messageTop += textHeight;
        }

        int bottom = inHeight;
        if (hideInputField)
        {	
        	sendButton.setVisible(false);
        	inputField.setVisible(false);
        	messageLabel.setVisible(false);
        	inputField.setEditable(canvas,false);
        }
        else 
        {	int charW = myFM.stringWidth("X");
            int mwidth = charW*12+40;
            int bwidth = myFM.stringWidth(s.get("Send")+charW*2);
            bottom = bottom - textHeight;
            sendButton.setBounds( x+inWidth - bwidth, y+bottom, bwidth, textHeight);
            inputField.setBounds( x+mwidth, y+bottom-1,
                inWidth - bwidth - mwidth, inHeight - bottom);
            messageLabel.setBounds( x+2, y+bottom, mwidth ,
                inHeight - bottom);
           	sendButton.setVisible(true);
        	inputField.setVisible(true);
        	setSingleSend(null,false);
        	messageLabel.setVisible(true);
           	inputField.setEditable(canvas,true);
          }


        inputField.setVisible(!hideInputField);
        messages.setVisible(true);
    	messages.setEditable(canvas, false);
        messages.setBounds(l, messageTop, inWidth, bottom - (messageTop-t));
        if(keyboard!=null) { keyboard.resizeAndReposition(); }
    }
    
    public void setSingleSend(SimpleUser n,boolean temp) 
		{ users.setSingleSend(n,temp);
		  Color bb = (n!=null)
				  ? reddishColor
				  : buttonColor;
		  messageLabel.setBackground(bb);
		  sendButton.setBackground(bb);
		  messageLabel.setText((n!=null) 
		  	? s.get(MESSAGETOPROMPT,n.name()) 
		  	: s.get(MESSAGEPROMPT));
		}

	/* below here definitely work in progress */
	
	public void sendAndPostMessage(int gamechannel, String keywordLobbyChat, String string) {

	}

	public void addTo(Container commonPanel) {

	}

	public void addTo(CanvasProtocol can) {

	}

	public void addto(XFrame f) {

	}

	public void moveToFront() {

	}
	public boolean containsPoint(HitPoint p)
	{
		boolean in = G.pointInRect(p, x,y,w,h);
		if(keyboard!=null)
		{
			in |= keyboard.containsPoint(p);
		}
		return(in);
	}

	public void redrawBoard(Graphics g,HitPoint p)
	{	if(visible)
		{
		if(g!=null) { setHasUnseenContent(false); }
		G.fillRect(g, backgroundColor,x,y,w,h);
		G.frameRect(g,Color.black, x, y,w,h);
		G.setFont(g,basicFont);

		HitPoint ap = p;
		if(keyboard!=null && keyboard.containsPoint(ap)) { ap=null; }
		{
		inputField.redrawBoard(g,ap);
		shortNameField.redrawBoard(g,ap);
		nameField.redrawBoard(g,ap);
		messages.redrawBoard(g,ap);
		messageLabel.redrawBoard(g,ap);
		sendButton.redrawBoard(g,ap);
		}
		if(keyboard!=null)
		{ // draw the keyboard on top
		  if(keyboard.closed) { keyboard = null; }
		  else
		  {
			keyboard.draw(g,p); 
		  }
		}
		}
	}
	

	private void sendInput()
	{
       	String str = inputField.getText();
    	int scount = stringCount;
    	eventcount++;
    	if (str!=null && (str.length()>0)) 
    		{
    		int len = prevstr.length;
    		if ((theConn != null))
    		{
    			if(str.equals(prevstr[len-1]) && (prevStringCount==scount)) {}
    			else if(!muted)
    				{
    				SimpleUser toSingleUser = users.getToSingleUser();
    				boolean priv = (toSingleUser!=null) ;
    				String chatKey = (priv ? (isSpectator? KEYWORD_PSCHAT : KEYWORD_PPCHAT)
    									: (isSpectator? KEYWORD_SCHAT : KEYWORD_PCHAT));
    				String base = priv 
    								? NetConn.SEND_MESSAGE_TO + toSingleUser.channel()+" "
            						: NetConn.SEND_GROUP;
    				
    				theConn.na.getLock();
    				if(theConn.hasSequence) 		
    					{
    					 // add sequence number and keep the accounting straight.
    					 // note that this is deliberately duplicative and poorly
    					 // structured, to make it more likely to trip up hackers
    					 // using advanced tools to mess with our communications. 					
    					 String seq = "x"+theConn.na.seq++;
    					 base  = seq + " "+base;	
    					 if(!priv)
    					 {
    						 @SuppressWarnings("unchecked")
							 Hashtable<String,String>xm = (Hashtable<String,String>)sharedInfo.getObj(exHashtable.MYXM);
    						 xm.put(seq,base);
    					 }
    					}
     				if(str.length()>CHATSIZELIMIT)
    					{ // prevent children from flooding the lobby
    						str = str.substring(0,CHATSIZELIMIT)+" ..."; 
    						floodStrings++;
    					}
     				if(floodStrings<FLOODLIMIT)
     				{
     				// keep the noisy children from annoying the others. 
     					theConn.count(1);
       				if(!theConn.sendMessage(base 
    						+ chatKey
    						+" "
    						+ str))
       				{ str=s.get("You have been disconnected #1","??");
    				}}
     				theConn.na.Unlock();
    				}
    		}
    		postMessageWithName(messageLabel.getText(),true,
    				isSpectator?KEYWORD_CHAT:KEYWORD_PCHAT,str,true);
    		
    		for(int i=1; i<len; i++) { prevstr[i-1]=prevstr[i]; }
    		prevstr[len-1]= str;
    		prevStringCount=scount;
    		}
    	inputField.setText("");
    	canvas.requestFocus();
    	canvas.repaint();
 	}
	
	private LibCanvas canvas = null;
	public void setCanvas(LibCanvas can) 
	{ 	
		if(canvas!=can)
			{
			canvas = can; 
			canvas.addFocusListener(this);
			}
	}
    public void StartDragging(HitPoint hp)
    {	 //System.out.println("Start "+hp);
    	int left = G.Left(hp);
    	int top = G.Top(hp);
       	if(keyboard!=null && keyboard.containsPoint(hp)) { keyboard.StartDragging(hp); }
       	else
       	{
       	messages.doMouseDrag(left,top);
    	inputField.doMouseDrag(left,top);
    	nameField.doMouseDrag(left,top);
    	shortNameField.doMouseDrag(left,top);
     	}

    }
    private boolean draggingOutside = false;
    public HitPoint MouseMotion(int ex, int ey,MouseState upcode)
    {	HitPoint p =  new HitPoint(ex, ey,upcode);
		if(containsPoint(p) && !draggingOutside)
		{	
			if(keyboard!=null && keyboard.containsPoint(p))
			{ keyboard.doMouseMove(ex,ey,upcode); 
			}
			else {
			boolean drag = (upcode==MouseState.LAST_IS_DRAG);
			p.dragging = drag;
			messages.doMouseMove(ex,ey,upcode);
			nameField.doMouseMove(ex, ey, upcode);
			shortNameField.doMouseMove(ex, ey, upcode);
			inputField.doMouseMove(ex,ey,upcode);
			if(drag) { canvas.repaint(); }
			}
			redrawBoard(null,p);
			return canvas.getMouse().setHighlightPoint(p);
		}
		else { draggingOutside = upcode==MouseState.LAST_IS_DRAG; }
    	return(null);
    }
    public boolean DoRepeat()
    {
    	return(messages.DoRepeat());
    }
	public boolean StopDragging(HitPoint hp)
	{	

	    if(hp.hitCode instanceof CalculatorButton.id)
		{
			if(keyboard!=null)
			{ if(keyboard.closed) { keyboard = null; }
				else 
				{ keyboard.StopDragging(hp); 
				}
			}
			return(true);
		}
		else if(hp.hitCode instanceof ChatId)
		{

	    	ChatId id = (ChatId)hp.hitCode;
	    	boolean key = false;
	    	switch(id)
	    	{
	    	case NameField:
	    		key = nameField.editable();
	    	case ShortNameField:
	    		key |= (id==ChatId.ShortNameField) && shortNameField.editable();
	    	case InputField: 
	    		
	    		key |= (id==ChatId.InputField) && inputField.editable() && inputField.idle();
	    		if(key)
	    		{
	    		changeFocus(true,id);
	    		if(useKeyboard) {
	    			keyboard = new Keyboard(canvas,inputField);
	    		}
	    		else 
	    		{	canvas.requestFocus(); 
	    			canvas.repaint(flipInterval);
	    		}}
	    		break;
	    	case MessageLabel:
	    		Point loc = messageLabel.getLocation();
	    		users.selectDestination(this,this,s.get(MESSAGEPROMPT),G.Left(loc),G.Top(loc));
	    		break;
	    	case SendButton:
	    		sendInput();
	    		break;
	    	default: break;
	    	}		
	    	return(true);
		}
	else
		{	return(false);
		}
	}
	public void update(SimpleObservable o, Object arg) {
		if(canvas!=null)
		{
			if(arg ==Op.Send)
			{
			//G.addLog("send");
			sendInput();
			}
		//G.addLog("repaint");
		changeFocus(true,windowId(o));
		canvas.repaint(); 
		}
	}
	public ChatId windowId(SimpleObservable o)
	{	Object target = o.getTarget();
		if(target==inputField) { return(ChatId.InputField); }
		if(target==nameField) { return(ChatId.NameField); }
		if(target==shortNameField) { return(ChatId.ShortNameField); }
		return(null);
	}
	public void actionPerformed(ActionEvent e) {
	   	PopupManager destMenu = users.getDestMenu();
		Object target = e.getSource();
    	if(destMenu.selectMenuTarget(target))
    	{	setSingleSend((SimpleUser)(destMenu.rawValue),false);
    	}
    	else
    		{ G.print("action performed "+e);
    		}
	}
	public void show(MenuInterface menu, int x, int y) throws AccessControlException {
		canvas.show(menu,x,y);
	}
	public void focusGained(FocusEvent e) 
	{
		changeFocus(true,null); 
		canvas.repaint(flipInterval);
	}
	public void focusLost(FocusEvent e) {
		
		changeFocus(false,null); 
		canvas.repaint(flipInterval);
	}
	public int getHeight() { return(h); }
}
