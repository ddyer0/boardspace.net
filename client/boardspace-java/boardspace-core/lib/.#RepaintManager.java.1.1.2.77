package lib;
/**
 * all the gritty details of constructing and displaying the main window image 
 * are here.   Generally speaking, the image is constructed from three pieces,
 * a "fixed elements" bitmap with unchanging contents (between major reformatting)
 * a "display image" with fixed elements overlaid by current contents
 * a "ephemeral" layer of things that are always drawn on the fly.
 * 
 * four different styles of constructing this are supported.
 * 
 * direct, where everything is drawn on the fly and there are no backing bitmaps. This is normally
 * used only when memory is low.
 * 
 * single buffer, where one buffer image is constructed from fixed+dynamic, 
 *  then the ephemeral elements are painted on top
 * double buffer, where front and back images generated by single buffer mode are flipped
 *  this is used on android devices where single buffering results in undesirable flickering.
 * deferred, where no actual drawing is done in response to paint requests, but the drawing is
 *  scheduled and performed in the user loop.  This is the standard display mode for traditional java.
 *   
 */

import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import lib.Graphics;
import lib.Image;
import java.awt.Rectangle;
import java.awt.image.ImageObserver;

import javax.swing.JCheckBoxMenuItem;
import bridge.JMenu;
import bridge.MasterForm;
/* below here should be the same for codename1 and standard java */
import lib.DeferredEventManager;
import lib.G;
import lib.ProgressMonitor;
import vnc.VNCTransmitter;
import vnc.VncInterface;

enum CanvasId implements CellId
{
	FrameTime, ReleaseTime;
	public String shortName() { return(name()); }
}
enum RefreshReason  {
	GeneralRefresh ,	// repaint immediately and draw completely
	Paint,				// repaint after a delay
	VirginBuffer,		// newly created buffer with no content
	DeferredComplete,	// received "paint" in deferred buffer mode, need to draw now.
	Swap,				// back buffer ready, swap with front buffer
	ReadyToSee,			// single buffer is ready to view, trigger "paint" now.
	Timed,				// just a timer, no repaint needed
	Sprites,			// timer, need to draw sprites for animation but not main buffer
}

class PaintTimer
{	// if RECORD is on, we save a stack trace for every paint timer, and log 
	// the events that trigger a redraw to the console.  This is intended as
	// the ultimate debugging aid for "why am I repainting already!"
	static boolean RECORD = false;
	static boolean REPORT = false;
	long expiration;	// expiration time
	int plus = 0;		// original "plus time"
	RefreshReason why;
	String stackTrace = null;
	String caller = null;
	public String toString() { return("<timer "+plus+" "+why+" "+caller+">"); }
	PaintTimer(long ex,int pt,RefreshReason w,String call) 
	{	expiration = ex;
		plus = pt;
		why = w;
		caller = call;
		if(RECORD && (why!=RefreshReason.Timed)) { stackTrace = G.getStackTrace(); }
	}
}
class PTStack extends OStack<PaintTimer>
{
	public PaintTimer[] newComponentArray(int sz) { return(new PaintTimer[sz]); }
	public long topz(int def)
	{
		PaintTimer top = top();
		if(top==null) { return(def); }
		return(top.expiration);
	}
}

public class RepaintManager implements VncInterface
{	boolean USE_VOLATILE_IMAGE = true;	// this uses native hardware, fixes the mac/catalina "terrible font" bug, 4/2020
	boolean USE_BUFFERED_IMAGE = true;
	boolean ZOOM_SLOWLY = true;
	int MINIMUM_FRAME_TIME = 1000/60;		// frames per second
	enum RepaintStrategy {
		Direct_SingleBuffer(0,0,0),
		Direct_Unbuffered(0,0,0),
		Deferred(0,0,0),
		Deferred_Unbuffered(0,0,0),
		SingleBufferNofixed(0,0,0),
		SingleBuffer(0,0,0),
		DoubleBufferNofixed(80,0,0),
		DoubleBuffer(80,0,0);
		int frameTime;
		int frameDelay;
		int releaseTime;
		RepaintStrategy(int fr,int fd,int rt)
		{ frameTime = fr;
		  frameDelay = fd;
		  releaseTime = rt;
		}
	}
	boolean record = false;
	public void setRecord(boolean v) 
	{	if(v)
		{if(!record) 
			{ G.startLog("recording"); 
			record = true;	
			}
		}
		else { G.finishLog(); record = false; } 

	}
	public Color fill = Color.gray;
	public String message = "";
	public boolean showBitmaps = false;
	//
	// if using direct drawing on regular java, the drawing thread
	// interacts badly with the game thread.  This scheme implements
	// a wait-until-safe synchronization.  While the game thread is
	// waiting, which ought to be almost all the time, the painter
	// is allowed to paint.  If the painter arrives at a bad time, 
	// it just repaints the last frame and schedules another paint.
	//
	long waitingToPaintStart = 0;
	SimpleLock directDrawingLock = new SimpleLock("Direct_SingleBuffer Draw");
	boolean getDirectDrawingLock()
	{	// this only applies if using direct drawing
		switch(repaintStrategy)
		{
		case Direct_SingleBuffer:
		case Direct_Unbuffered:
			return(directDrawingLock.Lock());
		default: return(true);
		}
	}
	boolean releaseDirectDrawingLock()
	{
		switch(repaintStrategy)
		{
		case Direct_Unbuffered:
		case Direct_SingleBuffer:
			return(directDrawingLock.UnlockIfHeld());
		default: return(true);
		}
	}
	//
	// this is what the companion has to supply, in addition to being a standard window component
	//
	public interface RepaintHelper extends ImageObserver
	{
		public void actualPaint(Graphics g,HitPoint hp);	// paint on the real window
		public void actualUpdate(Graphics g);
		public void actualRepaint();						// request paint on the real screen
		public void actualRepaint(int n);					// request paint on the real screen (in a while)
		public boolean lowMemory();							// memory ran out sometime
		public void setLowMemory(String s);					// memory ran out while getting buffers
		public void handleError(String s,String context,Throwable r);	// report an error
		public void drawClientCanvas(Graphics g,boolean complete,HitPoint p);	// actual drawing, usually to a buffer
		public void ShowStats(Graphics gc, int i, int j);
		public void showRectangles(Graphics gc, int i);
		public Font getDefaultFont();
		public void manageCanvasCache(int time);
		public boolean needsCacheManagement();
		public void paintSprites(Graphics offGC, HitPoint pt);
		public boolean globalPinchInProgress();
		public void drawActivePinch(Graphics g,Image im,boolean useLast);
		public int getSX();
		public int getSY();
		public int getWidth();
		public int getHeight();
		public double getRotation();
		public double getGlobalZoom();
		public Component getComponent();
		public void paintImage(Graphics gc, HitPoint hp, Image theImage);
		
	}
	Component client;
	RepaintHelper helper;
	public RepaintManager(RepaintHelper cl) 
	{ client = cl.getComponent();
	  helper = cl;
	}
	
	public RepaintManager(RepaintHelper cl,RepaintStrategy m)
	{	this(cl);
		repaintStrategy = m;
	}
	
	// 
	// painting the screen and related activity
	//
	public RepaintStrategy repaintStrategy = G.isCodename1() 
			? (G.isAndroid() ? RepaintStrategy.DoubleBuffer : RepaintStrategy.SingleBuffer)
					: RepaintStrategy.Deferred;
	private Image allFixed = null; 		// for drawing unchanging elements of the board
	private XImage paintBuffer = null; 	// for drawing the main board offscreen
	private XImage drawBuffer = null;	// for optional double buffering 
	private Image duplicateImage = null;
	private PTStack timers = new PTStack();
	private boolean paintedAFrame = false;
	private long lastPaintedAFrame = 0;
	
	private synchronized void addTimer(long now,int increment,RefreshReason why,String call)
	{	if(now==0) { now = G.Date(); }
		//G.addLog("Add timer "+increment+" "+why);
		long future = now + increment;
		PaintTimer newtime = new PaintTimer(future,increment,why,call);
		boolean some = false;
		for(int lim = timers.size()-1; lim>=0 && !some; lim--)
		{
			PaintTimer nextTimer = timers.elementAt(lim);
			if(nextTimer.expiration>=future)
				{
				  if(nextTimer.why==why)
				  	{  if(nextTimer.expiration>future) { timers.setElementAt(newtime,lim); } 
				  	}
				  else { timers.insertElementAt(newtime,lim+1); }
				  some = true; 
				}
			else if(nextTimer.why==why) { some = true; }	// already exists with a shorter time
		}
		if(record)
		{ StringBuilder msg = new StringBuilder();
		  msg.append("Timers: ");
		  for(int lim=timers.size()-1; lim>=0; lim--) { msg.append(timers.elementAt(lim).toString()); }
		  G.addLog(msg.toString());
		}
		if(!some)
		{
		timers.insertElementAt(newtime,0);
			}
		if(sleeping()) { wakeMe(); }
		//else { G.addLog("not sleeping"); }
	}
	private boolean paintNeeded = false;
	private PaintTimer triggerEvent = null;
	public synchronized boolean setPaintNeeded(boolean val) 
	{ 	boolean old = paintNeeded;
		paintNeeded = val; 
		return(old);
	}
	
	//
	// get the next timer if it is in the future
	// handle any expired timers
	//
	private PaintTimer getNextTimer()
	{	long now = G.Date();
		PaintTimer next = null;
		synchronized (this)
	{	
		boolean reachedTheFuture = false;
		while( !reachedTheFuture && (null != (next = timers.top())))
			{
			reachedTheFuture |= next.expiration>=now;
			timers.pop();
			switch(next.why)
				{
				case ReadyToSee: 
					repaintReady();	// trigger paint in buffered modes
					break;
				case Timed:			// just wake up
					break;
				default:
					// all the rest assumed to require redrawing
					reachedTheFuture = true;
					if(!setPaintNeeded(true))
					{ 	// if this is the triggering event, maybe record it
						triggerEvent = next;
						if(PaintTimer.REPORT && PaintTimer.RECORD)
						{
						G.startLog("trigger paint");
						G.addLog(""+next+":"+next.stackTrace);
						G.finishLog();
						}
					}
				}
			}

		}
		
		return(next); 	// wait for the future
	}
	
	private long lastPaint = 0;			// when the last actual paint to the real screen occurred
	public int paintSteps = 0;			// number of repaints
	public int sleepTime = 0;			// time spent sleeping
	public long benchTime = 0;
	public long paintTime = 0;			// time spent painting
	public long lastPaintTime = 0;		// most recent paint
	public void clearStats()
	{
		sleepTime =  0;
		benchTime = 0;
 	   	paintSteps = 0; 
 	   	paintTime = 0;
	}
	public String statString()
	{	long now = G.Date();
        int pt = (int)(paintTime / Math.max(1,paintSteps));
        int pctsleep = (int)(sleepTime*100/Math.max(now-benchTime,1));
        String te = triggerEvent==null ? "" : ""+triggerEvent;
		return(" P:"+ paintSteps + " "+(lastPaintTime)+"/"+pt+"u S:"+pctsleep+"% "+te);
	}
	boolean shutdown = false;
	// call this to release bitmaps and prevent getting them back
	public void shutdown()
	{ shutdown = true;
	  stopVNC("window shutdown");
	  ProgressMonitor.stopProgress();
	  setAllFixed(null);
	  setPaintBuffer(null);
	  
	}	 
	    // some help mapping the java refresh actions into our canvas.  It's desirable 
	    // to do all the drawing synchronously, in the main game thread, so there's 
	    // no question of synchronization among the game thread, the refresh thread
	    // and the mouse input thread.
	private boolean completeRefresh = true; //we need to repaint everything
	private synchronized boolean setComplete(boolean val)
	{
		boolean old = completeRefresh;
		completeRefresh = val;
		return(old);
	}
	
    HitPoint highlightPoint = null;
    public void setHighlightPoint(HitPoint p)
    { highlightPoint = p; 
    }
    
    public Slider frameTimeSlider = null;
    public Slider releaseTimeSlider = null;
	    
    
public boolean performStandardButtons(CellId id)
{	 if(id==CanvasId.FrameTime) 
    		{
			if(frameTimeSlider!=null) { repaintStrategy.frameTime = (int)(frameTimeSlider.value*100); }
			return(true);
		}
	else if(id==CanvasId.ReleaseTime) 
		{ if(releaseTimeSlider!=null) { repaintStrategy.releaseTime = (int)(releaseTimeSlider.value*100); }
		return(true);
		}
	return(false);
}

    public void generalRefresh(String w)
    {
    	setComplete(true);
    	addTimer(0,1,RefreshReason.GeneralRefresh,w);
    }
    int imageErrors=0;

    //
    // this is a debugging utility to inset a postage stamps of the backing bitmaps
    // that are used to construct the main image.
    //
    static int step = 0;
    public void showBitmaps(Graphics g)
    {
		int w = client.getWidth();
		int h = client.getHeight();
		int w1 = w/6;
		int h1 = h/6;
		int xx = -G.getTranslateX(g)+w1/2;
		int x = xx;
		int y = -G.getTranslateY(g)+h1*3; 
		G.setClip(g,x,y,w,h);
		G.fillRect(g,Color.black,x,y,w1*4,h1+h1/2);
		y+=h1/8;
		x+= w1/4;
		Image im = allFixed;
		if(im!=null) { G.drawImage(g,im,x,y,w1,h1,client); }
		else { G.setColor(g,Color.blue); G.drawLine(g,x,y,x+w1/2,y+h1/2); }
		G.frameRect(g,Color.blue,x,y,w1,h1);
		x += w1+w1/8;
		if(drawBuffer!=null) { G.drawImage(g,drawBuffer.theImage,x,y,w1,h1,client); }
		else { G.setColor(g,Color.blue); G.drawLine(g,x,y,x+w1/2,y+h1/2); }
		G.frameRect(g,Color.blue,x,y,w1,h1);
		x += w1+w1/8;
		if(paintBuffer!=null) { G.drawImage(g,paintBuffer.theImage,x,y,w1,h1,client); }
		else { G.setColor(g,Color.blue); G.drawLine(g,x,y,x+w1/2,y+h1/2); }
		G.frameRect(g,Color.blue,x,y,w1,h1);
		if(message!=null)
		{	G.Text(g,false,xx+w1/8,y+h1,w1*5, h1/2,Color.white, null,""+step+":"+message+" rr "+repaintReadyCount+" rs "+repaintSpritesCount);
			message = "";
			repaintReadyCount = 0;
			repaintSpritesCount = 0;
		}
	}
  
	private boolean checkReadyToSee(XImage im)
	{	if(im.readyToSee()) { return(true); }
		if(im.written)
		{
		long now = G.Date();
    	long delay = (im.endWriteTime+repaintStrategy.releaseTime)-now;
    	if(delay<=0) { im.setReadyToSee(); return(true); }
		}
    	return(false);
    }
	private void cantPaintNow()
	{
		long now = G.Date();
		if(waitingToPaintStart==0) { waitingToPaintStart = now; }
		helper.actualRepaint(10);
		if(now-waitingToPaintStart>500)
		{	String msg = directDrawingLock.lockThreadStack();
			G.print("Waiting to paint ",msg);
			waitingToPaintStart = now;
		}
	}
	
    public void paint(Graphics g)
    { 	if(shutdown) { return; }
    	//G.addLog("painting");
     	if(G.canRepaintLocally(client)
				|| G.canRepaintLocally(g))
    	{
    	G.setFont(g,helper.getDefaultFont());	// start with a consistent font

    	switch(repaintStrategy)
    	{   	
    	case Deferred_Unbuffered:
    	case Deferred:
    		setComplete(true);		// say we need it
    		addTimer(0,0,RefreshReason.DeferredComplete,"Paint");
            break;
            
   		  	
    	case DoubleBuffer:
    	case DoubleBufferNofixed:
    		swapBuffersIfReady();
    	case SingleBuffer:
    	case SingleBufferNofixed:
    	{
    	XImage im = getOrCreatePaintBuffer();
    	if(im!=null)
     		{
    		//if(showBitmaps) { G.print(""+step+": start "+repaintStrategy); }
    		@SuppressWarnings("unused")
			long lp = lastPaint;
    		boolean pinch = helper.globalPinchInProgress() || im.usedForPinch;
    		im.startReadTime = G.Date();
    		long prevPaint = lastPaint;
    		if(pinch)
    		{
    		double r = helper.getRotation();
    		int w = helper.getWidth()/2;
    		int h = helper.getHeight()/2;	
    		G.setRotation(g, r,w,h);
        		im.usedForPinch = true;
        		helper.drawActivePinch(g,im.getImage(),!pinch);
    		G.setRotation(g, -r, w, h);
    		lastPaint = G.Date();
				}
    		else {
    		//G.addLog("drawing to real screen");

    		drawToRealScreen(g,im);
    		im.setSeen();
    		lastPaint = im.endReadTime = G.Date();
    		HitPoint hp = (highlightPoint == null) ?  new HitPoint(-1,-1) : highlightPoint;
    		step++;
    		helper.actualPaint(g,hp);		// this does the rest of painting, ie; painting components

    		if(showBitmaps)
	    		{
    			long now = G.Date();
	    		message += ""+(lastPaint-prevPaint)+" next: "+(timers.topz(0)-now);
	    		showBitmaps(g);
	    		}
    		}

       		return;
    		}
    		}
    	// can fall through if unable to create a buffer
       	case Direct_Unbuffered:
       		triggerEvent = null;
       		if(getDirectDrawingLock())
       			{
       			waitingToPaintStart = 0;	
       			try {
       				repaintCanvas(g);
       			}
       			finally { releaseDirectDrawingLock(); }
       		}
       		else // not now
       		{ cantPaintNow();
       		} 	
       		break;
       		/* fall into the direct draw case if there's no backing store */
       	case Direct_SingleBuffer:
    		//G.fillRect(g,fill,0,0,client.getWidth(),client.getHeight());
       		//G.addLog("paint direct");
       		triggerEvent = null;
  			XImage back = getOrCreatePaintBuffer();
  			if(getDirectDrawingLock())
       		{	try {
       			waitingToPaintStart = 0;
       			Graphics off = back.getImage().getGraphics();
       			repaintCanvas(off);
       			drawToRealScreen(g,back);
       			}
       			finally { releaseDirectDrawingLock(); }
       		}
       		else  
       		{
   			  drawToRealScreen(g,back);	// show what we've got
   			  cantPaintNow();
       		}
  		  	break;
    	}
 
 
     }
	
    }


    /** create a blank image with the specified size.
	    * 
	    * @param w
	    * @param h
	    * @return an Image
	    */
	    public Image createBlankImage(int w,int h,Color fillColor)
	    {	
	        try {
	        	Image im = //Toolkit.getDefaultToolkit().createImage();
	        		USE_VOLATILE_IMAGE ? G.getVolatileImage(helper.getComponent(),w,h) :
	        			USE_BUFFERED_IMAGE ? G.createTransparentImage(w,h) : G.createImage(client,w,h);
	        	if(im==null)
	        	{setRepaintStrategy(RepaintStrategy.Direct_SingleBuffer);
	        	 helper.setLowMemory("CreateImage "+w+"x"+h+" failed with null");
	        	}
	        	else if(fillColor!=null){
	        		Graphics gr = im.getGraphics();
	        		G.fillRect(gr,fillColor,0,0,w,h);
	        	}
	        	return(im); 
	        }
	    	catch (ThreadDeath err) { throw err;}
	        catch (Throwable err)
	        { imageErrors++;
	          setRepaintStrategy(RepaintStrategy.Direct_SingleBuffer);
	          helper.setLowMemory("CreateImage "+w+"x"+h+" failed with "+err);
	          if(imageErrors<3)
	          {
	        	  throw G.Error("createAllFixed #"+imageErrors+" "+w+"x"+h+" "+err) ;
	          }
	        }
	        return(null);
	    }

	    private void setAllFixed(Image newv)
	    {	
	        Image im = allFixed;
	        allFixed = newv;
	        if ((im != null) && (im != newv))
	        {
	            G.Dispose(im);
	        }
	    }
	    /**
	     * create (of necessary) and return an offscreen image
	     * with the specified size.  This image is intended to be
	     * used to draw background, rarely changing elements in the
	     * background.
	     * @param w
	     * @param h
	     * @return true if a new image was created
	     */
	    public boolean createAllFixed(int w, int h)
	    {	boolean newv=false;
	    	switch(repaintStrategy)
	    	{
	    	default:
	    		if(!helper.lowMemory())
	    		{
	    			if (needNewImage(allFixed,w,h))
	    	    	{	
	    	    		setAllFixed(null);	// release the old first
	    	    		setAllFixed(createBlankImage(w, h,fill));
	    	    		newv=true;
	    	    	}
	    			break;
	    		}
	    	case DoubleBufferNofixed:
	    	case SingleBufferNofixed:
	    	{ // by convention, the "allfixed" array is only a performance enhancement
	    		// and we can do without it pretty well.
	    		if(allFixed!=null)
		    		{
	    		setAllFixed(null);
	    		newv=true;
	    		}
	    	}
	    	}
	    	return (newv);
	    }
	    
	    public Image allFixed() { return(allFixed); }

	    public XImage getPaintBuffer() 
	   	{ 
	    	switch(repaintStrategy)
	    	{
	    	case Direct_Unbuffered:
	    	case Deferred_Unbuffered:
	    		if(paintBuffer!=null) { setPaintBuffer(null); } 
	    		return(null); 
	    	default:
	        	if(paintBuffer!=null)
	        		{int w = client.getWidth();
	        	     int h = client.getHeight();
	        	     if(needNewImage(paintBuffer,w,h)) 
	        	     	{ setPaintBuffer(null); 
	        	     	}
	        		}
	        	  return(paintBuffer); 
	    	}
	    }
	    public XImage getOrCreatePaintBuffer()
	    {
	    	XImage im = getPaintBuffer();
	    	if(im==null)
	    		{ im = createPaintBuffer(); 
	       		  if(im!=null)
	       		  { //if we got a virgin bitmap, schedule an actual paint asap
	       			  addTimer(0,0,RefreshReason.VirginBuffer,"virgin paint buffer");
	       		  }
	    		}
	    	return(im);
	    }
	    
	    public XImage getOrCreateDrawBuffer()
	    {
	    	XImage im = getDrawBuffer();
	    	if(im==null) { im = createDrawBuffer(); } 
	    	return(im);
	    }
	    
	    private XImage getDrawBuffer() 
	    { 
	    	switch(repaintStrategy)
	    	{
	    	case Deferred_Unbuffered:
	    	case Direct_Unbuffered:
	    		setPaintBuffer(null);
	    		return(null);
	    	case DoubleBuffer: 
	    	case DoubleBufferNofixed:
	    		return(drawBuffer);
	    	case Deferred:
	    	case Direct_SingleBuffer:
	    	case SingleBuffer: 
	    	case SingleBufferNofixed:
	    	default:
	    		return(paintBuffer);
	    	}
	    }
	    
	    private void swapOffScreenNow()
	    {	XImage off = paintBuffer;
	    	 // inhibit the swap if there's an unseen frame ready
	        paintBuffer = drawBuffer;
	        drawBuffer=off;
	        if(off!=null) { off.clear(); }
	    }
	    
	    private void swapBuffersIfReady()
	    {	switch(repaintStrategy)
	    	{
	    	default: break;
	    	case DoubleBuffer:
	    	case DoubleBufferNofixed:
	    	{	XImage draw = drawBuffer;
	    		if(draw!=null)
	    		{
	    		if(checkReadyToSee(draw)) { 
	    			swapOffScreenNow();
	    		}}
	    	}}
	    }
	    
	    private Image recycle(Image r,Image n,int w,int h)
	    {	if((r==null) && (n!=null) && (G.Width(n,helper)==w) && (G.Height(n,helper)==h)) 
	    		{ //G.print("recycling "+n+" from "+this);
	    		  Graphics g = n.getGraphics();
	    		  G.fillRect(g,fill,0,0,w,h);
	    		  return(n); 
	    		}
	    	if(n!=null) { G.Dispose(n); }
	    	return(r);
	    }
	    
	    // get a recycled image with a given size, or null, and trash the other cached images.
	    public Image getRecycledImage(int w,int h)
	    {	Image rim = null;
	    	if((repaintStrategy==RepaintStrategy.DoubleBuffer)
	    			|| (repaintStrategy==RepaintStrategy.DoubleBufferNofixed))
	    		{	XImage im = getDrawBuffer();
	    			drawBuffer=null;
	    			if(im!=null) { rim = recycle(rim,im.theImage,w,h); }
	    		}
	     	{ Image im = allFixed();
	    	  allFixed = null;
	    	  rim = recycle(rim,im,w,h);
	    	}
	       	{ XImage im = getPaintBuffer();
	       	  paintBuffer = null;
	       	  if(im!=null) { rim = recycle(rim,im.theImage,w,h); }
	       	}
	       	return(rim);
	    }
	    
	    private void setPaintBuffer(XImage newv)
	    {
	        XImage im = paintBuffer;
	        paintBuffer = newv;
	        if ((im != null) && (im != newv))
	        {
	            G.Dispose(im.theImage);
	        }
	        if(newv==null && (drawBuffer!=null))
	        {	// always flush both
	        	swapOffScreenNow();
	        	setPaintBuffer(null); 
	        }
	    }
	    
	    private final boolean needNewImage(XImage im,int w,int h)
	    {	return((im==null) || needNewImage(im.theImage,w,h));
	    }
	    private final boolean needNewImage(Image im,int w,int h)
	    {	return((im==null)
	    		 || (G.Width(im,helper)!=w)
	    		 || (G.Height(im,helper)!=h));
	    }
	    public void setRepaintStrategy(RepaintStrategy strat)
	    {
	    	repaintStrategy = strat;
	    	switch(strat)
	    	{
	    	case DoubleBufferNofixed:
	    	case SingleBufferNofixed:
	    	case Direct_SingleBuffer:
	    		setAllFixed(null);
	    		break;
	    	default:
	    	}
	    	switch(strat)
	    	{
	    	case Deferred_Unbuffered:
	    	case Direct_Unbuffered:
	    		setPaintBuffer(null); 
	    		/** fall through */
	    	case SingleBuffer:
	    	case Direct_SingleBuffer:
	    	case SingleBufferNofixed:
	    	case Deferred:
				if(drawBuffer!=null) { swapOffScreenNow(); setPaintBuffer(null); }
				break;
	    	default:
	    		break;
	    	}
	    	setBufferMenuChoice();
	    }
	    /**
	     * create (if necessary) and return an offscreen image with
	     * a specified size.  This image is intended to be used for
	     * routine offscreen drawing before displaying on the canvas.
	     * If double buffering is in effect, the back buffer is returned.
	     * 
	     * @param w
	     * @param h
	     * @return true if a new image was created
	     */
	    public XImage createOffScreen(int w, int h)
	    {	
	        	Image newim =G.getRecycledImage(w,h);
	        	if(newim==null) { newim = createBlankImage(w, h,fill); }
	    	if(newim!=null) 
	            {
	    		return(new XImage(newim));
	            }
	    	return(null);
	    }



	     /** timer expired requiring a real paint */
	     public void repaintCanvas()
	     {	if(shutdown) { return; }
	     
	     	switch(repaintStrategy)
	     	{
	     	case Direct_Unbuffered:
	     	case Direct_SingleBuffer:	
	     		helper.actualRepaint();
	     		break;
	     	case Deferred_Unbuffered:
	     	case Deferred:
		    	 {
		    	 Graphics g = Graphics.create(client.getGraphics());
		    	 boolean rotated = MasterForm.rotateCanvas(client, g);
		       	 repaintCanvas(g);
		       	 if(rotated) { MasterForm.unrotateCanvas(client, g); }
		    	 }
		    	 break;
	     	default:
	     		{boolean rotated = MasterForm.rotateCanvas(client,null);
		       	 repaintCanvas(null);
		       	 if(rotated) { MasterForm.unrotateCanvas(client,null); }
	     		}
	     		break;
	     	} 	 
	     }
	     private int repaintReadyCount = 0;
	     public void repaintReady() 
	     {	 repaintReadyCount++;
	     	 //G.addLog("repaint ready");
	    	 helper.actualRepaint();
	     }
	     private int repaintSpritesCount = 0;
	     public void repaintSprites(int timer,String caller)
	     {	
	    	repaintSpritesCount++;
	    	addTimer(G.Date(),timer,RefreshReason.Sprites,caller);
	     }
	     public void repaintCanvas(Graphics g)
	     {	 
	    	 if(ZOOM_SLOWLY)
	    		 {switch(repaintStrategy)
		    	 {	default:
		    		 if(helper.globalPinchInProgress())
		     		{ 	//G.addLog("request repaint in pan/zoom");
		     			helper.actualRepaint();
		    			return;		// inhibit real drawing until we stop pan/zoom 
			     		}
		    		 	break;
		    	 case Deferred:
		    	 case Deferred_Unbuffered:
		    	 }}
	    	 boolean complete = setComplete(false);
	         if(complete) { clearStats(); }
	 //        setVisible(shouldBeVisible);
	 //        imageCache.clearCachedImages();

	         final HitPoint hp = (highlightPoint == null) ?  new HitPoint(-1,-1) : highlightPoint;
	         final Graphics hg = g;
	         final boolean hcomplete = complete;
	         //
	         // start the paint with no hitobject, this makes the 
	         // actual drawing pass behave the same as the mouse-only pass
	         //
	         // IOS only does rendering in EDT
	         if(G.isCodename1())// this forces all drawing into the edt thread
	         {	// G.addLog("run paintcanvas in edt");
	        	 G.runInEdt(
	     				new Runnable () 
	     				{	public void run() 
	     					{ //G.addLog("running paintcanvas in edt");
	     					  paintCanvas(hg,hcomplete,hp);
	     					}
	     				}); 
	        	 //G.addLog("finished paintcanvas in edt");
	         }
	         else {
	         paintCanvas(hg, hcomplete,hp);
	         }
	     }
	     
	     int errors = 0;
	     private XImage createPaintBuffer()
	     {
	    	 int width = client.getWidth();
	    	 int height = client.getHeight();
	    	 XImage pb = createOffScreen(width,height);
	    	 setPaintBuffer(pb);
	    	 return(pb);
	     }
	     private XImage createDrawBuffer()
	     {
	    	 int width = client.getWidth();
	    	 int height = client.getHeight();
	    	 XImage pb = createOffScreen(width,height);
	    	 drawBuffer =pb;
	    	 return(pb);
	     }
	     
	     /**
	      * this is the method that actually draws the window, which will
	      * can be superseded by the final window class.  This default method
	      * creates an off screen bitmap and calls {@link #repaintCanvas } with the 
	      * gc of the off screen bitmap, so if that is the desired behavior
	      * repaintCanvas can be overridden instead. 
	      * 
	      * @param gc a graphics object
	      * @param completePaint if true, do a complete refresh
	      * @param pt a {@link lib.HitPoint}, representing the state of the mouse.
	      * 
	      * @see HitPoint
	      */
	    public void paintCanvas(Graphics gc, boolean completePaint,HitPoint pt)
	 	{	//G.addLog("Actual painting start");
	 		long now = G.Date();
	 		boolean drawn = false;
	    	try {
	    	switch(repaintStrategy)
	    	{
	    	case Direct_Unbuffered:
	    	case Direct_SingleBuffer:
	    	case Deferred_Unbuffered:
	    		break;
	    	default:
		    	{
		 		XImage localOffScreen = getOrCreateDrawBuffer();
		 		boolean complete = completePaint | (localOffScreen !=null && localOffScreen.mustBeComplete);
		 		if(localOffScreen!=null)
		 	    {  
	    	    	if(localOffScreen.written() && !localOffScreen.seen())
			    	    	{
	    	    		// buffer not available for writing
	    	    		long delay = (localOffScreen.endReadTime+repaintStrategy.frameTime)-now;
	   	    	    	if(delay>0)
			    	    		{ //G.print("Reschedule "+delay);
		   	    	    		  if(completePaint) { setComplete(true); }	// reinstate completeness
	   	    	    		  addTimer(now,(int)delay,RefreshReason.Paint,"wait for clean buffer");
			    	    		}	// reschedule for later
		       	    	return; 
		 	    	}
		    	    		repaintCanvas(localOffScreen,gc,complete,pt);

		       		drawn = true;

		        		}
		 		}}
		    	
		    	if(gc!=null && !drawn)
		 	    	{
		 	    	helper.drawClientCanvas(gc,true,pt);
		 	    	helper.paintSprites(gc,pt);
		 	    	lastPaintedAFrame = G.Date();
		 	    	paintedAFrame = true;
		      		G.setColor(gc,Color.blue);
		        	helper.showRectangles(gc,100);
		        	helper.ShowStats(gc,0,0);
	    	
		    	}
	    	}
	 		catch (Throwable err)
	 		{	if(errors++<10) {	helper.handleError("in paintCanvas",null,err); }
	 		}
       
	 		long later = G.Date()-now;
	 		lastPaintTime = later;
	    	paintTime += later;
	    	paintSteps++;
	    	//G.addLog("Actual painting end");
	  	}
	    	
	 	private void repaintCanvas(XImage offScreen,Graphics gc,boolean complete0, HitPoint pt)
	 	{	
	 		boolean complete = setComplete(false)|complete0;
	  		Graphics offGC = offScreen.getGraphics();	// also marks it as unseen
	  		G.setFont(offGC,helper.getDefaultFont());
  			
	  		// font, line style, etc are not well defined at this point
	  		helper.drawClientCanvas(offGC,complete,pt);
	  		long now = lastPaintedAFrame = G.Date();
	  		offScreen.startWriteTime = now;
	  		paintedAFrame = true;
	    	if(repaintStrategy==RepaintStrategy.Deferred)
	    	{	int x = helper.getSX();
	    		int y = helper.getSY();
	    		G.translate(offGC,-x,-y);
	    		helper.paintSprites(offGC,pt);
		    	helper.ShowStats(offGC,0,0);	// add some stats on top of everything
	    		G.translate(offGC,x,y);
	    	}
			    
	    	helper.showRectangles(offGC,100);
	    	G.setColor(offGC,Color.blue);
	    	helper.ShowStats(offGC,0,0);	// add some stats on top of everything
		    
	    	offScreen.startReadTime = G.Date();
	    	drawToRealScreen(gc,offScreen);
	    	lastPaint = offScreen.endReadTime = G.Date();
		    
		    offScreen.mustBeComplete = false;
   	    	long fintime = G.Date();
   	    	offScreen.setWritten(fintime);
   	    	if(repaintStrategy!=RepaintStrategy.Deferred) 
   	    	{
   	    	addTimer(fintime,repaintStrategy.releaseTime,RefreshReason.ReadyToSee,"RepaintCanvas");	    // wake us when the frame is ready
   	    	}
	 	}
	 	
	 	public void drawToRealScreen(Graphics gc,XImage im)
	 	{	//G.addLog("draw to real screen");
	 		double rot = helper.getRotation();
	 		int w = client.getWidth()/2;
	 		int h = client.getHeight()/2;
    		G.setRotation(gc, rot,w,h);
    		HitPoint hp = (highlightPoint == null) ?  new HitPoint(-1,-1) : highlightPoint;
    		helper.paintImage(gc,hp,im.theImage);
	    	G.setRotation(gc, -rot, w,h);
	    	Image dup = duplicateImage;
	    	if(dup!=null)
	    	{
	    		Graphics g2 = dup.getGraphics();
	    		G.drawImage(g2, im.theImage, 0, 0, client);
	    		captureState = im.writtenState;
	    		duplicateImage = null;
	    		G.wake(dup);
	    	}
	 	}
	     /** request a normal refresh of the window
	      * some background elements may not be repainted.
	      */
	     public void repaint(String w)
	 	{ 	if(G.canRepaintLocally(client))
	 		{ 	//G.startLog("repaint from mouse");
	     		repaint(0,w);
	 		}
	 	}
	     public void repaint(int tm,String w)
	     {	
	    	 long now = G.Date();
	    	 // no matter how much of a hurry, don't paint again too soon
	    	 addTimer(now,Math.max((int)((lastPaintedAFrame+MINIMUM_FRAME_TIME)-now), tm),RefreshReason.Paint,w);
	     }

	     private boolean sleeping = false;
	     private synchronized void setSleeping(boolean val) { sleeping = val; }
	     private synchronized boolean sleeping() { return(sleeping); }	   
	     
	     private boolean waitAWhile(PaintTimer timer)
	     {	
	     	 boolean waited = false;
	     	 long now = G.Date();
	     	 long howLong = timer.expiration - now;
	    	 if(howLong>0) 
	    	 	{ long beginsleep = now; 
	    	 	  setSleeping(true);
	    	 	  //G.addLog("sleep "+client+" "+howLong);
	    	 	  releaseDirectDrawingLock();
	    	 	  G.waitAWhile(client,howLong);
	    	 	  //G.addLog("done sleeping");
	    	 	  setSleeping(false);
	    	 	  waited = true;
	    	 	  long later = G.Date();
	    	 	  long sl = later-beginsleep;
	    	 	  while(!getDirectDrawingLock()) 
	    	 	  	{ G.waitAWhile(client,10); 
	    	 	  	}

	    	 	  //if(sl<howLong) 
	    	 	 // 	{ G.addLog("Waked early " + client+" "+sl); 
	    	 	 // 	}
	    	 	  sleepTime += sl; 
	    	 	  if(benchTime==0) { benchTime = beginsleep; }
	    	 	}
	    	 //G.addLog("waked");
	    	 return(waited);
	     }

	     /**
	      * this captures the standard java "update" request,
	      * but doesn't do any painting.
	      */
	     public void update(Graphics g)
	     { 	// this is an attempt to affect the "blank screen" problem.
	     	// the theory is that our non-painting is resulting in a damaged
	     	// drawing engine.
	     	//G.combinedClip(g,0,0,0,0);
	     	//super.update(g);
	     	//
	     	// also note; dealing with problems where the chat area is blank, you 
	     	// can frequently "fix" the problem by forcing theChar.update(g) here,
	     	// or by adding super.update(g) here.   Drawing a colored line here
	     	// also is useful to diagnose some problems.  See comments about JPanel
	     	// verses Panel in commonChatApplet and commonPanel.
	     	//
	     	switch(repaintStrategy)
	     	{
	     	case Deferred:
	     	case Deferred_Unbuffered:
	         	wakeMe();
	         	break;
	     	case Direct_Unbuffered:
	     	case Direct_SingleBuffer:
	     		paint(g);
	     		break;
	     	default:
	     		break;
	     	}
	     }

	    public void wakeMe()
	    { 	//G.addLog("wake");
	    	wake();
	    }
	    /** wake the run loop early.  This should not normally be necessary
	     * 
	     *
	     */
	    public void wake()
	    {
	        G.wake(client);
	    }

	    public void repaintAndOrSleep(final int howLongMax)
	    {	
	    	final long now = G.Date();
	    	//G.addLog("repaintOrSleep "+howLongMax);
		   	addTimer(now,howLongMax,RefreshReason.Timed,"repaintAndOrSleep");
		   			
		   	// process timers until we wait once
		    PaintTimer next = null;
		    boolean waited = false;
		    paintedAFrame = false;				// exit when we've actually painted a frame, let the main loop run around
		   	do { next = getNextTimer(); 
		   		if(next!=null)
		   			{
		   			final int nextv = (int)(next.expiration-now);
		   		if(nextv>0 && helper.needsCacheManagement())
   						{
		   				G.startInEdt(new Runnable() { public void run()	{ 	 helper.manageCanvasCache(nextv); 	}});
   						}
		   			waited |= waitAWhile(next);
		   			{ if(setPaintNeeded(false) && !paintedAFrame)
		   				{
		   				boolean canSee = G.isCompletelyVisible(client) || G.isPartlyVisible(client);
		   				if(canSee)
		   				{	// if we can't see the window, don't actually repaint
		   					// we'll get another paint request when we can see it.
		   					repaintCanvas(); 
		   			    }}}
		   			}
		   	} while(next!=null && !waited && !paintedAFrame);
	   	
	    }
	
	    public JCheckBoxMenuItem directSingleBufferChoice = null;
	    public JCheckBoxMenuItem directUnbufferedChoice = null;
	    public JCheckBoxMenuItem singleBufferChoice = null;
	    public JCheckBoxMenuItem doubleBufferChoice = null;
	    public JCheckBoxMenuItem deferredChoice = null;
	    public JCheckBoxMenuItem deferredUnbufferedChoice = null;
	    public JCheckBoxMenuItem doubleBufferNofixedChoice = null;
	    public JCheckBoxMenuItem singleBufferNofixedChoice = null;

	    public boolean handleDeferredEvent(Object target)
	    {
	        if(target==directSingleBufferChoice)
	        	{ if(directSingleBufferChoice.getState()) {setRepaintStrategy(RepaintStrategy.Direct_SingleBuffer);}
	        	  return(true); 
	        	}
	        else if(target==directUnbufferedChoice)
        	{ if(directUnbufferedChoice.getState()) {setRepaintStrategy(RepaintStrategy.Direct_Unbuffered);}
        	  return(true); 
        	}
	        else if(target==doubleBufferChoice)
	        	{ if(doubleBufferChoice.getState()) {setRepaintStrategy(RepaintStrategy.DoubleBuffer);}
	        	  return(true); 
	        	}
	        else if(target==singleBufferChoice)
	        	{ if(singleBufferChoice.getState()) { setRepaintStrategy(RepaintStrategy.SingleBuffer);}
	        	  return(true); 
	        	}
	        else if(target==doubleBufferNofixedChoice)
	        	{ if(doubleBufferNofixedChoice.getState()) {setRepaintStrategy(RepaintStrategy.DoubleBufferNofixed); }
	        	  return(true); 
	        	}
	        else if(target==singleBufferNofixedChoice)
	        	{ if(singleBufferNofixedChoice.getState()) { setRepaintStrategy(RepaintStrategy.SingleBufferNofixed);}
	        	  return(true); 
	        	}
	        else if(target==deferredChoice)
	        	{ if(deferredChoice.getState())  {setRepaintStrategy(RepaintStrategy.Deferred); }
	        	  return(true); 
	        	}
	        else if(target==deferredUnbufferedChoice)
        	{ if(deferredUnbufferedChoice.getState())  {setRepaintStrategy(RepaintStrategy.Deferred_Unbuffered); }
        	  return(true); 
        	}

	        if(frameTimeSlider!=null) { frameTimeSlider.setValue( repaintStrategy.frameTime*100); }
	        if(releaseTimeSlider!=null) { releaseTimeSlider.setValue( repaintStrategy.releaseTime*100);}
	        return(false);
	
	    }
	    private void setBufferMenuChoice()
	    {
	    	if(directSingleBufferChoice!=null) 
	    		{ boolean newstate  = repaintStrategy==RepaintStrategy.Direct_SingleBuffer;
	    		  if(newstate!=directSingleBufferChoice.getState())
	    			  {directSingleBufferChoice.setState(newstate); }}
	    	
	    	if(directUnbufferedChoice!=null) 
    			{ boolean newstate  = repaintStrategy==RepaintStrategy.Direct_Unbuffered;
    			  if(newstate!=directUnbufferedChoice.getState())
    			   {directUnbufferedChoice.setState(newstate); }}

	    	if(singleBufferNofixedChoice!=null)
	    		{ boolean newstate = repaintStrategy==RepaintStrategy.SingleBufferNofixed;
	    		  if(newstate!=singleBufferNofixedChoice.getState())
	    			  {singleBufferNofixedChoice.setState(newstate); }}
	    	if(doubleBufferNofixedChoice!=null) 
	    		{ 	boolean newstate = repaintStrategy==RepaintStrategy.DoubleBufferNofixed;
	    			if(newstate!=doubleBufferNofixedChoice.getState())
	    				{ doubleBufferNofixedChoice.setState(newstate); }}
	    	if(singleBufferChoice!=null) 
	    		{ boolean newstate = repaintStrategy==RepaintStrategy.SingleBuffer;
	    		  if(newstate!=singleBufferChoice.getState())
	    			  { singleBufferChoice.setState(newstate);}}
	    	if(doubleBufferChoice!=null)
	    		{ boolean newstate = repaintStrategy==RepaintStrategy.DoubleBuffer;
	    		  if(newstate!=doubleBufferChoice.getState())
	    			  {doubleBufferChoice.setState(newstate); }}
	    	if(deferredChoice!=null) 
	    		{ boolean newstate = repaintStrategy==RepaintStrategy.Deferred;
	    		  if(newstate!=deferredChoice.getState())
	    			  { deferredChoice.setState(newstate);}}
	    	if(deferredUnbufferedChoice!=null) 
    			{ boolean newstate = repaintStrategy==RepaintStrategy.Deferred_Unbuffered;
    				if(newstate!=deferredUnbufferedChoice.getState())
    				{ deferredUnbufferedChoice.setState(newstate);}}

	    }
	    public void addUIChoices(LFrameProtocol myFrame,DeferredEventManager deferredEvents)
	    {	if(myFrame!=null)
	    	{
	    	JMenu setBuffer = myFrame.addChoiceMenu("Set Buffering",null);

           	directUnbufferedChoice = new JCheckBoxMenuItem("Direct No Buffer");
           	directUnbufferedChoice.addItemListener(deferredEvents);

	    	directSingleBufferChoice = new JCheckBoxMenuItem("Direct Single Buffer");
           	directSingleBufferChoice.addItemListener(deferredEvents);
           	         	
          	singleBufferNofixedChoice = new JCheckBoxMenuItem("Single Buffer, No fixed");
           	singleBufferNofixedChoice.addItemListener(deferredEvents);
          	
           	singleBufferChoice = new JCheckBoxMenuItem("Single Buffer");
           	singleBufferChoice.addItemListener(deferredEvents);

            doubleBufferNofixedChoice = new JCheckBoxMenuItem("Double Buffer, No fixed");
           	doubleBufferNofixedChoice.addItemListener(deferredEvents);

           	doubleBufferChoice = new JCheckBoxMenuItem("Double Buffer");
           	doubleBufferChoice.addItemListener(deferredEvents);
           	
           	deferredChoice = new JCheckBoxMenuItem("Deferred to Worker, Single Buffer");
           	deferredChoice.addItemListener(deferredEvents);
           	
           	deferredUnbufferedChoice = new JCheckBoxMenuItem("Deferred to Worker, Unbuffered");
           	deferredUnbufferedChoice.addItemListener(deferredEvents);
          
          	 setBuffer.add(directUnbufferedChoice);
           	 setBuffer.add(directSingleBufferChoice);
           	 setBuffer.add(singleBufferNofixedChoice);
           	 setBuffer.add(singleBufferChoice);
           	 setBuffer.add(doubleBufferNofixedChoice);
           	 setBuffer.add(doubleBufferChoice);
           	 setBufferMenuChoice();
           	 if(!G.isCodename1())
           	 	{ setBuffer.add(deferredChoice); 
           	 	  setBuffer.add(deferredUnbufferedChoice);
           	 	}
           	 
             //frameTimeSlider = new Slider("frame=",CanvasId.FrameTime,0,1,repaintStrategy.frameTime/100.0);
             //releaseTimeSlider = new Slider("release=",CanvasId.ReleaseTime,0,1,repaintStrategy.releaseTime/100.0);
	    	}
	    }
	    public void positionSliders(Graphics gc,HitPoint highlight,Rectangle goalRect)
	    {
        	if(((repaintStrategy==RepaintStrategy.DoubleBuffer) )
        			|| (repaintStrategy==RepaintStrategy.DoubleBufferNofixed))
        	{
        		if(frameTimeSlider!=null)
        		{
           			G.SetRect(frameTimeSlider,
        			G.Left(goalRect),
        			G.Top(goalRect),
        			G.Height(goalRect)*6,
        			G.Height(goalRect));
           			G.fillRect(gc,Color.white,frameTimeSlider);
           			frameTimeSlider.draw(gc,highlight);
        		}
        		if(releaseTimeSlider!=null)
        		{
           			G.SetRect(releaseTimeSlider,
        			G.Right(frameTimeSlider),
        			G.Top(frameTimeSlider),
        			G.Width(frameTimeSlider),
        			G.Height(frameTimeSlider));
           			G.fillRect(gc,Color.white,releaseTimeSlider);
           			releaseTimeSlider.draw(gc,highlight);
        		}
        	}
	    }
	    
	    int captureState = 0;
	    VNCTransmitter transmitter;
	    public void setTransmitter(VNCTransmitter m) { transmitter = m; }
	    public VNCTransmitter getTransmitter() { return(transmitter); }
	    public boolean isVncActive() { return(transmitter!=null && transmitter.isActive()); };
	    String stopReason = null;
	    public void stopVNC(String reason)
	    {	stopReason = reason;
	    	G.wake(duplicateImage);
	    	duplicateImage = null;

	    	VNCTransmitter tm = transmitter;
	    	transmitter = null;
	    	if(tm!=null)
	    	{
	    		tm.stop(reason);
	    	}
	    }
	    public boolean needsRecapture()
	    {
	    	XImage im = getPaintBuffer();
	    	return(im==null ? true : im.writtenState!=captureState);
	    }
	    // capture a copy of the screen to an image.  This is
	    // synchronized with the actual drawing, so there's no
	    // flashy-flashy behavior
	    public void captureScreen(Image im,int timeout)
	    {
	    	duplicateImage = im;
	    	while(duplicateImage!=null)
	    	{	G.waitAWhile(im, timeout);
	    		client.repaint(); 
	    	}
	    }
	    //
	    // capture the current image, but not synchronized so some flashy
	    // behavior will appear
	    //
		public Image captureScreen() 
		{
			XImage im = createPaintBuffer();
			captureState = im.writtenState;
			return(im.getImage());
		}

		public Rectangle getScreenBound() {
			return(new Rectangle(0,0,client.getWidth(),client.getHeight()));
		}
		double imageSize(Image x,ImageStack im) { return(x==null) ? 0 : x.imageSize(im); }
		
		double imageSize(XImage x,ImageStack im)
		{ return((x==null) ? 0 : x.imageSize(im)); } 
		public double imageSize(ImageStack im)
		{	return( imageSize(allFixed,im)
					+ imageSize(duplicateImage,im)
					+ imageSize(paintBuffer,im)
					+ imageSize(drawBuffer,im)
					);
		}
		
}